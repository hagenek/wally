["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/highlight_DOT_js/lib/languages/coq.js"],"~:js","shadow$provide.module$node_modules$highlight_DOT_js$lib$languages$coq=function(global,require,module,exports){module.exports=function(hljs){return{name:\"Coq\",keywords:{keyword:\"_|0 as at cofix else end exists exists2 fix for forall fun if IF in let match mod Prop return Set then Type using where with Abort About Add Admit Admitted All Arguments Assumptions Axiom Back BackTo Backtrack Bind Blacklist Canonical Cd Check Class Classes Close Coercion Coercions CoFixpoint CoInductive Collection Combined Compute Conjecture Conjectures Constant constr Constraint Constructors Context Corollary CreateHintDb Cut Declare Defined Definition Delimit Dependencies Dependent Derive Drop eauto End Equality Eval Example Existential Existentials Existing Export exporting Extern Extract Extraction Fact Field Fields File Fixpoint Focus for From Function Functional Generalizable Global Goal Grab Grammar Graph Guarded Heap Hint HintDb Hints Hypotheses Hypothesis ident Identity If Immediate Implicit Import Include Inductive Infix Info Initial Inline Inspect Instance Instances Intro Intros Inversion Inversion_clear Language Left Lemma Let Libraries Library Load LoadPath Local Locate Ltac ML Mode Module Modules Monomorphic Morphism Next NoInline Notation Obligation Obligations Opaque Open Optimize Options Parameter Parameters Parametric Path Paths pattern Polymorphic Preterm Print Printing Program Projections Proof Proposition Pwd Qed Quit Rec Record Recursive Redirect Relation Remark Remove Require Reserved Reset Resolve Restart Rewrite Right Ring Rings Save Scheme Scope Scopes Script Search SearchAbout SearchHead SearchPattern SearchRewrite Section Separate Set Setoid Show Solve Sorted Step Strategies Strategy Structure SubClass Table Tables Tactic Term Test Theorem Time Timeout Transparent Type Typeclasses Types Undelimit Undo Unfocus Unfocused Unfold Universe Universes Unset Unshelve using Variable Variables Variant Verbose Visibility where with\".split(\" \"),\nbuilt_in:\"abstract absurd admit after apply as assert assumption at auto autorewrite autounfold before bottom btauto by case case_eq cbn cbv change classical_left classical_right clear clearbody cofix compare compute congruence constr_eq constructor contradict contradiction cut cutrewrite cycle decide decompose dependent destruct destruction dintuition discriminate discrR do double dtauto eapply eassumption eauto ecase econstructor edestruct ediscriminate eelim eexact eexists einduction einjection eleft elim elimtype enough equality erewrite eright esimplify_eq esplit evar exact exactly_once exfalso exists f_equal fail field field_simplify field_simplify_eq first firstorder fix fold fourier functional generalize generalizing gfail give_up has_evar hnf idtac in induction injection instantiate intro intro_pattern intros intuition inversion inversion_clear is_evar is_var lapply lazy left lia lra move native_compute nia nsatz omega once pattern pose progress proof psatz quote record red refine reflexivity remember rename repeat replace revert revgoals rewrite rewrite_strat right ring ring_simplify rtauto set setoid_reflexivity setoid_replace setoid_rewrite setoid_symmetry setoid_transitivity shelve shelve_unifiable simpl simple simplify_eq solve specialize split split_Rabs split_Rmult stepl stepr subst sum swap symmetry tactic tauto time timeout top transitivity trivial try tryif unfold unify until using vm_compute with\".split(\" \")},\ncontains:[hljs.QUOTE_STRING_MODE,hljs.COMMENT(\"\\\\(\\\\*\",\"\\\\*\\\\)\"),hljs.C_NUMBER_MODE,{className:\"type\",excludeBegin:!0,begin:\"\\\\|\\\\s*\",end:\"\\\\w+\"},{begin:/[-=]>/}]}}}","~:source","shadow$provide[\"module$node_modules$highlight_DOT_js$lib$languages$coq\"] = function(global,require,module,exports) {\n/*\nLanguage: Coq\nAuthor: Stephan Boyer <stephan@stephanboyer.com>\nCategory: functional\nWebsite: https://coq.inria.fr\n*/\n\n/** @type LanguageFn */\nfunction coq(hljs) {\n  const KEYWORDS = [\n    \"_|0\",\n    \"as\",\n    \"at\",\n    \"cofix\",\n    \"else\",\n    \"end\",\n    \"exists\",\n    \"exists2\",\n    \"fix\",\n    \"for\",\n    \"forall\",\n    \"fun\",\n    \"if\",\n    \"IF\",\n    \"in\",\n    \"let\",\n    \"match\",\n    \"mod\",\n    \"Prop\",\n    \"return\",\n    \"Set\",\n    \"then\",\n    \"Type\",\n    \"using\",\n    \"where\",\n    \"with\",\n    \"Abort\",\n    \"About\",\n    \"Add\",\n    \"Admit\",\n    \"Admitted\",\n    \"All\",\n    \"Arguments\",\n    \"Assumptions\",\n    \"Axiom\",\n    \"Back\",\n    \"BackTo\",\n    \"Backtrack\",\n    \"Bind\",\n    \"Blacklist\",\n    \"Canonical\",\n    \"Cd\",\n    \"Check\",\n    \"Class\",\n    \"Classes\",\n    \"Close\",\n    \"Coercion\",\n    \"Coercions\",\n    \"CoFixpoint\",\n    \"CoInductive\",\n    \"Collection\",\n    \"Combined\",\n    \"Compute\",\n    \"Conjecture\",\n    \"Conjectures\",\n    \"Constant\",\n    \"constr\",\n    \"Constraint\",\n    \"Constructors\",\n    \"Context\",\n    \"Corollary\",\n    \"CreateHintDb\",\n    \"Cut\",\n    \"Declare\",\n    \"Defined\",\n    \"Definition\",\n    \"Delimit\",\n    \"Dependencies\",\n    \"Dependent\",\n    \"Derive\",\n    \"Drop\",\n    \"eauto\",\n    \"End\",\n    \"Equality\",\n    \"Eval\",\n    \"Example\",\n    \"Existential\",\n    \"Existentials\",\n    \"Existing\",\n    \"Export\",\n    \"exporting\",\n    \"Extern\",\n    \"Extract\",\n    \"Extraction\",\n    \"Fact\",\n    \"Field\",\n    \"Fields\",\n    \"File\",\n    \"Fixpoint\",\n    \"Focus\",\n    \"for\",\n    \"From\",\n    \"Function\",\n    \"Functional\",\n    \"Generalizable\",\n    \"Global\",\n    \"Goal\",\n    \"Grab\",\n    \"Grammar\",\n    \"Graph\",\n    \"Guarded\",\n    \"Heap\",\n    \"Hint\",\n    \"HintDb\",\n    \"Hints\",\n    \"Hypotheses\",\n    \"Hypothesis\",\n    \"ident\",\n    \"Identity\",\n    \"If\",\n    \"Immediate\",\n    \"Implicit\",\n    \"Import\",\n    \"Include\",\n    \"Inductive\",\n    \"Infix\",\n    \"Info\",\n    \"Initial\",\n    \"Inline\",\n    \"Inspect\",\n    \"Instance\",\n    \"Instances\",\n    \"Intro\",\n    \"Intros\",\n    \"Inversion\",\n    \"Inversion_clear\",\n    \"Language\",\n    \"Left\",\n    \"Lemma\",\n    \"Let\",\n    \"Libraries\",\n    \"Library\",\n    \"Load\",\n    \"LoadPath\",\n    \"Local\",\n    \"Locate\",\n    \"Ltac\",\n    \"ML\",\n    \"Mode\",\n    \"Module\",\n    \"Modules\",\n    \"Monomorphic\",\n    \"Morphism\",\n    \"Next\",\n    \"NoInline\",\n    \"Notation\",\n    \"Obligation\",\n    \"Obligations\",\n    \"Opaque\",\n    \"Open\",\n    \"Optimize\",\n    \"Options\",\n    \"Parameter\",\n    \"Parameters\",\n    \"Parametric\",\n    \"Path\",\n    \"Paths\",\n    \"pattern\",\n    \"Polymorphic\",\n    \"Preterm\",\n    \"Print\",\n    \"Printing\",\n    \"Program\",\n    \"Projections\",\n    \"Proof\",\n    \"Proposition\",\n    \"Pwd\",\n    \"Qed\",\n    \"Quit\",\n    \"Rec\",\n    \"Record\",\n    \"Recursive\",\n    \"Redirect\",\n    \"Relation\",\n    \"Remark\",\n    \"Remove\",\n    \"Require\",\n    \"Reserved\",\n    \"Reset\",\n    \"Resolve\",\n    \"Restart\",\n    \"Rewrite\",\n    \"Right\",\n    \"Ring\",\n    \"Rings\",\n    \"Save\",\n    \"Scheme\",\n    \"Scope\",\n    \"Scopes\",\n    \"Script\",\n    \"Search\",\n    \"SearchAbout\",\n    \"SearchHead\",\n    \"SearchPattern\",\n    \"SearchRewrite\",\n    \"Section\",\n    \"Separate\",\n    \"Set\",\n    \"Setoid\",\n    \"Show\",\n    \"Solve\",\n    \"Sorted\",\n    \"Step\",\n    \"Strategies\",\n    \"Strategy\",\n    \"Structure\",\n    \"SubClass\",\n    \"Table\",\n    \"Tables\",\n    \"Tactic\",\n    \"Term\",\n    \"Test\",\n    \"Theorem\",\n    \"Time\",\n    \"Timeout\",\n    \"Transparent\",\n    \"Type\",\n    \"Typeclasses\",\n    \"Types\",\n    \"Undelimit\",\n    \"Undo\",\n    \"Unfocus\",\n    \"Unfocused\",\n    \"Unfold\",\n    \"Universe\",\n    \"Universes\",\n    \"Unset\",\n    \"Unshelve\",\n    \"using\",\n    \"Variable\",\n    \"Variables\",\n    \"Variant\",\n    \"Verbose\",\n    \"Visibility\",\n    \"where\",\n    \"with\"\n  ];\n  const BUILT_INS = [\n    \"abstract\",\n    \"absurd\",\n    \"admit\",\n    \"after\",\n    \"apply\",\n    \"as\",\n    \"assert\",\n    \"assumption\",\n    \"at\",\n    \"auto\",\n    \"autorewrite\",\n    \"autounfold\",\n    \"before\",\n    \"bottom\",\n    \"btauto\",\n    \"by\",\n    \"case\",\n    \"case_eq\",\n    \"cbn\",\n    \"cbv\",\n    \"change\",\n    \"classical_left\",\n    \"classical_right\",\n    \"clear\",\n    \"clearbody\",\n    \"cofix\",\n    \"compare\",\n    \"compute\",\n    \"congruence\",\n    \"constr_eq\",\n    \"constructor\",\n    \"contradict\",\n    \"contradiction\",\n    \"cut\",\n    \"cutrewrite\",\n    \"cycle\",\n    \"decide\",\n    \"decompose\",\n    \"dependent\",\n    \"destruct\",\n    \"destruction\",\n    \"dintuition\",\n    \"discriminate\",\n    \"discrR\",\n    \"do\",\n    \"double\",\n    \"dtauto\",\n    \"eapply\",\n    \"eassumption\",\n    \"eauto\",\n    \"ecase\",\n    \"econstructor\",\n    \"edestruct\",\n    \"ediscriminate\",\n    \"eelim\",\n    \"eexact\",\n    \"eexists\",\n    \"einduction\",\n    \"einjection\",\n    \"eleft\",\n    \"elim\",\n    \"elimtype\",\n    \"enough\",\n    \"equality\",\n    \"erewrite\",\n    \"eright\",\n    \"esimplify_eq\",\n    \"esplit\",\n    \"evar\",\n    \"exact\",\n    \"exactly_once\",\n    \"exfalso\",\n    \"exists\",\n    \"f_equal\",\n    \"fail\",\n    \"field\",\n    \"field_simplify\",\n    \"field_simplify_eq\",\n    \"first\",\n    \"firstorder\",\n    \"fix\",\n    \"fold\",\n    \"fourier\",\n    \"functional\",\n    \"generalize\",\n    \"generalizing\",\n    \"gfail\",\n    \"give_up\",\n    \"has_evar\",\n    \"hnf\",\n    \"idtac\",\n    \"in\",\n    \"induction\",\n    \"injection\",\n    \"instantiate\",\n    \"intro\",\n    \"intro_pattern\",\n    \"intros\",\n    \"intuition\",\n    \"inversion\",\n    \"inversion_clear\",\n    \"is_evar\",\n    \"is_var\",\n    \"lapply\",\n    \"lazy\",\n    \"left\",\n    \"lia\",\n    \"lra\",\n    \"move\",\n    \"native_compute\",\n    \"nia\",\n    \"nsatz\",\n    \"omega\",\n    \"once\",\n    \"pattern\",\n    \"pose\",\n    \"progress\",\n    \"proof\",\n    \"psatz\",\n    \"quote\",\n    \"record\",\n    \"red\",\n    \"refine\",\n    \"reflexivity\",\n    \"remember\",\n    \"rename\",\n    \"repeat\",\n    \"replace\",\n    \"revert\",\n    \"revgoals\",\n    \"rewrite\",\n    \"rewrite_strat\",\n    \"right\",\n    \"ring\",\n    \"ring_simplify\",\n    \"rtauto\",\n    \"set\",\n    \"setoid_reflexivity\",\n    \"setoid_replace\",\n    \"setoid_rewrite\",\n    \"setoid_symmetry\",\n    \"setoid_transitivity\",\n    \"shelve\",\n    \"shelve_unifiable\",\n    \"simpl\",\n    \"simple\",\n    \"simplify_eq\",\n    \"solve\",\n    \"specialize\",\n    \"split\",\n    \"split_Rabs\",\n    \"split_Rmult\",\n    \"stepl\",\n    \"stepr\",\n    \"subst\",\n    \"sum\",\n    \"swap\",\n    \"symmetry\",\n    \"tactic\",\n    \"tauto\",\n    \"time\",\n    \"timeout\",\n    \"top\",\n    \"transitivity\",\n    \"trivial\",\n    \"try\",\n    \"tryif\",\n    \"unfold\",\n    \"unify\",\n    \"until\",\n    \"using\",\n    \"vm_compute\",\n    \"with\"\n  ];\n  return {\n    name: 'Coq',\n    keywords: {\n      keyword: KEYWORDS,\n      built_in: BUILT_INS\n    },\n    contains: [\n      hljs.QUOTE_STRING_MODE,\n      hljs.COMMENT('\\\\(\\\\*', '\\\\*\\\\)'),\n      hljs.C_NUMBER_MODE,\n      {\n        className: 'type',\n        excludeBegin: true,\n        begin: '\\\\|\\\\s*',\n        end: '\\\\w+'\n      },\n      { // relevance booster\n        begin: /[-=]>/\n      }\n    ]\n  };\n}\n\nmodule.exports = coq;\n\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js"]],"~:properties",["^5",["excludeBegin","begin","className","contains","name","built_in","keyword","keywords","end"]],"~:compiled-at",1638904261484,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$highlight_DOT_js$lib$languages$coq.js\",\n\"lineCount\":3,\n\"mappings\":\"AAAAA,cAAA,CAAA,sDAAA,CAA2E,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CA8bnHD,MAAOC,CAAAA,OAAP,CArbAC,QAAY,CAACC,IAAD,CAAO,CA8ZjB,MAAO,CACLC,KAAM,KADD,CAELC,SAAU,CACRC,QAhaaC,qvDAAAA,CAAAA,KAAAA,CAAAA,GAAAA,CA+ZL;AAERC,SAnLcC,u5CAAAA,CAAAA,KAAAA,CAAAA,GAAAA,CAiLN,CAFL;AAMLC,SAAU,CACRP,IAAKQ,CAAAA,iBADG,CAERR,IAAKS,CAAAA,OAAL,CAAa,QAAb,CAAuB,QAAvB,CAFQ,CAGRT,IAAKU,CAAAA,aAHG,CAIR,CACEC,UAAW,MADb,CAEEC,aAAc,CAAA,CAFhB,CAGEC,MAAO,SAHT,CAIEC,IAAK,MAJP,CAJQ,CAUR,CACED,MAAO,OADT,CAVQ,CANL,CA9ZU,CATgG;\",\n\"sources\":[\"node_modules/highlight_DOT_js/lib/languages/coq.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$highlight_DOT_js$lib$languages$coq\\\"] = function(global,require,module,exports) {\\n/*\\nLanguage: Coq\\nAuthor: Stephan Boyer <stephan@stephanboyer.com>\\nCategory: functional\\nWebsite: https://coq.inria.fr\\n*/\\n\\n/** @type LanguageFn */\\nfunction coq(hljs) {\\n  const KEYWORDS = [\\n    \\\"_|0\\\",\\n    \\\"as\\\",\\n    \\\"at\\\",\\n    \\\"cofix\\\",\\n    \\\"else\\\",\\n    \\\"end\\\",\\n    \\\"exists\\\",\\n    \\\"exists2\\\",\\n    \\\"fix\\\",\\n    \\\"for\\\",\\n    \\\"forall\\\",\\n    \\\"fun\\\",\\n    \\\"if\\\",\\n    \\\"IF\\\",\\n    \\\"in\\\",\\n    \\\"let\\\",\\n    \\\"match\\\",\\n    \\\"mod\\\",\\n    \\\"Prop\\\",\\n    \\\"return\\\",\\n    \\\"Set\\\",\\n    \\\"then\\\",\\n    \\\"Type\\\",\\n    \\\"using\\\",\\n    \\\"where\\\",\\n    \\\"with\\\",\\n    \\\"Abort\\\",\\n    \\\"About\\\",\\n    \\\"Add\\\",\\n    \\\"Admit\\\",\\n    \\\"Admitted\\\",\\n    \\\"All\\\",\\n    \\\"Arguments\\\",\\n    \\\"Assumptions\\\",\\n    \\\"Axiom\\\",\\n    \\\"Back\\\",\\n    \\\"BackTo\\\",\\n    \\\"Backtrack\\\",\\n    \\\"Bind\\\",\\n    \\\"Blacklist\\\",\\n    \\\"Canonical\\\",\\n    \\\"Cd\\\",\\n    \\\"Check\\\",\\n    \\\"Class\\\",\\n    \\\"Classes\\\",\\n    \\\"Close\\\",\\n    \\\"Coercion\\\",\\n    \\\"Coercions\\\",\\n    \\\"CoFixpoint\\\",\\n    \\\"CoInductive\\\",\\n    \\\"Collection\\\",\\n    \\\"Combined\\\",\\n    \\\"Compute\\\",\\n    \\\"Conjecture\\\",\\n    \\\"Conjectures\\\",\\n    \\\"Constant\\\",\\n    \\\"constr\\\",\\n    \\\"Constraint\\\",\\n    \\\"Constructors\\\",\\n    \\\"Context\\\",\\n    \\\"Corollary\\\",\\n    \\\"CreateHintDb\\\",\\n    \\\"Cut\\\",\\n    \\\"Declare\\\",\\n    \\\"Defined\\\",\\n    \\\"Definition\\\",\\n    \\\"Delimit\\\",\\n    \\\"Dependencies\\\",\\n    \\\"Dependent\\\",\\n    \\\"Derive\\\",\\n    \\\"Drop\\\",\\n    \\\"eauto\\\",\\n    \\\"End\\\",\\n    \\\"Equality\\\",\\n    \\\"Eval\\\",\\n    \\\"Example\\\",\\n    \\\"Existential\\\",\\n    \\\"Existentials\\\",\\n    \\\"Existing\\\",\\n    \\\"Export\\\",\\n    \\\"exporting\\\",\\n    \\\"Extern\\\",\\n    \\\"Extract\\\",\\n    \\\"Extraction\\\",\\n    \\\"Fact\\\",\\n    \\\"Field\\\",\\n    \\\"Fields\\\",\\n    \\\"File\\\",\\n    \\\"Fixpoint\\\",\\n    \\\"Focus\\\",\\n    \\\"for\\\",\\n    \\\"From\\\",\\n    \\\"Function\\\",\\n    \\\"Functional\\\",\\n    \\\"Generalizable\\\",\\n    \\\"Global\\\",\\n    \\\"Goal\\\",\\n    \\\"Grab\\\",\\n    \\\"Grammar\\\",\\n    \\\"Graph\\\",\\n    \\\"Guarded\\\",\\n    \\\"Heap\\\",\\n    \\\"Hint\\\",\\n    \\\"HintDb\\\",\\n    \\\"Hints\\\",\\n    \\\"Hypotheses\\\",\\n    \\\"Hypothesis\\\",\\n    \\\"ident\\\",\\n    \\\"Identity\\\",\\n    \\\"If\\\",\\n    \\\"Immediate\\\",\\n    \\\"Implicit\\\",\\n    \\\"Import\\\",\\n    \\\"Include\\\",\\n    \\\"Inductive\\\",\\n    \\\"Infix\\\",\\n    \\\"Info\\\",\\n    \\\"Initial\\\",\\n    \\\"Inline\\\",\\n    \\\"Inspect\\\",\\n    \\\"Instance\\\",\\n    \\\"Instances\\\",\\n    \\\"Intro\\\",\\n    \\\"Intros\\\",\\n    \\\"Inversion\\\",\\n    \\\"Inversion_clear\\\",\\n    \\\"Language\\\",\\n    \\\"Left\\\",\\n    \\\"Lemma\\\",\\n    \\\"Let\\\",\\n    \\\"Libraries\\\",\\n    \\\"Library\\\",\\n    \\\"Load\\\",\\n    \\\"LoadPath\\\",\\n    \\\"Local\\\",\\n    \\\"Locate\\\",\\n    \\\"Ltac\\\",\\n    \\\"ML\\\",\\n    \\\"Mode\\\",\\n    \\\"Module\\\",\\n    \\\"Modules\\\",\\n    \\\"Monomorphic\\\",\\n    \\\"Morphism\\\",\\n    \\\"Next\\\",\\n    \\\"NoInline\\\",\\n    \\\"Notation\\\",\\n    \\\"Obligation\\\",\\n    \\\"Obligations\\\",\\n    \\\"Opaque\\\",\\n    \\\"Open\\\",\\n    \\\"Optimize\\\",\\n    \\\"Options\\\",\\n    \\\"Parameter\\\",\\n    \\\"Parameters\\\",\\n    \\\"Parametric\\\",\\n    \\\"Path\\\",\\n    \\\"Paths\\\",\\n    \\\"pattern\\\",\\n    \\\"Polymorphic\\\",\\n    \\\"Preterm\\\",\\n    \\\"Print\\\",\\n    \\\"Printing\\\",\\n    \\\"Program\\\",\\n    \\\"Projections\\\",\\n    \\\"Proof\\\",\\n    \\\"Proposition\\\",\\n    \\\"Pwd\\\",\\n    \\\"Qed\\\",\\n    \\\"Quit\\\",\\n    \\\"Rec\\\",\\n    \\\"Record\\\",\\n    \\\"Recursive\\\",\\n    \\\"Redirect\\\",\\n    \\\"Relation\\\",\\n    \\\"Remark\\\",\\n    \\\"Remove\\\",\\n    \\\"Require\\\",\\n    \\\"Reserved\\\",\\n    \\\"Reset\\\",\\n    \\\"Resolve\\\",\\n    \\\"Restart\\\",\\n    \\\"Rewrite\\\",\\n    \\\"Right\\\",\\n    \\\"Ring\\\",\\n    \\\"Rings\\\",\\n    \\\"Save\\\",\\n    \\\"Scheme\\\",\\n    \\\"Scope\\\",\\n    \\\"Scopes\\\",\\n    \\\"Script\\\",\\n    \\\"Search\\\",\\n    \\\"SearchAbout\\\",\\n    \\\"SearchHead\\\",\\n    \\\"SearchPattern\\\",\\n    \\\"SearchRewrite\\\",\\n    \\\"Section\\\",\\n    \\\"Separate\\\",\\n    \\\"Set\\\",\\n    \\\"Setoid\\\",\\n    \\\"Show\\\",\\n    \\\"Solve\\\",\\n    \\\"Sorted\\\",\\n    \\\"Step\\\",\\n    \\\"Strategies\\\",\\n    \\\"Strategy\\\",\\n    \\\"Structure\\\",\\n    \\\"SubClass\\\",\\n    \\\"Table\\\",\\n    \\\"Tables\\\",\\n    \\\"Tactic\\\",\\n    \\\"Term\\\",\\n    \\\"Test\\\",\\n    \\\"Theorem\\\",\\n    \\\"Time\\\",\\n    \\\"Timeout\\\",\\n    \\\"Transparent\\\",\\n    \\\"Type\\\",\\n    \\\"Typeclasses\\\",\\n    \\\"Types\\\",\\n    \\\"Undelimit\\\",\\n    \\\"Undo\\\",\\n    \\\"Unfocus\\\",\\n    \\\"Unfocused\\\",\\n    \\\"Unfold\\\",\\n    \\\"Universe\\\",\\n    \\\"Universes\\\",\\n    \\\"Unset\\\",\\n    \\\"Unshelve\\\",\\n    \\\"using\\\",\\n    \\\"Variable\\\",\\n    \\\"Variables\\\",\\n    \\\"Variant\\\",\\n    \\\"Verbose\\\",\\n    \\\"Visibility\\\",\\n    \\\"where\\\",\\n    \\\"with\\\"\\n  ];\\n  const BUILT_INS = [\\n    \\\"abstract\\\",\\n    \\\"absurd\\\",\\n    \\\"admit\\\",\\n    \\\"after\\\",\\n    \\\"apply\\\",\\n    \\\"as\\\",\\n    \\\"assert\\\",\\n    \\\"assumption\\\",\\n    \\\"at\\\",\\n    \\\"auto\\\",\\n    \\\"autorewrite\\\",\\n    \\\"autounfold\\\",\\n    \\\"before\\\",\\n    \\\"bottom\\\",\\n    \\\"btauto\\\",\\n    \\\"by\\\",\\n    \\\"case\\\",\\n    \\\"case_eq\\\",\\n    \\\"cbn\\\",\\n    \\\"cbv\\\",\\n    \\\"change\\\",\\n    \\\"classical_left\\\",\\n    \\\"classical_right\\\",\\n    \\\"clear\\\",\\n    \\\"clearbody\\\",\\n    \\\"cofix\\\",\\n    \\\"compare\\\",\\n    \\\"compute\\\",\\n    \\\"congruence\\\",\\n    \\\"constr_eq\\\",\\n    \\\"constructor\\\",\\n    \\\"contradict\\\",\\n    \\\"contradiction\\\",\\n    \\\"cut\\\",\\n    \\\"cutrewrite\\\",\\n    \\\"cycle\\\",\\n    \\\"decide\\\",\\n    \\\"decompose\\\",\\n    \\\"dependent\\\",\\n    \\\"destruct\\\",\\n    \\\"destruction\\\",\\n    \\\"dintuition\\\",\\n    \\\"discriminate\\\",\\n    \\\"discrR\\\",\\n    \\\"do\\\",\\n    \\\"double\\\",\\n    \\\"dtauto\\\",\\n    \\\"eapply\\\",\\n    \\\"eassumption\\\",\\n    \\\"eauto\\\",\\n    \\\"ecase\\\",\\n    \\\"econstructor\\\",\\n    \\\"edestruct\\\",\\n    \\\"ediscriminate\\\",\\n    \\\"eelim\\\",\\n    \\\"eexact\\\",\\n    \\\"eexists\\\",\\n    \\\"einduction\\\",\\n    \\\"einjection\\\",\\n    \\\"eleft\\\",\\n    \\\"elim\\\",\\n    \\\"elimtype\\\",\\n    \\\"enough\\\",\\n    \\\"equality\\\",\\n    \\\"erewrite\\\",\\n    \\\"eright\\\",\\n    \\\"esimplify_eq\\\",\\n    \\\"esplit\\\",\\n    \\\"evar\\\",\\n    \\\"exact\\\",\\n    \\\"exactly_once\\\",\\n    \\\"exfalso\\\",\\n    \\\"exists\\\",\\n    \\\"f_equal\\\",\\n    \\\"fail\\\",\\n    \\\"field\\\",\\n    \\\"field_simplify\\\",\\n    \\\"field_simplify_eq\\\",\\n    \\\"first\\\",\\n    \\\"firstorder\\\",\\n    \\\"fix\\\",\\n    \\\"fold\\\",\\n    \\\"fourier\\\",\\n    \\\"functional\\\",\\n    \\\"generalize\\\",\\n    \\\"generalizing\\\",\\n    \\\"gfail\\\",\\n    \\\"give_up\\\",\\n    \\\"has_evar\\\",\\n    \\\"hnf\\\",\\n    \\\"idtac\\\",\\n    \\\"in\\\",\\n    \\\"induction\\\",\\n    \\\"injection\\\",\\n    \\\"instantiate\\\",\\n    \\\"intro\\\",\\n    \\\"intro_pattern\\\",\\n    \\\"intros\\\",\\n    \\\"intuition\\\",\\n    \\\"inversion\\\",\\n    \\\"inversion_clear\\\",\\n    \\\"is_evar\\\",\\n    \\\"is_var\\\",\\n    \\\"lapply\\\",\\n    \\\"lazy\\\",\\n    \\\"left\\\",\\n    \\\"lia\\\",\\n    \\\"lra\\\",\\n    \\\"move\\\",\\n    \\\"native_compute\\\",\\n    \\\"nia\\\",\\n    \\\"nsatz\\\",\\n    \\\"omega\\\",\\n    \\\"once\\\",\\n    \\\"pattern\\\",\\n    \\\"pose\\\",\\n    \\\"progress\\\",\\n    \\\"proof\\\",\\n    \\\"psatz\\\",\\n    \\\"quote\\\",\\n    \\\"record\\\",\\n    \\\"red\\\",\\n    \\\"refine\\\",\\n    \\\"reflexivity\\\",\\n    \\\"remember\\\",\\n    \\\"rename\\\",\\n    \\\"repeat\\\",\\n    \\\"replace\\\",\\n    \\\"revert\\\",\\n    \\\"revgoals\\\",\\n    \\\"rewrite\\\",\\n    \\\"rewrite_strat\\\",\\n    \\\"right\\\",\\n    \\\"ring\\\",\\n    \\\"ring_simplify\\\",\\n    \\\"rtauto\\\",\\n    \\\"set\\\",\\n    \\\"setoid_reflexivity\\\",\\n    \\\"setoid_replace\\\",\\n    \\\"setoid_rewrite\\\",\\n    \\\"setoid_symmetry\\\",\\n    \\\"setoid_transitivity\\\",\\n    \\\"shelve\\\",\\n    \\\"shelve_unifiable\\\",\\n    \\\"simpl\\\",\\n    \\\"simple\\\",\\n    \\\"simplify_eq\\\",\\n    \\\"solve\\\",\\n    \\\"specialize\\\",\\n    \\\"split\\\",\\n    \\\"split_Rabs\\\",\\n    \\\"split_Rmult\\\",\\n    \\\"stepl\\\",\\n    \\\"stepr\\\",\\n    \\\"subst\\\",\\n    \\\"sum\\\",\\n    \\\"swap\\\",\\n    \\\"symmetry\\\",\\n    \\\"tactic\\\",\\n    \\\"tauto\\\",\\n    \\\"time\\\",\\n    \\\"timeout\\\",\\n    \\\"top\\\",\\n    \\\"transitivity\\\",\\n    \\\"trivial\\\",\\n    \\\"try\\\",\\n    \\\"tryif\\\",\\n    \\\"unfold\\\",\\n    \\\"unify\\\",\\n    \\\"until\\\",\\n    \\\"using\\\",\\n    \\\"vm_compute\\\",\\n    \\\"with\\\"\\n  ];\\n  return {\\n    name: 'Coq',\\n    keywords: {\\n      keyword: KEYWORDS,\\n      built_in: BUILT_INS\\n    },\\n    contains: [\\n      hljs.QUOTE_STRING_MODE,\\n      hljs.COMMENT('\\\\\\\\(\\\\\\\\*', '\\\\\\\\*\\\\\\\\)'),\\n      hljs.C_NUMBER_MODE,\\n      {\\n        className: 'type',\\n        excludeBegin: true,\\n        begin: '\\\\\\\\|\\\\\\\\s*',\\n        end: '\\\\\\\\w+'\\n      },\\n      { // relevance booster\\n        begin: /[-=]>/\\n      }\\n    ]\\n  };\\n}\\n\\nmodule.exports = coq;\\n\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"coq\",\"hljs\",\"name\",\"keywords\",\"keyword\",\"KEYWORDS\",\"built_in\",\"BUILT_INS\",\"contains\",\"QUOTE_STRING_MODE\",\"COMMENT\",\"C_NUMBER_MODE\",\"className\",\"excludeBegin\",\"begin\",\"end\"]\n}\n"]