["^ ","~:output",["^ ","~:js","goog.provide('zprint.range');\n/**\n * If a line number n is in a particular edamame row, return the row map.\n *   If it is not in the row, return +1 or -1 to indicate which direction\n *   to look.\n */\nzprint.range.in_row_QMARK_ = (function zprint$range$in_row_QMARK_(n,row){\nif(cljs.core.truth_(row)){\nif((((new cljs.core.Keyword(null,\"row\",\"row\",-570139521).cljs$core$IFn$_invoke$arity$1(row) <= n)) && ((n <= new cljs.core.Keyword(null,\"end-row\",\"end-row\",-545103581).cljs$core$IFn$_invoke$arity$1(row))))){\nreturn row;\n} else {\nif((n < new cljs.core.Keyword(null,\"row\",\"row\",-570139521).cljs$core$IFn$_invoke$arity$1(row))){\nreturn (-1);\n} else {\nreturn (1);\n}\n}\n} else {\nreturn null;\n}\n});\n/**\n * Given two rows, is the first before the second?\n */\nzprint.range.row_before_QMARK_ = (function zprint$range$row_before_QMARK_(row_a,row_b){\nreturn (new cljs.core.Keyword(null,\"end-row\",\"end-row\",-545103581).cljs$core$IFn$_invoke$arity$1(row_a) < new cljs.core.Keyword(null,\"row\",\"row\",-570139521).cljs$core$IFn$_invoke$arity$1(row_b));\n});\n/**\n * Given two rows, if the linenumber is between the rows, return true, else\n *   nil.\n */\nzprint.range.between_rows_QMARK_ = (function zprint$range$between_rows_QMARK_(linenumber,row_a,row_b){\nif(((cljs.core.map_QMARK_(row_a)) && (cljs.core.map_QMARK_(row_b)))){\nif(zprint.range.row_before_QMARK_(row_a,row_b)){\nreturn (((new cljs.core.Keyword(null,\"end-row\",\"end-row\",-545103581).cljs$core$IFn$_invoke$arity$1(row_a) < linenumber)) && ((linenumber < new cljs.core.Keyword(null,\"row\",\"row\",-570139521).cljs$core$IFn$_invoke$arity$1(row_b))));\n} else {\nreturn (((new cljs.core.Keyword(null,\"end-row\",\"end-row\",-545103581).cljs$core$IFn$_invoke$arity$1(row_b) < linenumber)) && ((linenumber < new cljs.core.Keyword(null,\"row\",\"row\",-570139521).cljs$core$IFn$_invoke$arity$1(row_a))));\n}\n} else {\nreturn null;\n}\n});\n/**\n * Given a row-vec, and a current index into the row-vec, if the\n *   linenumber is within that row, return the index to that row.   If\n *   the linenumber is not in that row, then scan either way for\n *   max-tries looking for a match for this linenumber.  Return the\n *   row index if a row is found containing this linenumber. If it is\n *   between two rows, return the row after.  If we fall off the either\n *   end of the row-vec, then return :before-beginning or :beyone-end.  \n *   If we don't find anything after trying for max-tries, :before or\n *   :after, depending on which way we should try next.\n */\nzprint.range.scan_for_row = (function zprint$range$scan_for_row(row_vec,row_vec_index,linenumber,max_tries){\nvar current_index = row_vec_index;\nvar previous_index = null;\nvar tries = (0);\nwhile(true){\nvar row = cljs.core.get.cljs$core$IFn$_invoke$arity$2(row_vec,current_index);\nvar row_or_direction = zprint.range.in_row_QMARK_(linenumber,row);\nif(cljs.core.map_QMARK_(row_or_direction)){\nreturn current_index;\n} else {\nif((row_or_direction == null)){\nif((current_index > (0))){\nreturn new cljs.core.Keyword(null,\"beyond-end\",\"beyond-end\",487000285);\n} else {\nreturn new cljs.core.Keyword(null,\"before-beginning\",\"before-beginning\",485705715);\n}\n} else {\nif((tries >= max_tries)){\nif((row_or_direction > (0))){\nreturn new cljs.core.Keyword(null,\"after\",\"after\",594996914);\n} else {\nreturn new cljs.core.Keyword(null,\"before\",\"before\",-1633692388);\n}\n} else {\nvar next_index = (current_index + row_or_direction);\nvar next_row = cljs.core.get.cljs$core$IFn$_invoke$arity$2(row_vec,next_index);\nvar row_or_direction__$1 = zprint.range.in_row_QMARK_(linenumber,next_row);\nif(cljs.core.map_QMARK_(row_or_direction__$1)){\nreturn next_index;\n} else {\nif((row_or_direction__$1 == null)){\nif((next_index > (0))){\nreturn new cljs.core.Keyword(null,\"beyond-end\",\"beyond-end\",487000285);\n} else {\nreturn new cljs.core.Keyword(null,\"before-beginning\",\"before-beginning\",485705715);\n}\n} else {\nif(cljs.core.truth_(zprint.range.between_rows_QMARK_(linenumber,row,next_row))){\nif(zprint.range.row_before_QMARK_(row,next_row)){\nreturn next_index;\n} else {\nreturn current_index;\n}\n} else {\nvar G__45702 = (current_index + row_or_direction__$1);\nvar G__45703 = current_index;\nvar G__45704 = (tries + (1));\ncurrent_index = G__45702;\nprevious_index = G__45703;\ntries = G__45704;\ncontinue;\n}\n\n}\n}\n}\n\n}\n}\nbreak;\n}\n});\n/**\n * Return the absolute value of a number.\n */\nzprint.range.abs = (function zprint$range$abs(n){\nif((n < (0))){\nreturn (- n);\n} else {\nreturn n;\n}\n});\n/**\n * Given a vector of rows, find the row that contains a line number,\n *   linenumber, and return the number of that row in the vector.\n *   row-vec looks like this: \n *   [{:row 2, :col 1, :end-row 7, :end-col 21}\n * {:row 9, :col 1, :end-row 18, :end-col 6} \n * {:row 20, :col 1, :end-row 29, :end-col 6}]\n *   If none exists, return the next row. Note that line numbers are 1\n *   based, not zero based for this routine and the information in\n *   row-vec, but the index into row-vec that this routine returns is\n *   zero based.  Uses a binary search. If the line number is before the\n *   first information in the row-vec, returns :before-beginning, and\n *   if it is after the last information in the row-vec, returns\n *   :beyond-end. Note that the row-vec as returned from edamame\n *   parse-string-all contains not only maps like {:row 5 :end-row 10}\n *   but also nils for things that didn't have paired delimiters around\n *   them (e.g., keywords, strings, etc.).  You must remove those\n *   from row-vec before calling find-row.  Note that find-row returns an \n *   index into row-vec, and it must be the row-vec that has had nils \n *   removed from it (or this routine would do that for you).\n */\nzprint.range.find_row = (function zprint$range$find_row(var_args){\nvar G__45661 = arguments.length;\nswitch (G__45661) {\ncase 4:\nreturn zprint.range.find_row.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ncase 3:\nreturn zprint.range.find_row.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\n(zprint.range.find_row.cljs$core$IFn$_invoke$arity$4 = (function (row_vec,linenumber,dbg_QMARK_,scan_size){\nif(cljs.core.truth_(dbg_QMARK_)){\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\"find-row: linenumber:\",linenumber,\"scan-size:\",scan_size], 0));\n} else {\n}\n\nvar size = cljs.core.count(row_vec);\nvar row_vec_index = ((size / (2)) | (0));\nvar previous_index = (0);\nvar tries = (0);\nwhile(true){\nif((tries > (10))){\nreturn new cljs.core.Keyword(null,\"fail\",\"fail\",1706214930);\n} else {\nvar maybe_index = zprint.range.scan_for_row(row_vec,row_vec_index,linenumber,scan_size);\nif(typeof maybe_index === 'number'){\nreturn maybe_index;\n} else {\nif(((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(maybe_index,new cljs.core.Keyword(null,\"before-beginning\",\"before-beginning\",485705715))) || (cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(maybe_index,new cljs.core.Keyword(null,\"beyond-end\",\"beyond-end\",487000285))))){\nreturn maybe_index;\n} else {\nvar G__45706 = (function (){var G__45667 = row_vec_index;\nvar G__45668 = ((zprint.range.abs((row_vec_index - previous_index)) / (2)) | (0));\nvar fexpr__45666 = ((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(maybe_index,new cljs.core.Keyword(null,\"before\",\"before\",-1633692388)))?cljs.core._:cljs.core._PLUS_);\nreturn (fexpr__45666.cljs$core$IFn$_invoke$arity$2 ? fexpr__45666.cljs$core$IFn$_invoke$arity$2(G__45667,G__45668) : fexpr__45666.call(null,G__45667,G__45668));\n})();\nvar G__45707 = row_vec_index;\nvar G__45708 = (tries + (1));\nrow_vec_index = G__45706;\nprevious_index = G__45707;\ntries = G__45708;\ncontinue;\n\n}\n}\n}\nbreak;\n}\n}));\n\n(zprint.range.find_row.cljs$core$IFn$_invoke$arity$3 = (function (row_vec,n,dbg_QMARK_){\nreturn zprint.range.find_row.cljs$core$IFn$_invoke$arity$4(row_vec,n,dbg_QMARK_,(4));\n}));\n\n(zprint.range.find_row.cljs$lang$maxFixedArity = 4);\n\n/**\n * Given a sequence of lines and a starting line index in that sequence,\n *   return the index of the first non-blank line including or after that\n *   starting line index.\n */\nzprint.range.next_non_blank_line = (function zprint$range$next_non_blank_line(line_vec,index){\nvar max_idx = (cljs.core.count(line_vec) - (1));\nvar idx = index;\nwhile(true){\nvar line = cljs.core.nth.cljs$core$IFn$_invoke$arity$2(line_vec,idx);\nif((((!(cljs.core.empty_QMARK_(clojure.string.trim(line))))) || ((idx >= max_idx)))){\nreturn idx;\n} else {\nvar G__45715 = (idx + (1));\nidx = G__45715;\ncontinue;\n}\nbreak;\n}\n});\n/**\n * Given a sequence of lines and a starting line index in that sequence,\n *   return the index of the first previous non-blank line including or before\n *   that starting line index.  Returns -1 if no non-blank line found.\n */\nzprint.range.previous_non_blank_line = (function zprint$range$previous_non_blank_line(line_vec,index){\nvar idx = index;\nwhile(true){\nvar line = cljs.core.nth.cljs$core$IFn$_invoke$arity$2(line_vec,idx);\nif((!(cljs.core.empty_QMARK_(clojure.string.trim(line))))){\nreturn idx;\n} else {\nif((idx === (0))){\nreturn (-1);\n} else {\nvar G__45716 = (idx - (1));\nidx = G__45716;\ncontinue;\n\n}\n}\nbreak;\n}\n});\n/**\n * Given a string which contains lines and a vector of those lines,\n *   and a range of lines inside of them, expand the range such that\n *   it covers everything from the first non-blank line beyond the\n *   previous top level expression before the start to the end of the\n *   top level expression containing the end of the range.  Returns\n *   [actual-start actual-end].  Note that start, end, actual-start\n *   and actual-end are all zero based line numbers.\n */\nzprint.range.expand_range_to_top_level = (function zprint$range$expand_range_to_top_level(filestring,lines,start,end,dbg_QMARK_){\nif(cljs.core.truth_(dbg_QMARK_)){\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\"expand-range-to-top-level: start:\",start,\"end:\",end], 0));\n} else {\n}\n\nvar line_count = cljs.core.count(lines);\nvar start__$1 = ((typeof start === 'number')?start:(0));\nvar end__$1 = ((typeof end === 'number')?end:line_count);\nvar end__$2 = (((end__$1 < start__$1))?start__$1:end__$1);\nvar row_vec = (function (){try{return cljs.core.mapv.cljs$core$IFn$_invoke$arity$2(cljs.core.meta,edamame.core.parse_string_all.cljs$core$IFn$_invoke$arity$2(filestring,new cljs.core.PersistentArrayMap(null, 4, [new cljs.core.Keyword(null,\"all\",\"all\",892129742),true,new cljs.core.Keyword(null,\"features\",\"features\",-1146962336),new cljs.core.PersistentHashSet(null, new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(null,\"clj\",\"clj\",-660495428),null,new cljs.core.Keyword(null,\"cljs\",\"cljs\",1492417629),null], null), null),new cljs.core.Keyword(null,\"read-cond\",\"read-cond\",1056899244),(function (expr){\nreturn cljs.core.with_meta(cljs.core.PersistentVector.EMPTY,cljs.core.meta(expr));\n}),new cljs.core.Keyword(null,\"auto-resolve\",\"auto-resolve\",1851201983),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"current\",\"current\",-1088038603),cljs.core._STAR_ns_STAR_], null)], null)));\n}catch (e45685){var e = e45685;\nreturn null;\n}})();\nvar row_vec__$1 = (cljs.core.truth_(row_vec)?cljs.core.into.cljs$core$IFn$_invoke$arity$2(cljs.core.PersistentVector.EMPTY,cljs.core.remove.cljs$core$IFn$_invoke$arity$2(cljs.core.nil_QMARK_,row_vec)):null);\nvar _ = (cljs.core.truth_(dbg_QMARK_)?cljs.core.prn.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([row_vec__$1], 0)):null);\nvar start_row_idx = (cljs.core.truth_(row_vec__$1)?zprint.range.find_row.cljs$core$IFn$_invoke$arity$3(row_vec__$1,(start__$1 + (1)),dbg_QMARK_):new cljs.core.Keyword(null,\"fail\",\"fail\",1706214930));\nvar ___$1 = (cljs.core.truth_(dbg_QMARK_)?cljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\"expand-range-to-top-level start-row-idx:\",start_row_idx,((typeof start_row_idx === 'number')?[\"row:\",cljs.core.str.cljs$core$IFn$_invoke$arity$1(cljs.core.nth.cljs$core$IFn$_invoke$arity$2(row_vec__$1,start_row_idx)),\"previous row:\",cljs.core.str.cljs$core$IFn$_invoke$arity$1(cljs.core.nth.cljs$core$IFn$_invoke$arity$2(row_vec__$1,(function (){var x__4295__auto__ = (0);\nvar y__4296__auto__ = (start_row_idx - (1));\nreturn ((x__4295__auto__ > y__4296__auto__) ? x__4295__auto__ : y__4296__auto__);\n})()))].join(''):\"\")], 0)):null);\nvar actual_start = ((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(start_row_idx,new cljs.core.Keyword(null,\"fail\",\"fail\",1706214930)))?(-1):((((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(start_row_idx,new cljs.core.Keyword(null,\"before-beginning\",\"before-beginning\",485705715))) && ((!((start__$1 < (0)))))))?(0):((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(start_row_idx,new cljs.core.Keyword(null,\"before-beginning\",\"before-beginning\",485705715)))?(-1):((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(start_row_idx,(0)))?(0):((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(start_row_idx,new cljs.core.Keyword(null,\"beyond-end\",\"beyond-end\",487000285)))?line_count:new cljs.core.Keyword(null,\"end-row\",\"end-row\",-545103581).cljs$core$IFn$_invoke$arity$1(cljs.core.get.cljs$core$IFn$_invoke$arity$2(row_vec__$1,(start_row_idx - (1))))\n)))));\nvar actual_start__$1 = (((((actual_start < (1))) || ((actual_start >= line_count))))?actual_start:zprint.range.next_non_blank_line(lines,actual_start));\nvar end_row_idx = (cljs.core.truth_(row_vec__$1)?zprint.range.find_row.cljs$core$IFn$_invoke$arity$3(row_vec__$1,(end__$2 + (1)),dbg_QMARK_):new cljs.core.Keyword(null,\"fail\",\"fail\",1706214930));\nvar ___$2 = (cljs.core.truth_(dbg_QMARK_)?cljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\"expand-range-to-top-level end-row-idx:\",end_row_idx,((typeof end_row_idx === 'number')?[\"row:\",cljs.core.str.cljs$core$IFn$_invoke$arity$1(cljs.core.nth.cljs$core$IFn$_invoke$arity$2(row_vec__$1,end_row_idx))].join(''):\"\")], 0)):null);\nvar actual_end = ((((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(end_row_idx,new cljs.core.Keyword(null,\"fail\",\"fail\",1706214930))) || (cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(end_row_idx,new cljs.core.Keyword(null,\"beyond-end\",\"beyond-end\",487000285)))))?line_count:((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(end_row_idx,new cljs.core.Keyword(null,\"before-beginning\",\"before-beginning\",485705715)))?new cljs.core.Keyword(null,\"do-nothing\",\"do-nothing\",1030476282):(function (){var end_row = cljs.core.get.cljs$core$IFn$_invoke$arity$2(row_vec__$1,end_row_idx);\nif(((end__$2 + (1)) < new cljs.core.Keyword(null,\"row\",\"row\",-570139521).cljs$core$IFn$_invoke$arity$1(end_row))){\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(end_row_idx,start_row_idx)){\nreturn new cljs.core.Keyword(null,\"do-nothing\",\"do-nothing\",1030476282);\n} else {\nreturn zprint.range.previous_non_blank_line(lines,end__$2);\n}\n} else {\nreturn (new cljs.core.Keyword(null,\"end-row\",\"end-row\",-545103581).cljs$core$IFn$_invoke$arity$1(end_row) - (1));\n}\n})()\n));\nvar actual_start__$2 = ((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(actual_end,new cljs.core.Keyword(null,\"do-nothing\",\"do-nothing\",1030476282)))?(-1):actual_start__$1);\nvar actual_end__$1 = ((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(actual_end,new cljs.core.Keyword(null,\"do-nothing\",\"do-nothing\",1030476282)))?(-1):actual_end);\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [actual_start__$2,actual_end__$1], null);\n});\n/**\n * Given lines, a sequence of lines, and a start and end of a range,\n *   split the sequence of lines into three parts: [before-lines range\n *   after-lines].  If any of these collections would be empty, return\n *   an empty sequence. End must be equal to or greater than start. If\n *   end is neg?, there will be no range.\n */\nzprint.range.split_out_range = (function zprint$range$split_out_range(lines,start,end){\nvar start__$1 = (function (){var x__4295__auto__ = start;\nvar y__4296__auto__ = (0);\nreturn ((x__4295__auto__ > y__4296__auto__) ? x__4295__auto__ : y__4296__auto__);\n})();\nvar before = start__$1;\nvar range = (((end < (0)))?(0):((end - start__$1) + (1)));\nvar after = ((cljs.core.count(lines) - (1)) - end);\nreturn new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.take.cljs$core$IFn$_invoke$arity$2(before,lines),cljs.core.take.cljs$core$IFn$_invoke$arity$2(range,cljs.core.drop.cljs$core$IFn$_invoke$arity$2(before,lines)),cljs.core.take.cljs$core$IFn$_invoke$arity$2(after,cljs.core.drop.cljs$core$IFn$_invoke$arity$2((before + range),lines))], null);\n});\n/**\n * Given before-lines, range, and after-lines where before-lines\n *   and after-lines are sequences of lines, and range is a string\n *   which has been formatted, reassemble these three chunks into a\n *   single string with appropriate newlines joining them together.\n *   Note that this is *not* an inverse to split-out-range, because\n *   in that routine range is a seq of lines, and in this routine\n *   range is a string.  Note also that we only join them with a \n *   newline if there are two pieces, otherwise we get extra lines.\n */\nzprint.range.reassemble_range = (function zprint$range$reassemble_range(before_lines,range,after_lines){\nvar before_QMARK_ = (!(cljs.core.empty_QMARK_(before_lines)));\nvar before_lines__$1 = ((before_QMARK_)?clojure.string.join.cljs$core$IFn$_invoke$arity$2(\"\\n\",before_lines):\"\");\nvar range_QMARK_ = (!(cljs.core.empty_QMARK_(range)));\nvar after_QMARK_ = (!(cljs.core.empty_QMARK_(after_lines)));\nvar after_lines__$1 = ((after_QMARK_)?clojure.string.join.cljs$core$IFn$_invoke$arity$2(\"\\n\",after_lines):\"\");\nvar before_range = ((((before_QMARK_) && (range_QMARK_)))?\"\\n\":\"\");\nvar range_after = ((((range_QMARK_) && (after_QMARK_)))?\"\\n\":\"\");\nvar range_after__$1 = (((((!(range_QMARK_))) && (((before_QMARK_) && (after_QMARK_)))))?\"\\n\":range_after);\nreturn [before_lines__$1,before_range,cljs.core.str.cljs$core$IFn$_invoke$arity$1(range),range_after__$1,after_lines__$1].join('');\n});\n","~:ns-info",["^ ","~:rename-macros",null,"~:renames",["^ "],"~:meta",["^ ","~:file","zprint/range.cljc","~:line",1,"~:column",14,"~:end-line",1,"~:end-column",26,"~:no-doc",true],"~:ns-aliases",["^ ","~$cljs.loader","~$shadow.loader","~$react","~$module$node_modules$react$index","~$react-dom","~$module$node_modules$react_dom$index","~$highlight.js","~$module$node_modules$highlight_DOT_js$lib$index","~$clojure.pprint","~$cljs.pprint","~$clojure.spec.alpha","~$cljs.spec.alpha","~$clojure.repl","~$cljs.repl"],"~:use-macros",null,"~:excludes",["~#set",[]],"~:name","~$zprint.range","~:op","~:ns","~:imports",null,"~:requires",["^ ","~$clojure.string","^T","~$s","^T","~$edamame.core","^U","~$cljs.core","^V","~$goog","^W"],"~:seen",["^M",["~:require"]],"~:uses",["^ ","~$parse-string-all","^U"],"~:require-macros",["^ ","^V","^V"],"~:form",["~#list",["~$ns","^O",["^12",["^Y",["^T","~:as","~$s"],["^U","~:refer",["^["]]]]]],"~:flags",["^ ","^Y",["^M",[]]],"~:js-deps",["^ "],"~:deps",["^W","^V","^T","^U"]],"^Q","^O","~:resource-id",["~:shadow.build.classpath/resource","zprint/range.cljc"],"~:compiled-at",1638904286810,"~:resource-name","zprint/range.cljc","~:warnings",[],"~:source","(ns ^:no-doc zprint.range\n  (:require [clojure.string :as s]\n            [edamame.core :refer [parse-string-all]]))\n\n;;\n;; # Handle range specification\n;;\n\n(defn in-row?\n  \"If a line number n is in a particular edamame row, return the row map.\n  If it is not in the row, return +1 or -1 to indicate which direction\n  to look.\"\n  [n row]\n  #_(println \"n:\" n \"row:\" row)\n  (when row\n    (if (<= (:row row) n (:end-row row)) row (if (< n (:row row)) -1 +1))))\n\n(defn row-before?\n  \"Given two rows, is the first before the second?\"\n  [row-a row-b]\n  #_(println \"row-before? row-a:\" row-a \"row-b:\" row-b)\n  (< (:end-row row-a) (:row row-b)))\n\n(defn between-rows?\n  \"Given two rows, if the linenumber is between the rows, return true, else\n  nil.\"\n  [linenumber row-a row-b]\n  #_(println \"between-rows? linenumber:\" linenumber\n             \"row-a:\" row-a\n             \"row-b:\" row-b)\n  (when (and (map? row-a) (map? row-b))\n    (if (row-before? row-a row-b)\n      (< (:end-row row-a) linenumber (:row row-b))\n      (< (:end-row row-b) linenumber (:row row-a)))))\n\n(defn scan-for-row\n  \"Given a row-vec, and a current index into the row-vec, if the\n  linenumber is within that row, return the index to that row.   If\n  the linenumber is not in that row, then scan either way for\n  max-tries looking for a match for this linenumber.  Return the\n  row index if a row is found containing this linenumber. If it is\n  between two rows, return the row after.  If we fall off the either\n  end of the row-vec, then return :before-beginning or :beyone-end.  \n  If we don't find anything after trying for max-tries, :before or\n  :after, depending on which way we should try next.\"\n  [row-vec row-vec-index linenumber max-tries]\n  (loop [current-index row-vec-index\n         previous-index nil\n         tries 0]\n    (let [row (get row-vec current-index)\n          row-or-direction (in-row? linenumber row)]\n      #_(println \"scan-for-row current-index:\" current-index\n                 \"previous-index:\" previous-index\n                 \"tries:\" tries\n                 \"row:\" row\n                 \"row-or-direction\" row-or-direction)\n      (cond (map? row-or-direction) current-index   ; in this row\n            (nil? row-or-direction)\n              (if (pos? current-index) :beyond-end :before-beginning)\n            :else\n              (if (>= tries max-tries)\n                ; tell caller where to look next\n                (if (pos? row-or-direction) :after :before)\n                (let [next-index (+ current-index row-or-direction)\n                      next-row (get row-vec next-index)\n                      row-or-direction (in-row? linenumber next-row)]\n                  (cond (map? row-or-direction) next-index ; we are in the row,\n                                                           ; return its index\n                        (nil? row-or-direction)\n                          (if (pos? next-index) :beyond-end :before-beginning)\n                        :else (if (between-rows? linenumber row next-row)\n                                ; We are between rows, return later one\n                                (if (row-before? row next-row)\n                                  next-index\n                                  current-index)\n                                ; Keep looking\n                                (recur (+ current-index row-or-direction)\n                                       current-index\n                                       (inc tries))))))))))\n\n(defn abs \"Return the absolute value of a number.\" [n] (if (neg? n) (- n) n))\n\n(defn find-row\n  \"Given a vector of rows, find the row that contains a line number,\n  linenumber, and return the number of that row in the vector.\n  row-vec looks like this: \n  [{:row 2, :col 1, :end-row 7, :end-col 21}\n   {:row 9, :col 1, :end-row 18, :end-col 6} \n   {:row 20, :col 1, :end-row 29, :end-col 6}]\n  If none exists, return the next row. Note that line numbers are 1\n  based, not zero based for this routine and the information in\n  row-vec, but the index into row-vec that this routine returns is\n  zero based.  Uses a binary search. If the line number is before the\n  first information in the row-vec, returns :before-beginning, and\n  if it is after the last information in the row-vec, returns\n  :beyond-end. Note that the row-vec as returned from edamame\n  parse-string-all contains not only maps like {:row 5 :end-row 10}\n  but also nils for things that didn't have paired delimiters around\n  them (e.g., keywords, strings, etc.).  You must remove those\n  from row-vec before calling find-row.  Note that find-row returns an \n  index into row-vec, and it must be the row-vec that has had nils \n  removed from it (or this routine would do that for you).\"\n  ([row-vec linenumber dbg? scan-size]\n   (when dbg?\n     (println \"find-row: linenumber:\" linenumber \"scan-size:\" scan-size))\n   (let [size (count row-vec)]\n     ; We are 1 based, because edamame row numbers are 1 based.\n     (loop [row-vec-index (int (/ size 2))\n            previous-index 0\n            tries 0]\n       #_(println \"\\n\\n================== row-vec-index:\" row-vec-index)\n       (if (> tries 10)\n         :fail\n         (let [maybe-index\n                 (scan-for-row row-vec row-vec-index linenumber scan-size)]\n           ; If it is a number, that is the row-vec-index to return\n           ; If it is :before, we ran off the beginning, :after the end\n           ; nil means that we didn't find it, but can keep looking\n           #_(println \"maybe-index:\" maybe-index)\n           (cond\n             (number? maybe-index) maybe-index  ; we found something to return\n             ; is it in this row?\n             (or (= maybe-index :before-beginning) (= maybe-index :beyond-end))\n               maybe-index\n             :else ; Has to be :before or :after\n               (do #_(println \"find-row: maybe-index:\" maybe-index\n                              \"row-vec-index:\" row-vec-index\n                              \"previous-index:\" previous-index\n                              \"abs:\" (abs (- row-vec-index previous-index)))\n                   (recur ((if (= maybe-index :before) - +)\n                            row-vec-index\n                            (int (/ (abs (- row-vec-index previous-index)) 2)))\n                          row-vec-index\n                          (inc tries)))))))))\n  ([row-vec n dbg?] (find-row row-vec n dbg? 4)))\n\n(defn next-non-blank-line\n  \"Given a sequence of lines and a starting line index in that sequence,\n  return the index of the first non-blank line including or after that\n  starting line index.\"\n  [line-vec index]\n  (let [max-idx (dec (count line-vec))]\n    (loop [idx index]\n      (let [line (nth line-vec idx)]\n        ; Return current idx if it is non-blank or the last line\n        (if (or (not (empty? (clojure.string/trim line))) (>= idx max-idx))\n          idx\n          (recur (inc idx)))))))\n\n(defn previous-non-blank-line\n  \"Given a sequence of lines and a starting line index in that sequence,\n  return the index of the first previous non-blank line including or before\n  that starting line index.  Returns -1 if no non-blank line found.\"\n  [line-vec index]\n  (loop [idx index]\n    (let [line (nth line-vec idx)]\n      ; Return current idx if it is non-blank\n      (cond (not (empty? (clojure.string/trim line))) idx\n            ; if the first line is not non-blank, then we didn't find one\n            (zero? idx) -1\n            ; keep looking for a non-blank line\n            :else (recur (dec idx))))))\n\n(defn expand-range-to-top-level\n  \"Given a string which contains lines and a vector of those lines,\n  and a range of lines inside of them, expand the range such that\n  it covers everything from the first non-blank line beyond the\n  previous top level expression before the start to the end of the\n  top level expression containing the end of the range.  Returns\n  [actual-start actual-end].  Note that start, end, actual-start\n  and actual-end are all zero based line numbers.\"\n  ; But also note that parse-string-all (and thus row-vec) and\n  ; find-row all operate with one-based line numbers!!!\n  [filestring lines start end dbg?]\n  (when dbg? (println \"expand-range-to-top-level: start:\" start \"end:\" end))\n  (let [line-count (count lines)\n        start (if (number? start) start 0)\n        end (if (number? end) end line-count)\n        ; If end is before start, make them the same\n        end (if (< end start) start end)\n        ; Get a vector of maps describing all top level expressions using\n        ; one based line numbers.  For example:\n        ; [{:col 1, :end-col 21, :end-row 7, :row 2}\n        ;  {:col 1, :end-col 6, :end-row 20, :row 11}\n        ;  {:col 1, :end-col 70, :end-row 26, :row 22}\n        ;  {:col 1, :end-col 48, :end-row 29, :row 27}]\n        row-vec (try (mapv meta\n                       (parse-string-all\n                         filestring\n                         {:all true,\n                          :features #{:clj :cljs},\n                          ; Ensure that reader-conditionals have something\n                          ; show up with meta data regardless of the\n                          ; \"features\" in the reader-conditional\n                          :read-cond (fn [expr] (with-meta [] (meta expr))),\n                          :auto-resolve {:current *ns*}}))\n                     ; If we can't parse it, we have set row-vec to nil, which\n                     ; should cause us to format everything.\n                     (catch #?(:clj Exception\n                               :cljs :default)\n                       e\n                       nil))\n        row-vec (when row-vec (into [] (remove nil? row-vec)))\n        ; If row-vec is nil, then we didn't parse this, so do everything\n        ; silently.\n        _ (when dbg? (prn row-vec))\n        ; Figure out which expression start falls within, after making\n        ; it a one-based line number.  -idx are indexes into row-vec,\n        ; *not* linenumbers\n        start-row-idx (if row-vec (find-row row-vec (inc start) dbg?) :fail)\n        _ (when dbg?\n            (println \"expand-range-to-top-level start-row-idx:\"\n                     start-row-idx\n                     (if (number? start-row-idx)\n                       (str \"row:\" (nth row-vec start-row-idx)\n                            \"previous row:\" (nth row-vec\n                                                 (max 0 (dec start-row-idx))))\n                       \"\")))\n        actual-start\n          ; -1 is a signal to not start at the beginning unless the end is\n          ; also -1, in which case it is a signal to put everything in the\n          ; before\n          (cond (= start-row-idx :fail) -1\n                (and (= start-row-idx :before-beginning) (not (neg? start))) 0\n                (= start-row-idx :before-beginning) -1\n                (= start-row-idx 0) 0\n                (= start-row-idx :beyond-end) line-count\n                ; normal case -- the line beyond the previous form\n                ; where (dec start-row-idx) is presumably the previous form\n                :else (:end-row (get row-vec (dec start-row-idx))))\n        ; Now, move actual-start to the first non-blank line after or equal to\n        ; actual-start.  But not if it is zero or negative, since we don't\n        ; want to mess with the range if it encompasses the beginning of\n        ; the file.\n        actual-start (if (or (< actual-start 1) (>= actual-start line-count))\n                       actual-start\n                       (next-non-blank-line lines actual-start))\n        end-row-idx (if row-vec (find-row row-vec (inc end) dbg?) :fail)\n        _ (when dbg?\n            (println \"expand-range-to-top-level end-row-idx:\"\n                     end-row-idx\n                     (if (number? end-row-idx)\n                       (str \"row:\" (nth row-vec end-row-idx))\n                       \"\")))\n        actual-end (cond\n                     (or (= end-row-idx :fail) (= end-row-idx :beyond-end))\n                       ; We are beyond the end or it didn't parse, say the\n                       ; end is beyond the last line.\n                       line-count\n                     (= end-row-idx :before-beginning)\n                       ; Someone is confused here too, say the end is the\n                       ; start.\n                       :do-nothing\n                     :else (let [end-row (get row-vec end-row-idx)]\n                             ; end-row-idx is either the row in which end falls\n                             ; or the next row if it was between rows\n                             ; Note: :row is the start line of a row-map\n                             ;\n                             ; Does end fall between two top-level expressions?\n                             (if (< (inc end) (:row end-row))\n                               ; Yes -- are start and end in same gap\n                               ; between expressions?\n                               (if (= end-row-idx start-row-idx)\n                                 ; Yes, do nothing\n                                 :do-nothing\n                                 ; No, work backward to the first non-blank\n                                 ; line prior to the end\n                                 (previous-non-blank-line lines end))\n                               ; No, end falls inside of an expression, so use\n                               ; the end of that expression.  Make it zero\n                               ; based.\n                               (dec (:end-row end-row)))))\n        actual-start (if (= actual-end :do-nothing) -1 actual-start)\n        actual-end (if (= actual-end :do-nothing) -1 actual-end)]\n    [actual-start actual-end]))\n\n;;\n;; # Take apart a series of lines based on a range\n;;\n\n(defn split-out-range\n  \"Given lines, a sequence of lines, and a start and end of a range,\n  split the sequence of lines into three parts: [before-lines range\n  after-lines].  If any of these collections would be empty, return\n  an empty sequence. End must be equal to or greater than start. If\n  end is neg?, there will be no range.\"\n  [lines start end]\n  (let [start (max start 0)\n        before start\n        range (if (neg? end) 0 (inc (- end start)))\n        after (- (dec (count lines)) end)]\n    #_(println \"before:\" before \"range:\" range \"after:\" after)\n    [(take before lines) (take range (drop before lines))\n     (take after (drop (+ before range) lines))]))\n\n(defn reassemble-range\n  \"Given before-lines, range, and after-lines where before-lines\n  and after-lines are sequences of lines, and range is a string\n  which has been formatted, reassemble these three chunks into a\n  single string with appropriate newlines joining them together.\n  Note that this is *not* an inverse to split-out-range, because\n  in that routine range is a seq of lines, and in this routine\n  range is a string.  Note also that we only join them with a \n  newline if there are two pieces, otherwise we get extra lines.\"\n  [before-lines range after-lines]\n  (let [before? (not (empty? before-lines))\n        before-lines (if before? (clojure.string/join \"\\n\" before-lines) \"\")\n        range? (not (empty? range))\n        after? (not (empty? after-lines))\n        after-lines (if after? (clojure.string/join \"\\n\" after-lines) \"\")\n        before-range (if (and before? range?) \"\\n\" \"\")\n        range-after (if (and range? after?) \"\\n\" \"\")\n        range-after (if (and (not range?) before? after?) \"\\n\" range-after)]\n    (str before-lines before-range range range-after after-lines)))\n\n","~:reader-features",["^M",["~:cljs"]],"~:cljc",true,"~:source-map-compact",["^ ","mappings","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","names",["zprint.range/in-row?","n","row","zprint.range/row-before?","row-a","row-b","zprint.range/between-rows?","linenumber","cljs.core/map?","zprint.range/scan-for-row","row-vec","row-vec-index","max-tries","current-index","previous-index","tries","cljs.core.get","row-or-direction","next-index","next-row","zprint.range/abs","var_args","G__45661","zprint.range/find-row","js/Error","dbg?","scan-size","cljs.core.println","size","cljs.core/count","maybe-index","cljs.core._EQ_","G__45667","G__45668","fexpr__45666","cljs.core/-","cljs.core/+","zprint.range.find_row","zprint.range/next-non-blank-line","line-vec","index","max-idx","idx","line","cljs.core.nth","cljs.core/empty?","clojure.string/trim","zprint.range/previous-non-blank-line","zprint.range/expand-range-to-top-level","filestring","lines","start","end","line-count","e45685","cljs.core.mapv","cljs.core/meta","edamame.core.parse_string_all","expr","cljs.core/with-meta","cljs.core/*ns*","e","cljs.core.into","cljs.core.remove","cljs.core/nil?","_","cljs.core.prn","start-row-idx","x__4295__auto__","y__4296__auto__","actual-start","end-row-idx","actual-end","end-row","zprint.range/split-out-range","before","range","after","cljs.core.take","cljs.core.drop","zprint.range/reassemble-range","before-lines","after-lines","before?","clojure.string.join","range?","after?","before-range","range-after"]],"~:used-vars",["^M",["~$clojure.string/join","~$zprint.range/scan-for-row","~$cljs.core/=","~$cljs.core/count","~$zprint.range/reassemble-range","~$cljs.core/prn","~$cljs.core/take","~$cljs.core/mapv","~$zprint.range/find-row","~$cljs.core/empty?","~$cljs.core/-","~$zprint.range/row-before?","~$cljs.core/into","~$cljs.core/map?","~$cljs.core/with-meta","~$zprint.range/next-non-blank-line","~$zprint.range/between-rows?","~$cljs.core/get","~$cljs.core/remove","~$zprint.range/expand-range-to-top-level","~$cljs.core/nil?","~$cljs.core/nth","~$cljs.core/meta","~$cljs.core/println","~$cljs.core/not","~$zprint.range/abs","~$zprint.range/in-row?","~$edamame.core/parse-string-all","~$clojure.string/trim","~$zprint.range/split-out-range","~$cljs.core/*ns*","~$zprint.range/previous-non-blank-line","~$cljs.core/+","~$js/Error","~$cljs.core/drop"]]],"~:cache-keys",["~#cmap",[["^1:","goog/dom/tagname.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","~:shadow.build.compiler/resolve",["^ ","~:require-id",null,"~:deps-ids",["^M",[]],"~:deps-syms",["^W","~$goog.dom.HtmlElement"]]],["^1:","edamame/core.cljc"],["8915b89bb492e9e815fdda7c1acef2683070dc2a","^2?",["^ ","^2@",null,"^2A",["^M",[]],"^2B",["^W","^V","~$edamame.impl.parser"]]],["^1:","cljs/tools/reader/impl/utils.cljs"],["927809dcb44fa726e4969d993e3e733636d95ebb","^2?",["^ ","^2@",null,"^2A",["^M",[]],"^2B",["^W","^V","^T","~$goog.string"]]],["^1:","goog/math/math.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^2?",["^ ","^2@",null,"^2A",["^M",[]],"^2B",["^W","~$goog.array","~$goog.asserts"]]],["^1:","goog/html/trustedtypes.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^2?",["^ ","^2@",null,"^2A",["^M",[]],"^2B",["^W"]]],["^1:","goog/labs/useragent/browser.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^2?",["^ ","^2@",null,"^2A",["^M",[]],"^2B",["^W","^2F","~$goog.labs.userAgent.util","~$goog.object","~$goog.string.internal"]]],["^1:","goog/html/safeurl.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^2?",["^ ","^2@",null,"^2A",["^M",[]],"^2B",["^W","^2G","~$goog.fs.url","~$goog.html.TrustedResourceUrl","~$goog.i18n.bidi.Dir","~$goog.i18n.bidi.DirectionalString","~$goog.string.Const","~$goog.string.TypedString","^2J"]]],["^1:","goog/array/array.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^2?",["^ ","^2@",null,"^2A",["^M",[]],"^2B",["^W","^2G"]]],["^1:","goog/debug/error.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^2?",["^ ","^2@",null,"^2A",["^M",[]],"^2B",["^W"]]],["^1:","cljs/tools/reader/edn.cljs"],["927809dcb44fa726e4969d993e3e733636d95ebb","^2?",["^ ","^2@",null,"^2A",["^M",[]],"^2B",["^W","^V","~$cljs.tools.reader.impl.errors","~$cljs.tools.reader.reader-types","~$cljs.tools.reader.impl.utils","~$cljs.tools.reader.impl.commons","~$cljs.tools.reader","^2E","~$goog.string.StringBuffer"]]],["^1:","goog/dom/nodetype.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^2?",["^ ","^2@",null,"^2A",["^M",[]],"^2B",["^W"]]],["^1:","cljs/tools/reader/impl/inspect.cljs"],["927809dcb44fa726e4969d993e3e733636d95ebb","^2?",["^ ","^2@",null,"^2A",["^M",[]],"^2B",["^W","^V"]]],["^1:","cljs/tools/reader.cljs"],["927809dcb44fa726e4969d993e3e733636d95ebb","^2?",["^ ","^2@",null,"^2A",["^M",[]],"^2B",["^W","^V","^2R","^2S","^2T","^2Q","^2F","^2E","^2V"]]],["^1:","edamame/impl/parser.cljc"],["8915b89bb492e9e815fdda7c1acef2683070dc2a","^2?",["^ ","^2@",null,"^2A",["^M",[]],"^2B",["^W","^V","~$cljs.tools.reader.edn","^2R","~$cljs.tools.reader.impl.inspect","^2S","^2T","^T","~$edamame.impl.read-fn","~$edamame.impl.syntax-quote","^2V"]]],["^1:","goog/string/typedstring.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^2?",["^ ","^2@",null,"^2A",["^M",[]],"^2B",["^W"]]],["^1:","goog/object/object.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^2?",["^ ","^2@",null,"^2A",["^M",[]],"^2B",["^W"]]],["^1:","goog/dom/asserts.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^2?",["^ ","^2@",null,"^2A",["^M",[]],"^2B",["^W","^2G"]]],"~:SHADOW-TIMESTAMP",[1628015068000,1628015068000,1628015038000],["^1:","edamame/impl/syntax_quote.cljc"],["8915b89bb492e9e815fdda7c1acef2683070dc2a","^2?",["^ ","^2@",null,"^2A",["^M",[]],"^2B",["^W","^V","^T"]]],["^1:","goog/math/long.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^2?",["^ ","^2@",null,"^2A",["^M",[]],"^2B",["^W","^2G","~$goog.reflect"]]],["^1:","goog/html/trustedresourceurl.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^2?",["^ ","^2@",null,"^2A",["^M",[]],"^2B",["^W","^2G","~$goog.fs.blob","^2K","~$goog.html.SafeScript","~$goog.html.trustedtypes","^2M","^2N","^2O","^2P"]]],["^1:","goog/string/internal.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^2?",["^ ","^2@",null,"^2A",["^M",[]],"^2B",["^W"]]],["^1:","goog/functions/functions.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^2?",["^ ","^2@",null,"^2A",["^M",[]],"^2B",["^W"]]],["^1:","goog/html/safestyle.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^2?",["^ ","^2@",null,"^2A",["^M",[]],"^2B",["^W","^2F","^2G","~$goog.html.SafeUrl","^2O","^2P","^2J"]]],["^1:","goog/dom/safe.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^2?",["^ ","^2@",null,"^2A",["^M",[]],"^2B",["^W","^2G","~$goog.dom.asserts","~$goog.functions","~$goog.html.SafeHtml","^32","~$goog.html.SafeStyle","^34","^2L","~$goog.html.uncheckedconversions","^2O","^2J"]]],["^1:","goog/structs/map.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^2?",["^ ","^2@",null,"^2A",["^M",[]],"^2B",["^W","~$goog.iter.Iterator","~$goog.iter.StopIteration"]]],["^1:","goog/html/safehtml.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^2?",["^ ","^2@",null,"^2A",["^M",[]],"^2B",["^W","^2F","^2G","~$goog.dom.TagName","~$goog.dom.tags","^32","^38","~$goog.html.SafeStyleSheet","^34","^2L","^33","^2M","^2N","~$goog.labs.userAgent.browser","^2I","^2O","^2P","^2J"]]],["^1:","goog/dom/tags.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^2?",["^ ","^2@",null,"^2A",["^M",[]],"^2B",["^W","^2I"]]],["^1:","goog/fs/blob.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^2?",["^ ","^2@",null,"^2A",["^M",[]],"^2B",["^W","^2F"]]],["^1:","goog/asserts/asserts.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^2?",["^ ","^2@",null,"^2A",["^M",[]],"^2B",["^W","~$goog.debug.Error","~$goog.dom.NodeType"]]],["^1:","goog/uri/uri.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^2?",["^ ","^2@",null,"^2A",["^M",[]],"^2B",["^W","^2F","^2G","^2E","~$goog.structs","~$goog.structs.Map","~$goog.uri.utils","~$goog.uri.utils.ComponentIndex","~$goog.uri.utils.StandardQueryParam"]]],["^1:","edamame/impl/read_fn.cljc"],["8915b89bb492e9e815fdda7c1acef2683070dc2a","^2?",["^ ","^2@",null,"^2A",["^M",[]],"^2B",["^W","^V"]]],["^1:","goog/i18n/bidi.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^2?",["^ ","^2@",null,"^2A",["^M",[]],"^2B",["^W"]]],["^1:","goog/fs/url.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^2?",["^ ","^2@",null,"^2A",["^M",[]],"^2B",["^W"]]],["^1:","goog/base.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^2?",["^ ","^2@",null,"^2A",["^M",[]],"^2B",[]]],["^1:","goog/structs/structs.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^2?",["^ ","^2@",null,"^2A",["^M",[]],"^2B",["^W","^2F","^2I"]]],["^1:","cljs/tools/reader/impl/errors.cljs"],["927809dcb44fa726e4969d993e3e733636d95ebb","^2?",["^ ","^2@",null,"^2A",["^M",[]],"^2B",["^W","^V","^2R","^T","^2X"]]],["^1:","clojure/string.cljs"],["528fbd795675bc73c189ce8a8429415f03165a3b","^2?",["^ ","^2@",null,"^2A",["^M",[]],"^2B",["^W","^V","^2E","^2V"]]],["^1:","goog/string/string.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^2?",["^ ","^2@",null,"^2A",["^M",[]],"^2B",["^W","~$goog.dom.safe","^39","^2O","^2J"]]],["^1:","goog/reflect/reflect.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^2?",["^ ","^2@",null,"^2A",["^M",[]],"^2B",["^W"]]],["^1:","goog/labs/useragent/util.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^2?",["^ ","^2@",null,"^2A",["^M",[]],"^2B",["^W","^2J"]]],["^1:","goog/string/stringbuffer.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^2?",["^ ","^2@",null,"^2A",["^M",[]],"^2B",["^W"]]],["^1:","cljs/tools/reader/reader_types.cljs"],["927809dcb44fa726e4969d993e3e733636d95ebb","^2?",["^ ","^2@",null,"^2A",["^M",[]],"^2B",["^W","^V","^2S","^2E","^2V"]]],["^1:","goog/iter/iter.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^2?",["^ ","^2@",null,"^2A",["^M",[]],"^2B",["^W","^2F","^2G","^36","~$goog.math"]]],["^1:","goog/html/uncheckedconversions.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^2?",["^ ","^2@",null,"^2A",["^M",[]],"^2B",["^W","^2G","^37","^32","^38","^3>","^34","^2L","^2O","^2J","^2M"]]],["^1:","zprint/range.cljc"],["bcaedc2ca968ebbb39028e5b7a25467410a0b7a6","^2?",["^ ","^2@",null,"^2A",["^M",[]],"^2B",["^W","^V","^T","^U"]]],["^1:","cljs/tools/reader/impl/commons.cljs"],["927809dcb44fa726e4969d993e3e733636d95ebb","^2?",["^ ","^2@",null,"^2A",["^M",[]],"^2B",["^W","^V","^2Q","^2R","^2S"]]],["^1:","goog/dom/htmlelement.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^2?",["^ ","^2@",null,"^2A",["^M",[]],"^2B",["^W"]]],["^1:","cljs/core.cljs"],["528fbd795675bc73c189ce8a8429415f03165a3b","^2?",["^ ","^2@",null,"^2A",["^M",[]],"^2B",["^W","~$goog.math.Long","~$goog.math.Integer","^2E","^2I","^2F","~$goog.Uri","^2V"]]],["^1:","goog/html/safescript.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^2?",["^ ","^2@",null,"^2A",["^M",[]],"^2B",["^W","^2O","^2P","^33","^2G"]]],["^1:","goog/html/safestylesheet.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^2?",["^ ","^2@",null,"^2A",["^M",[]],"^2B",["^W","^2O","^38","^2P","^2F","^2I","^2G","^2J"]]],["^1:","goog/math/integer.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^2?",["^ ","^2@",null,"^2A",["^M",[]],"^2B",["^W","^30"]]],["^1:","goog/uri/utils.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^2?",["^ ","^2@",null,"^2A",["^M",[]],"^2B",["^W","^2G","^2E"]]],["^1:","goog/string/const.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^2?",["^ ","^2@",null,"^2A",["^M",[]],"^2B",["^W","^2G","^2P"]]]]],"~:clj-info",["^ ","jar:file:/Users/hagenek/.m2/repository/binaryage/devtools/1.0.3/devtools-1.0.3.jar!/devtools/defaults.clj",1638904136000,"jar:file:/Users/hagenek/.m2/repository/org/clojure/clojure/1.10.3/clojure-1.10.3.jar!/clojure/edn.clj",1628015039000,"jar:file:/Users/hagenek/.m2/repository/org/clojure/clojure/1.10.3/clojure-1.10.3.jar!/clojure/string.clj",1628015039000,"jar:file:/Users/hagenek/.m2/repository/org/clojure/clojurescript/1.10.879/clojurescript-1.10.879.jar!/cljs/analyzer/passes.cljc",1628015038000,"jar:file:/Users/hagenek/.m2/repository/org/clojure/data.json/2.4.0/data.json-2.4.0.jar!/clojure/data/json.clj",1628015036000,"jar:file:/Users/hagenek/.m2/repository/org/clojure/clojurescript/1.10.879/clojurescript-1.10.879.jar!/cljs/instant.clj",1628015038000,"jar:file:/Users/hagenek/.m2/repository/org/clojure/clojure/1.10.3/clojure-1.10.3.jar!/clojure/java/io.clj",1628015039000,"jar:file:/Users/hagenek/.m2/repository/org/clojure/clojurescript/1.10.879/clojurescript-1.10.879.jar!/cljs/externs.clj",1628015038000,"jar:file:/Users/hagenek/.m2/repository/org/clojure/clojurescript/1.10.879/clojurescript-1.10.879.jar!/cljs/source_map/base64.clj",1628015038000,"jar:file:/Users/hagenek/.m2/repository/org/clojure/clojure/1.10.3/clojure-1.10.3.jar!/clojure/pprint.clj",1628015039000,"jar:file:/Users/hagenek/.m2/repository/org/clojure/tools.reader/1.3.6/tools.reader-1.3.6.jar!/clojure/tools/reader.clj",1628015036000,"jar:file:/Users/hagenek/.m2/repository/org/clojure/clojurescript/1.10.879/clojurescript-1.10.879.jar!/cljs/source_map.clj",1628015038000,"jar:file:/Users/hagenek/.m2/repository/org/clojure/clojure/1.10.3/clojure-1.10.3.jar!/clojure/set.clj",1628015039000,"jar:file:/Users/hagenek/.m2/repository/org/clojure/tools.reader/1.3.6/tools.reader-1.3.6.jar!/cljs/tools/reader/reader_types.clj",1628015036000,"jar:file:/Users/hagenek/.m2/repository/org/clojure/clojurescript/1.10.879/clojurescript-1.10.879.jar!/cljs/util.cljc",1628015038000,"jar:file:/Users/hagenek/.m2/repository/org/clojure/clojurescript/1.10.879/clojurescript-1.10.879.jar!/cljs/js_deps.cljc",1628015038000,"jar:file:/Users/hagenek/.m2/repository/org/clojure/clojurescript/1.10.879/clojurescript-1.10.879.jar!/cljs/source_map/base64_vlq.clj",1628015038000,"jar:file:/Users/hagenek/.m2/repository/org/clojure/tools.reader/1.3.6/tools.reader-1.3.6.jar!/clojure/tools/reader/default_data_readers.clj",1628015036000,"jar:file:/Users/hagenek/.m2/repository/org/clojure/clojurescript/1.10.879/clojurescript-1.10.879.jar!/cljs/core.cljc",1628015038000,"jar:file:/Users/hagenek/.m2/repository/org/clojure/tools.reader/1.3.6/tools.reader-1.3.6.jar!/clojure/tools/reader/reader_types.clj",1628015036000,"jar:file:/Users/hagenek/.m2/repository/org/clojure/clojurescript/1.10.879/clojurescript-1.10.879.jar!/cljs/tagged_literals.cljc",1628015038000,"jar:file:/Users/hagenek/.m2/repository/org/clojure/tools.reader/1.3.6/tools.reader-1.3.6.jar!/clojure/tools/reader/impl/errors.clj",1628015036000,"jar:file:/Users/hagenek/.m2/repository/org/clojure/clojurescript/1.10.879/clojurescript-1.10.879.jar!/cljs/analyzer/impl.cljc",1628015038000,"jar:file:/Users/hagenek/.m2/repository/org/clojure/tools.reader/1.3.6/tools.reader-1.3.6.jar!/clojure/tools/reader/impl/inspect.clj",1628015036000,"jar:file:/Users/hagenek/.m2/repository/org/clojure/clojurescript/1.10.879/clojurescript-1.10.879.jar!/cljs/env.cljc",1628015038000,"jar:file:/Users/hagenek/.m2/repository/org/clojure/clojurescript/1.10.879/clojurescript-1.10.879.jar!/cljs/analyzer.cljc",1628015038000,"jar:file:/Users/hagenek/.m2/repository/org/clojure/clojure/1.10.3/clojure-1.10.3.jar!/clojure/core.clj",1628015039000,"jar:file:/Users/hagenek/.m2/repository/org/clojure/clojurescript/1.10.879/clojurescript-1.10.879.jar!/cljs/compiler.cljc",1628015038000,"jar:file:/Users/hagenek/.m2/repository/org/clojure/clojure/1.10.3/clojure-1.10.3.jar!/clojure/instant.clj",1628015039000,"jar:file:/Users/hagenek/.m2/repository/org/clojure/clojurescript/1.10.879/clojurescript-1.10.879.jar!/cljs/analyzer/passes/and_or.cljc",1628015038000],"~:analyzer",["^ ","^3",null,"^4",["^ "],"^5",["^ ","^6","zprint/range.cljc","^7",1,"^8",14,"^9",1,"^:",26,"^;",true],"^<",["^ ","^=","^>","^?","^@","^A","^B","^C","^D","^E","^F","^G","^H","^I","^J"],"^K",null,"^L",["^M",[]],"^N","^O","^R",null,"^S",["^ ","^T","^T","~$s","^T","^U","^U","^V","^V","^W","^W"],"^X",["^M",["^Y"]],"~:shadow/js-access-global",["^M",["Error"]],"^Z",["^ ","^[","^U"],"~:defs",["^ ","~$reassemble-range",["^ ","~:protocol-inline",null,"^5",["^ ","^6","zprint/range.cljc","^7",296,"^8",7,"^9",296,"^:",23,"~:arglists",["^12",["~$quote",["^12",[["~$before-lines","~$range","~$after-lines"]]]]],"~:doc","Given before-lines, range, and after-lines where before-lines\n  and after-lines are sequences of lines, and range is a string\n  which has been formatted, reassemble these three chunks into a\n  single string with appropriate newlines joining them together.\n  Note that this is *not* an inverse to split-out-range, because\n  in that routine range is a seq of lines, and in this routine\n  range is a string.  Note also that we only join them with a \n  newline if there are two pieces, otherwise we get extra lines."],"^N","^1J","^6","zprint/range.cljc","^:",23,"~:method-params",["^12",[["^4F","^4G","^4H"]]],"~:protocol-impl",null,"~:arglists-meta",["^12",[null,null]],"^8",1,"~:variadic?",false,"^7",296,"~:ret-tag","~$string","^9",296,"~:max-fixed-arity",3,"~:fn-var",true,"^4D",["^12",["^4E",["^12",[["^4F","^4G","^4H"]]]]],"^4I","Given before-lines, range, and after-lines where before-lines\n  and after-lines are sequences of lines, and range is a string\n  which has been formatted, reassemble these three chunks into a\n  single string with appropriate newlines joining them together.\n  Note that this is *not* an inverse to split-out-range, because\n  in that routine range is a seq of lines, and in this routine\n  range is a string.  Note also that we only join them with a \n  newline if there are two pieces, otherwise we get extra lines."],"~$expand-range-to-top-level",["^ ","^4C",null,"^5",["^ ","^6","zprint/range.cljc","^7",164,"^8",7,"^9",164,"^:",32,"^4D",["^12",["^4E",["^12",[["~$filestring","~$lines","~$start","~$end","~$dbg?"]]]]],"^4I","Given a string which contains lines and a vector of those lines,\n  and a range of lines inside of them, expand the range such that\n  it covers everything from the first non-blank line beyond the\n  previous top level expression before the start to the end of the\n  top level expression containing the end of the range.  Returns\n  [actual-start actual-end].  Note that start, end, actual-start\n  and actual-end are all zero based line numbers."],"^N","^1Y","^6","zprint/range.cljc","^:",32,"^4J",["^12",[["^4S","^4T","^4U","^4V","^4W"]]],"^4K",null,"^4L",["^12",[null,null]],"^8",1,"^4M",false,"^7",164,"^4N","~$cljs.core/IVector","^9",164,"^4P",5,"^4Q",true,"^4D",["^12",["^4E",["^12",[["^4S","^4T","^4U","^4V","^4W"]]]]],"^4I","Given a string which contains lines and a vector of those lines,\n  and a range of lines inside of them, expand the range such that\n  it covers everything from the first non-blank line beyond the\n  previous top level expression before the start to the end of the\n  top level expression containing the end of the range.  Returns\n  [actual-start actual-end].  Note that start, end, actual-start\n  and actual-end are all zero based line numbers."],"~$find-row",["^ ","^4C",null,"^5",["^ ","^6","zprint/range.cljc","^7",83,"^8",7,"^9",83,"^:",15,"^4D",["^12",["^4E",["^12",[["~$row-vec","~$linenumber","^4W","~$scan-size"],["^4Z","~$n","^4W"]]]]],"^4I","Given a vector of rows, find the row that contains a line number,\n  linenumber, and return the number of that row in the vector.\n  row-vec looks like this: \n  [{:row 2, :col 1, :end-row 7, :end-col 21}\n   {:row 9, :col 1, :end-row 18, :end-col 6} \n   {:row 20, :col 1, :end-row 29, :end-col 6}]\n  If none exists, return the next row. Note that line numbers are 1\n  based, not zero based for this routine and the information in\n  row-vec, but the index into row-vec that this routine returns is\n  zero based.  Uses a binary search. If the line number is before the\n  first information in the row-vec, returns :before-beginning, and\n  if it is after the last information in the row-vec, returns\n  :beyond-end. Note that the row-vec as returned from edamame\n  parse-string-all contains not only maps like {:row 5 :end-row 10}\n  but also nils for things that didn't have paired delimiters around\n  them (e.g., keywords, strings, etc.).  You must remove those\n  from row-vec before calling find-row.  Note that find-row returns an \n  index into row-vec, and it must be the row-vec that has had nils \n  removed from it (or this routine would do that for you).","~:top-fn",["^ ","^4M",false,"~:fixed-arity",4,"^4P",4,"^4J",[["^4Z","^4[","^4W","^50"],["^4Z","~$n","^4W"]],"^4D",["^12",[["^4Z","^4[","^4W","^50"],["^4Z","~$n","^4W"]]],"^4L",["^12",[null,null]]]],"^N","^1N","^6","zprint/range.cljc","^:",15,"^51",["^ ","^4M",false,"^52",4,"^4P",4,"^4J",[["^4Z","^4[","^4W","^50"],["^4Z","~$n","^4W"]],"^4D",["^12",[["^4Z","^4[","^4W","^50"],["^4Z","~$n","^4W"]]],"^4L",["^12",[null,null]]],"^4J",[["^4Z","^4[","^4W","^50"],["^4Z","~$n","^4W"]],"^4K",null,"^52",4,"^4L",["^12",[null,null]],"^8",1,"^4M",false,"~:methods",[["^ ","^52",4,"^4M",false,"~:tag",["^M",["~$any","~$cljs.core/Keyword","~$number"]]],["^ ","^52",3,"^4M",false,"^54",["^M",["^55","^56","^57"]]]],"^7",83,"^9",83,"^4P",4,"^4Q",true,"^4D",["^12",[["^4Z","^4[","^4W","^50"],["^4Z","~$n","^4W"]]],"^4I","Given a vector of rows, find the row that contains a line number,\n  linenumber, and return the number of that row in the vector.\n  row-vec looks like this: \n  [{:row 2, :col 1, :end-row 7, :end-col 21}\n   {:row 9, :col 1, :end-row 18, :end-col 6} \n   {:row 20, :col 1, :end-row 29, :end-col 6}]\n  If none exists, return the next row. Note that line numbers are 1\n  based, not zero based for this routine and the information in\n  row-vec, but the index into row-vec that this routine returns is\n  zero based.  Uses a binary search. If the line number is before the\n  first information in the row-vec, returns :before-beginning, and\n  if it is after the last information in the row-vec, returns\n  :beyond-end. Note that the row-vec as returned from edamame\n  parse-string-all contains not only maps like {:row 5 :end-row 10}\n  but also nils for things that didn't have paired delimiters around\n  them (e.g., keywords, strings, etc.).  You must remove those\n  from row-vec before calling find-row.  Note that find-row returns an \n  index into row-vec, and it must be the row-vec that has had nils \n  removed from it (or this routine would do that for you)."],"~$scan-for-row",["^ ","^4C",null,"^5",["^ ","^6","zprint/range.cljc","^7",36,"^8",7,"^9",36,"^:",19,"^4D",["^12",["^4E",["^12",[["^4Z","~$row-vec-index","^4[","~$max-tries"]]]]],"^4I","Given a row-vec, and a current index into the row-vec, if the\n  linenumber is within that row, return the index to that row.   If\n  the linenumber is not in that row, then scan either way for\n  max-tries looking for a match for this linenumber.  Return the\n  row index if a row is found containing this linenumber. If it is\n  between two rows, return the row after.  If we fall off the either\n  end of the row-vec, then return :before-beginning or :beyone-end.  \n  If we don't find anything after trying for max-tries, :before or\n  :after, depending on which way we should try next."],"^N","^1G","^6","zprint/range.cljc","^:",19,"^4J",["^12",[["^4Z","^59","^4[","^5:"]]],"^4K",null,"^4L",["^12",[null,null]],"^8",1,"^4M",false,"^7",36,"^4N",["^M",["^55","^56","^57"]],"^9",36,"^4P",4,"^4Q",true,"^4D",["^12",["^4E",["^12",[["^4Z","^59","^4[","^5:"]]]]],"^4I","Given a row-vec, and a current index into the row-vec, if the\n  linenumber is within that row, return the index to that row.   If\n  the linenumber is not in that row, then scan either way for\n  max-tries looking for a match for this linenumber.  Return the\n  row index if a row is found containing this linenumber. If it is\n  between two rows, return the row after.  If we fall off the either\n  end of the row-vec, then return :before-beginning or :beyone-end.  \n  If we don't find anything after trying for max-tries, :before or\n  :after, depending on which way we should try next."],"~$row-before?",["^ ","^4C",null,"^5",["^ ","^6","zprint/range.cljc","^7",18,"^8",7,"^9",18,"^:",18,"^4D",["^12",["^4E",["^12",[["~$row-a","~$row-b"]]]]],"^4I","Given two rows, is the first before the second?"],"^N","^1Q","^6","zprint/range.cljc","^:",18,"^4J",["^12",[["^5<","^5="]]],"^4K",null,"^4L",["^12",[null,null]],"^8",1,"^4M",false,"^7",18,"^4N","~$boolean","^9",18,"^4P",2,"^4Q",true,"^4D",["^12",["^4E",["^12",[["^5<","^5="]]]]],"^4I","Given two rows, is the first before the second?"],"~$split-out-range",["^ ","^4C",null,"^5",["^ ","^6","zprint/range.cljc","^7",281,"^8",7,"^9",281,"^:",22,"^4D",["^12",["^4E",["^12",[["^4T","^4U","^4V"]]]]],"^4I","Given lines, a sequence of lines, and a start and end of a range,\n  split the sequence of lines into three parts: [before-lines range\n  after-lines].  If any of these collections would be empty, return\n  an empty sequence. End must be equal to or greater than start. If\n  end is neg?, there will be no range."],"^N","^27","^6","zprint/range.cljc","^:",22,"^4J",["^12",[["^4T","^4U","^4V"]]],"^4K",null,"^4L",["^12",[null,null]],"^8",1,"^4M",false,"^7",281,"^4N","^4X","^9",281,"^4P",3,"^4Q",true,"^4D",["^12",["^4E",["^12",[["^4T","^4U","^4V"]]]]],"^4I","Given lines, a sequence of lines, and a start and end of a range,\n  split the sequence of lines into three parts: [before-lines range\n  after-lines].  If any of these collections would be empty, return\n  an empty sequence. End must be equal to or greater than start. If\n  end is neg?, there will be no range."],"~$next-non-blank-line",["^ ","^4C",null,"^5",["^ ","^6","zprint/range.cljc","^7",137,"^8",7,"^9",137,"^:",26,"^4D",["^12",["^4E",["^12",[["~$line-vec","~$index"]]]]],"^4I","Given a sequence of lines and a starting line index in that sequence,\n  return the index of the first non-blank line including or after that\n  starting line index."],"^N","^1U","^6","zprint/range.cljc","^:",26,"^4J",["^12",[["^5A","^5B"]]],"^4K",null,"^4L",["^12",[null,null]],"^8",1,"^4M",false,"^7",137,"^9",137,"^4P",2,"^4Q",true,"^4D",["^12",["^4E",["^12",[["^5A","^5B"]]]]],"^4I","Given a sequence of lines and a starting line index in that sequence,\n  return the index of the first non-blank line including or after that\n  starting line index."],"~$between-rows?",["^ ","^4C",null,"^5",["^ ","^6","zprint/range.cljc","^7",24,"^8",7,"^9",24,"^:",20,"^4D",["^12",["^4E",["^12",[["^4[","^5<","^5="]]]]],"^4I","Given two rows, if the linenumber is between the rows, return true, else\n  nil."],"^N","^1V","^6","zprint/range.cljc","^:",20,"^4J",["^12",[["^4[","^5<","^5="]]],"^4K",null,"^4L",["^12",[null,null]],"^8",1,"^4M",false,"^7",24,"^4N",["^M",["^5>","~$clj-nil"]],"^9",24,"^4P",3,"^4Q",true,"^4D",["^12",["^4E",["^12",[["^4[","^5<","^5="]]]]],"^4I","Given two rows, if the linenumber is between the rows, return true, else\n  nil."],"~$abs",["^ ","^4C",null,"^5",["^ ","^6","zprint/range.cljc","^7",81,"^8",7,"^9",81,"^:",10,"^4D",["^12",["^4E",["^12",[["~$n"]]]]],"^4I","Return the absolute value of a number."],"^N","^23","^6","zprint/range.cljc","^:",10,"^4J",["^12",[["~$n"]]],"^4K",null,"^4L",["^12",[null,null]],"^8",1,"^4M",false,"^7",81,"^4N",["^M",[null,"^57"]],"^9",81,"^4P",1,"^4Q",true,"^4D",["^12",["^4E",["^12",[["~$n"]]]]],"^4I","Return the absolute value of a number."],"~$in-row?",["^ ","^4C",null,"^5",["^ ","^6","zprint/range.cljc","^7",9,"^8",7,"^9",9,"^:",14,"^4D",["^12",["^4E",["^12",[["~$n","~$row"]]]]],"^4I","If a line number n is in a particular edamame row, return the row map.\n  If it is not in the row, return +1 or -1 to indicate which direction\n  to look."],"^N","^24","^6","zprint/range.cljc","^:",14,"^4J",["^12",[["~$n","^5G"]]],"^4K",null,"^4L",["^12",[null,null]],"^8",1,"^4M",false,"^7",9,"^4N",["^M",[null,"^57","^5D"]],"^9",9,"^4P",2,"^4Q",true,"^4D",["^12",["^4E",["^12",[["~$n","^5G"]]]]],"^4I","If a line number n is in a particular edamame row, return the row map.\n  If it is not in the row, return +1 or -1 to indicate which direction\n  to look."],"~$previous-non-blank-line",["^ ","^4C",null,"^5",["^ ","^6","zprint/range.cljc","^7",150,"^8",7,"^9",150,"^:",30,"^4D",["^12",["^4E",["^12",[["^5A","^5B"]]]]],"^4I","Given a sequence of lines and a starting line index in that sequence,\n  return the index of the first previous non-blank line including or before\n  that starting line index.  Returns -1 if no non-blank line found."],"^N","^29","^6","zprint/range.cljc","^:",30,"^4J",["^12",[["^5A","^5B"]]],"^4K",null,"^4L",["^12",[null,null]],"^8",1,"^4M",false,"^7",150,"^4N",["^M",[null,"^57"]],"^9",150,"^4P",2,"^4Q",true,"^4D",["^12",["^4E",["^12",[["^5A","^5B"]]]]],"^4I","Given a sequence of lines and a starting line index in that sequence,\n  return the index of the first previous non-blank line including or before\n  that starting line index.  Returns -1 if no non-blank line found."]],"^10",["^ ","^V","^V"],"~:cljs.analyzer/constants",["^ ","^X",["^M",["~:features","~:end-row","~:else","~:read-cond","~:all","~:fail","~:after","~:before-beginning","~:current","~:do-nothing","~:before","~:clj","^1@","~:beyond-end","~:row","~:auto-resolve"]],"~:order",["^5W","^5K","^5V","^5Q","^5L","^5P","^5T","^5O","^5N","^5J","^5M","^5X","^5U","^1@","^5R","^5S"]],"^16",["^ ","^Y",["^M",[]]],"^17",["^ "],"^18",["^W","^V","^T","^U"]],"^Q","^O","~:ns-specs",["^ "],"~:ns-spec-vars",["^M",[]],"~:compiler-options",["^2>",[["^60","~:static-fns"],true,["^60","~:shadow-tweaks"],null,["^60","~:source-map-inline"],null,["^60","~:elide-asserts"],false,["^60","~:optimize-constants"],null,["^60","^1="],null,["^60","~:external-config"],null,["^60","~:tooling-config"],null,["^60","~:emit-constants"],null,["^60","~:load-tests"],null,["^60","~:form-size-threshold"],null,["^60","~:data-readers"],null,["^60","~:infer-externs"],"~:auto",["^60","^1?"],null,["~:js-options","~:js-provider"],"~:shadow",["~:mode"],"~:dev",["^60","~:fn-invoke-direct"],null,["^60","~:source-map"],"/dev/null"]]]