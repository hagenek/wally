["^ ","~:output",["^ ","~:js","goog.provide('zprint.zprint');\n/**\n * Produce a blank string of desired size.\n */\nzprint.zprint.blanks = (function zprint$zprint$blanks(n){\nreturn cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core.str,cljs.core.repeat.cljs$core$IFn$_invoke$arity$2(n,\" \"));\n});\n/**\n * Produce a dot string of desired size.\n */\nzprint.zprint.dots = (function zprint$zprint$dots(n){\nreturn cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core.str,cljs.core.repeat.cljs$core$IFn$_invoke$arity$2(n,\".\"));\n});\n/**\n * Make a version of conj! that take multiple arguments.\n */\nzprint.zprint.conj_it_BANG_ = (function zprint$zprint$conj_it_BANG_(var_args){\nvar args__4824__auto__ = [];\nvar len__4818__auto___46181 = arguments.length;\nvar i__4819__auto___46182 = (0);\nwhile(true){\nif((i__4819__auto___46182 < len__4818__auto___46181)){\nargs__4824__auto__.push((arguments[i__4819__auto___46182]));\n\nvar G__46183 = (i__4819__auto___46182 + (1));\ni__4819__auto___46182 = G__46183;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4825__auto__ = ((((0) < args__4824__auto__.length))?(new cljs.core.IndexedSeq(args__4824__auto__.slice((0)),(0),null)):null);\nreturn zprint.zprint.conj_it_BANG_.cljs$core$IFn$_invoke$arity$variadic(argseq__4825__auto__);\n});\n\n(zprint.zprint.conj_it_BANG_.cljs$core$IFn$_invoke$arity$variadic = (function (rest){\nvar out = cljs.core.first(rest);\nvar more = cljs.core.next(rest);\nwhile(true){\nif(more){\nvar G__46184 = cljs.core.conj_BANG_.cljs$core$IFn$_invoke$arity$2(out,cljs.core.first(more));\nvar G__46185 = cljs.core.next(more);\nout = G__46184;\nmore = G__46185;\ncontinue;\n} else {\nreturn out;\n}\nbreak;\n}\n}));\n\n(zprint.zprint.conj_it_BANG_.cljs$lang$maxFixedArity = (0));\n\n/** @this {Function} */\n(zprint.zprint.conj_it_BANG_.cljs$lang$applyTo = (function (seq45285){\nvar self__4806__auto__ = this;\nreturn self__4806__auto__.cljs$core$IFn$_invoke$arity$variadic(cljs.core.seq(seq45285));\n}));\n\n/**\n * Do split for newlines, instead of using regular expressions.\n */\nzprint.zprint.split_lf = (function zprint$zprint$split_lf(s){\nvar input = s;\nvar out = cljs.core.PersistentVector.EMPTY;\nwhile(true){\nif(cljs.core.not(input)){\nreturn out;\n} else {\nvar next_lf = clojure.string.index_of.cljs$core$IFn$_invoke$arity$2(input,\"\\n\");\nvar chunk = (cljs.core.truth_(next_lf)?cljs.core.subs.cljs$core$IFn$_invoke$arity$3(input,(0),next_lf):input);\nvar G__46189 = (cljs.core.truth_(next_lf)?cljs.core.subs.cljs$core$IFn$_invoke$arity$2(input,(next_lf + (1))):null);\nvar G__46190 = cljs.core.conj.cljs$core$IFn$_invoke$arity$2(out,chunk);\ninput = G__46189;\nout = G__46190;\ncontinue;\n}\nbreak;\n}\n});\n/**\n * Do split for newlines, instead of using regular expressions.\n *   Maximum split is 2.\n */\nzprint.zprint.split_lf_2 = (function zprint$zprint$split_lf_2(s){\nvar temp__5751__auto__ = clojure.string.index_of.cljs$core$IFn$_invoke$arity$2(s,\"\\n\");\nif(cljs.core.truth_(temp__5751__auto__)){\nvar next_lf = temp__5751__auto__;\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.subs.cljs$core$IFn$_invoke$arity$3(s,(0),next_lf),cljs.core.subs.cljs$core$IFn$_invoke$arity$2(s,(next_lf + (1)))], null);\n} else {\nreturn new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [s], null);\n}\n});\nzprint.zprint.zpmap = (function zprint$zprint$zpmap(var_args){\nvar G__45301 = arguments.length;\nswitch (G__45301) {\ncase 3:\nreturn zprint.zprint.zpmap.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase 4:\nreturn zprint.zprint.zpmap.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\n(zprint.zprint.zpmap.cljs$core$IFn$_invoke$arity$3 = (function (options,f,coll){\nreturn cljs.core.map.cljs$core$IFn$_invoke$arity$2(f,coll);\n}));\n\n(zprint.zprint.zpmap.cljs$core$IFn$_invoke$arity$4 = (function (options,f,coll1,coll2){\nreturn cljs.core.map.cljs$core$IFn$_invoke$arity$3(f,coll1,coll2);\n}));\n\n(zprint.zprint.zpmap.cljs$lang$maxFixedArity = 4);\n\n/**\n * Takes an option map and the return from zfuture.  If the\n *   options map has (:parallel? options) as true, then deref\n *   the value, otherwise just pass it through.\n */\nzprint.zprint.zat = (function zprint$zprint$zat(options,value){\nreturn value;\n});\nzprint.zprint.fzprint_dbg = cljs.core.atom.cljs$core$IFn$_invoke$arity$1(null);\n/**\n * Accept a style-vec that we are about to hand to style-lines, and\n *   output it if called for, to aid in debugging.\n */\nzprint.zprint.log_lines = (function zprint$zprint$log_lines(p__45305,dbg_output,ind,style_vec){\nvar map__45306 = p__45305;\nvar map__45306__$1 = cljs.core.__destructure_map(map__45306);\nvar options = map__45306__$1;\nvar dbg_print_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__45306__$1,new cljs.core.Keyword(null,\"dbg-print?\",\"dbg-print?\",-660113872));\nvar dbg_indent = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__45306__$1,new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778));\nvar in_hang_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__45306__$1,new cljs.core.Keyword(null,\"in-hang?\",\"in-hang?\",-1065695639));\nif(cljs.core.truth_(dbg_print_QMARK_)){\nif(cljs.core.truth_(style_vec)){\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([dbg_indent,dbg_output,\"--------------\",\"in-hang?\",in_hang_QMARK_], 0));\n\nreturn cljs.core.prn.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([style_vec], 0));\n} else {\nreturn cljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([dbg_indent,dbg_output,\"--------------- no style-vec\"], 0));\n}\n} else {\nreturn null;\n}\n});\n/**\n * Show this thing as a function?\n */\nzprint.zprint.showfn_QMARK_ = (function zprint$zprint$showfn_QMARK_(fn_map,f){\nif((!(typeof f === 'string'))){\nvar f_str = cljs.core.str.cljs$core$IFn$_invoke$arity$1(f);\nvar or__4212__auto__ = (fn_map.cljs$core$IFn$_invoke$arity$1 ? fn_map.cljs$core$IFn$_invoke$arity$1(f_str) : fn_map.call(null,f_str));\nif(cljs.core.truth_(or__4212__auto__)){\nreturn or__4212__auto__;\n} else {\nvar or__4212__auto____$1 = cljs.core.re_find(/clojure/,f_str);\nif(cljs.core.truth_(or__4212__auto____$1)){\nreturn or__4212__auto____$1;\n} else {\nif((f instanceof cljs.core.Symbol)){\ntry{var or__4212__auto____$2 = cljs.core.re_find(/clojure/,cljs.core.str.cljs$core$IFn$_invoke$arity$1(new cljs.core.Keyword(null,\"ns\",\"ns\",441598760).cljs$core$IFn$_invoke$arity$1(cljs.core.meta(f))));\nif(cljs.core.truth_(or__4212__auto____$2)){\nreturn or__4212__auto____$2;\n} else {\nvar G__45308 = cljs.core.name(f);\nreturn (fn_map.cljs$core$IFn$_invoke$arity$1 ? fn_map.cljs$core$IFn$_invoke$arity$1(G__45308) : fn_map.call(null,G__45308));\n}\n}catch (e45307){var e = e45307;\nreturn null;\n}} else {\nreturn null;\n}\n}\n}\n} else {\nreturn null;\n}\n});\n/**\n * Show this thing as a user defined function?  Assumes that we\n *   have already handled any clojure defined functions!\n */\nzprint.zprint.show_user_fn_QMARK_ = (function zprint$zprint$show_user_fn_QMARK_(options,f){\nif((!(typeof f === 'string'))){\nvar f_str = cljs.core.str.cljs$core$IFn$_invoke$arity$1(f);\nvar user_fn_map = new cljs.core.Keyword(null,\"user-fn-map\",\"user-fn-map\",-908243227).cljs$core$IFn$_invoke$arity$1(options);\nvar or__4212__auto__ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(user_fn_map,f_str);\nif(cljs.core.truth_(or__4212__auto__)){\nreturn or__4212__auto__;\n} else {\nif((f instanceof cljs.core.Symbol)){\ntry{var or__4212__auto____$1 = (!(cljs.core.empty_QMARK_(cljs.core.str.cljs$core$IFn$_invoke$arity$1(new cljs.core.Keyword(null,\"ns\",\"ns\",441598760).cljs$core$IFn$_invoke$arity$1(cljs.core.meta(f))))));\nif(or__4212__auto____$1){\nreturn or__4212__auto____$1;\n} else {\nreturn cljs.core.get.cljs$core$IFn$_invoke$arity$2(user_fn_map,cljs.core.name(f));\n}\n}catch (e45309){var e = e45309;\nreturn null;\n}} else {\nreturn null;\n}\n}\n} else {\nreturn null;\n}\n});\nzprint.zprint.right_separator_map = new cljs.core.PersistentArrayMap(null, 3, [\")\",(1),\"]\",(1),\"}\",(1)], null);\n/**\n * Given the fn-style, is the first output good enough to be worth\n *   doing. p is pretty, which is typically hanging, and b is basic, which\n *   is typically flow. p-count is the number of elements in the hang.\n */\nzprint.zprint.good_enough_QMARK_ = (function zprint$zprint$good_enough_QMARK_(caller,p__45310,fn_style,p_count,indent_diff,p__45311,p__45312){\nvar map__45313 = p__45310;\nvar map__45313__$1 = cljs.core.__destructure_map(map__45313);\nvar options = map__45313__$1;\nvar map__45314 = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__45313__$1,new cljs.core.Keyword(null,\"tuning\",\"tuning\",-48660925));\nvar map__45314__$1 = cljs.core.__destructure_map(map__45314);\nvar hang_flow = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__45314__$1,new cljs.core.Keyword(null,\"hang-flow\",\"hang-flow\",428126548));\nvar hang_type_flow = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__45314__$1,new cljs.core.Keyword(null,\"hang-type-flow\",\"hang-type-flow\",-1585576590));\nvar hang_flow_limit = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__45314__$1,new cljs.core.Keyword(null,\"hang-flow-limit\",\"hang-flow-limit\",389146586));\nvar general_hang_adjust = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__45314__$1,new cljs.core.Keyword(null,\"general-hang-adjust\",\"general-hang-adjust\",-1631406987));\nvar hang_if_equal_flow_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__45314__$1,new cljs.core.Keyword(null,\"hang-if-equal-flow?\",\"hang-if-equal-flow?\",-1113113992));\nvar map__45315 = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__45313__$1,caller);\nvar map__45315__$1 = cljs.core.__destructure_map(map__45315);\nvar hang_expand = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__45315__$1,new cljs.core.Keyword(null,\"hang-expand\",\"hang-expand\",1086807559));\nvar hang_diff = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__45315__$1,new cljs.core.Keyword(null,\"hang-diff\",\"hang-diff\",-1575205424));\nvar hang_size = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__45315__$1,new cljs.core.Keyword(null,\"hang-size\",\"hang-size\",-347944063));\nvar hang_adjust = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__45315__$1,new cljs.core.Keyword(null,\"hang-adjust\",\"hang-adjust\",-613514382));\nvar width = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__45313__$1,new cljs.core.Keyword(null,\"width\",\"width\",-384071477));\nvar rightcnt = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__45313__$1,new cljs.core.Keyword(null,\"rightcnt\",\"rightcnt\",-45750070));\nvar dbg_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__45313__$1,new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771));\nvar vec__45316 = p__45311;\nvar p_lines = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45316,(0),null);\nvar p_maxwidth = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45316,(1),null);\nvar p_length_seq = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45316,(2),null);\nvar p_what = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45316,(3),null);\nvar vec__45319 = p__45312;\nvar b_lines = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45319,(0),null);\nvar b_maxwidth = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45319,(1),null);\nvar _ = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45319,(2),null);\nvar b_what = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45319,(3),null);\nvar p_last_maxwidth = cljs.core.last(p_length_seq);\nvar hang_diff__$1 = (function (){var or__4212__auto__ = hang_diff;\nif(cljs.core.truth_(or__4212__auto__)){\nreturn or__4212__auto__;\n} else {\nreturn (0);\n}\n})();\nvar hang_expand__$1 = (function (){var or__4212__auto__ = hang_expand;\nif(cljs.core.truth_(or__4212__auto__)){\nreturn or__4212__auto__;\n} else {\nreturn 1000.0;\n}\n})();\nvar hang_adjust__$1 = (function (){var or__4212__auto__ = hang_adjust;\nif(cljs.core.truth_(or__4212__auto__)){\nreturn or__4212__auto__;\n} else {\nreturn general_hang_adjust;\n}\n})();\nvar options__$1 = (cljs.core.truth_((function (){var or__4212__auto__ = p_what;\nif(cljs.core.truth_(or__4212__auto__)){\nreturn or__4212__auto__;\n} else {\nreturn b_what;\n}\n})())?cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(options,new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771),true):options);\nvar result = ((cljs.core.not(b_lines))?true:(function (){var and__4210__auto__ = p_lines;\nif(cljs.core.truth_(and__4210__auto__)){\nvar and__4210__auto____$1 = (p_last_maxwidth <= (width - (zprint.zprint.fix_rightcnt.cljs$core$IFn$_invoke$arity$1 ? zprint.zprint.fix_rightcnt.cljs$core$IFn$_invoke$arity$1(rightcnt) : zprint.zprint.fix_rightcnt.call(null,rightcnt))));\nif(and__4210__auto____$1){\nvar and__4210__auto____$2 = (p_maxwidth <= width);\nif(and__4210__auto____$2){\nvar or__4212__auto__ = (p_lines === (0));\nif(or__4212__auto__){\nreturn or__4212__auto__;\n} else {\nvar and__4210__auto____$3 = (b_lines > (0));\nif(and__4210__auto____$3){\nvar and__4210__auto____$4 = (p_count > (0));\nif(and__4210__auto____$4){\nif(cljs.core.truth_((function (){var and__4210__auto____$5 = cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(p_lines,b_lines);\nif(and__4210__auto____$5){\nreturn hang_if_equal_flow_QMARK_;\n} else {\nreturn and__4210__auto____$5;\n}\n})())){\nreturn true;\n} else {\nvar and__4210__auto____$5 = (((indent_diff <= hang_diff__$1))?true:(((p_lines - (1)) / p_count) <= hang_expand__$1));\nif(and__4210__auto____$5){\nvar and__4210__auto____$6 = (cljs.core.truth_(hang_size)?(p_lines < hang_size):true);\nif(and__4210__auto____$6){\nvar factor = ((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(fn_style,new cljs.core.Keyword(null,\"hang\",\"hang\",-1007256173)))?hang_type_flow:hang_flow);\nif((p_lines > hang_flow_limit)){\nreturn ((p_lines - (1)) <= b_lines);\n} else {\nreturn (((p_lines + hang_adjust__$1) / b_lines) < factor);\n}\n} else {\nreturn and__4210__auto____$6;\n}\n} else {\nreturn and__4210__auto____$5;\n}\n}\n} else {\nreturn and__4210__auto____$4;\n}\n} else {\nreturn and__4210__auto____$3;\n}\n}\n} else {\nreturn and__4210__auto____$2;\n}\n} else {\nreturn and__4210__auto____$1;\n}\n} else {\nreturn and__4210__auto__;\n}\n})());\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options__$1))){\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options__$1),(cljs.core.truth_(result)?\"++++++\":\"XXXXXX\"),\"p-what\",p_what,\"good-enough? caller:\",caller,\"fn-style:\",fn_style,\"width:\",width,\"rightcnt:\",rightcnt,\"hang-expand:\",hang_expand__$1,\"p-count:\",p_count,\"p-lines:\",p_lines,\"p-maxwidth:\",p_maxwidth,\"indent-diff:\",indent_diff,\"hang-diff:\",hang_diff__$1,\"p-last-maxwidth:\",p_last_maxwidth,\"b-lines:\",b_lines,\"b-maxwidth:\",b_maxwidth], 0));\n} else {\n}\n\nreturn result;\n});\n/**\n * Add :in-hang? true to the options map.\n */\nzprint.zprint.in_hang = (function zprint$zprint$in_hang(options){\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"in-hang?\",\"in-hang?\",-1065695639).cljs$core$IFn$_invoke$arity$1(options))){\nreturn options;\n} else {\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"do-in-hang?\",\"do-in-hang?\",-1235364947).cljs$core$IFn$_invoke$arity$1(options))){\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(options,new cljs.core.Keyword(null,\"in-hang?\",\"in-hang?\",-1065695639),(function (){var or__4212__auto__ = new cljs.core.Keyword(null,\"depth\",\"depth\",1768663640).cljs$core$IFn$_invoke$arity$1(options);\nif(cljs.core.truth_(or__4212__auto__)){\nreturn or__4212__auto__;\n} else {\nreturn true;\n}\n})());\n} else {\nreturn options;\n}\n}\n});\n/**\n * Scan a collection, and return true if it contains any nils or empty\n *   collections.\n */\nzprint.zprint.contains_nil_QMARK_ = (function zprint$zprint$contains_nil_QMARK_(coll){\nreturn cljs.core.some((function (p1__45322_SHARP_){\nif(cljs.core.coll_QMARK_(p1__45322_SHARP_)){\nreturn cljs.core.empty_QMARK_(p1__45322_SHARP_);\n} else {\nreturn (p1__45322_SHARP_ == null);\n}\n}),coll);\n});\n/**\n * Concatentate multiple sequences, but if any of them are nil, return nil.\n *   This version is 15-20% slower than the version below. Keeping it around\n *   just for illustrative purposes.\n */\nzprint.zprint.concat_no_nil_alt = (function zprint$zprint$concat_no_nil_alt(var_args){\nvar args__4824__auto__ = [];\nvar len__4818__auto___46209 = arguments.length;\nvar i__4819__auto___46210 = (0);\nwhile(true){\nif((i__4819__auto___46210 < len__4818__auto___46209)){\nargs__4824__auto__.push((arguments[i__4819__auto___46210]));\n\nvar G__46211 = (i__4819__auto___46210 + (1));\ni__4819__auto___46210 = G__46211;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4825__auto__ = ((((0) < args__4824__auto__.length))?(new cljs.core.IndexedSeq(args__4824__auto__.slice((0)),(0),null)):null);\nreturn zprint.zprint.concat_no_nil_alt.cljs$core$IFn$_invoke$arity$variadic(argseq__4825__auto__);\n});\n\n(zprint.zprint.concat_no_nil_alt.cljs$core$IFn$_invoke$arity$variadic = (function (rest){\nvar coll = rest;\nvar out = cljs.core.transient$(cljs.core.PersistentVector.EMPTY);\nwhile(true){\nvar c = cljs.core.first(coll);\nif(cljs.core.not(c)){\nreturn cljs.core.persistent_BANG_(out);\n} else {\nif(((((cljs.core.coll_QMARK_(c)) && ((!(cljs.core.empty_QMARK_(c)))))) || ((!((c == null)))))){\nvar G__46212 = cljs.core.next(coll);\nvar G__46213 = cljs.core.conj_BANG_.cljs$core$IFn$_invoke$arity$2(out,c);\ncoll = G__46212;\nout = G__46213;\ncontinue;\n} else {\nreturn null;\n}\n}\nbreak;\n}\n}));\n\n(zprint.zprint.concat_no_nil_alt.cljs$lang$maxFixedArity = (0));\n\n/** @this {Function} */\n(zprint.zprint.concat_no_nil_alt.cljs$lang$applyTo = (function (seq45323){\nvar self__4806__auto__ = this;\nreturn self__4806__auto__.cljs$core$IFn$_invoke$arity$variadic(cljs.core.seq(seq45323));\n}));\n\n/**\n * Concatentate multiple sequences, but if any of them are nil or empty\n *   collections, return nil.\n */\nzprint.zprint.concat_no_nil_pre_noseq = (function zprint$zprint$concat_no_nil_pre_noseq(var_args){\nvar args__4824__auto__ = [];\nvar len__4818__auto___46214 = arguments.length;\nvar i__4819__auto___46215 = (0);\nwhile(true){\nif((i__4819__auto___46215 < len__4818__auto___46214)){\nargs__4824__auto__.push((arguments[i__4819__auto___46215]));\n\nvar G__46216 = (i__4819__auto___46215 + (1));\ni__4819__auto___46215 = G__46216;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4825__auto__ = ((((0) < args__4824__auto__.length))?(new cljs.core.IndexedSeq(args__4824__auto__.slice((0)),(0),null)):null);\nreturn zprint.zprint.concat_no_nil_pre_noseq.cljs$core$IFn$_invoke$arity$variadic(argseq__4825__auto__);\n});\n\n(zprint.zprint.concat_no_nil_pre_noseq.cljs$core$IFn$_invoke$arity$variadic = (function (rest){\nvar result = cljs.core.reduce.cljs$core$IFn$_invoke$arity$3((function (v,o){\nif(cljs.core.coll_QMARK_(o)){\nif(cljs.core.empty_QMARK_(o)){\nreturn cljs.core.reduced(null);\n} else {\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(cljs.core.conj_BANG_,v,o);\n}\n} else {\nif((o == null)){\nreturn cljs.core.reduced(null);\n} else {\nreturn cljs.core.conj_BANG_.cljs$core$IFn$_invoke$arity$2(v,o);\n}\n}\n}),cljs.core.transient$(cljs.core.PersistentVector.EMPTY),rest);\nif(cljs.core.truth_(result)){\nreturn cljs.core.persistent_BANG_(result);\n} else {\nreturn null;\n}\n}));\n\n(zprint.zprint.concat_no_nil_pre_noseq.cljs$lang$maxFixedArity = (0));\n\n/** @this {Function} */\n(zprint.zprint.concat_no_nil_pre_noseq.cljs$lang$applyTo = (function (seq45328){\nvar self__4806__auto__ = this;\nreturn self__4806__auto__.cljs$core$IFn$_invoke$arity$variadic(cljs.core.seq(seq45328));\n}));\n\n/**\n * Concatentate multiple sequences, but if any of them are nil or empty\n *   collections, return nil. If any of them are :noseq, just skip them.\n *   When complete, check the last element-- if it is a :right, and if it\n *   the previous element is a :newline or :indent, then ensure that the\n *   number of spaces in that previous element matches the number to the\n *   right of the :right.\n */\nzprint.zprint.concat_no_nil = (function zprint$zprint$concat_no_nil(var_args){\nvar args__4824__auto__ = [];\nvar len__4818__auto___46218 = arguments.length;\nvar i__4819__auto___46219 = (0);\nwhile(true){\nif((i__4819__auto___46219 < len__4818__auto___46218)){\nargs__4824__auto__.push((arguments[i__4819__auto___46219]));\n\nvar G__46220 = (i__4819__auto___46219 + (1));\ni__4819__auto___46219 = G__46220;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4825__auto__ = ((((0) < args__4824__auto__.length))?(new cljs.core.IndexedSeq(args__4824__auto__.slice((0)),(0),null)):null);\nreturn zprint.zprint.concat_no_nil.cljs$core$IFn$_invoke$arity$variadic(argseq__4825__auto__);\n});\n\n(zprint.zprint.concat_no_nil.cljs$core$IFn$_invoke$arity$variadic = (function (rest){\nvar result = cljs.core.reduce.cljs$core$IFn$_invoke$arity$3((function (v,o){\nif(cljs.core.coll_QMARK_(o)){\nif(cljs.core.empty_QMARK_(o)){\nreturn cljs.core.reduced(null);\n} else {\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(cljs.core.conj_BANG_,v,o);\n}\n} else {\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(new cljs.core.Keyword(null,\"noseq\",\"noseq\",405935768),o)){\nreturn v;\n} else {\nif((o == null)){\nreturn cljs.core.reduced(null);\n} else {\nreturn cljs.core.conj_BANG_.cljs$core$IFn$_invoke$arity$2(v,o);\n}\n}\n}\n}),cljs.core.transient$(cljs.core.PersistentVector.EMPTY),rest);\nif(cljs.core.truth_(result)){\nvar result__$1 = cljs.core.persistent_BANG_(result);\nif((cljs.core.count(result__$1) < (2))){\nreturn result__$1;\n} else {\nvar vec__45335 = cljs.core.peek(result__$1);\nvar _ = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45335,(0),null);\nvar ___$1 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45335,(1),null);\nvar what = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45335,(2),null);\nvar right_ind = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45335,(3),null);\nvar last_element = vec__45335;\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(what,new cljs.core.Keyword(null,\"right\",\"right\",-452581833))){\nvar previous_index = (cljs.core.count(result__$1) - (2));\nvar vec__45338 = cljs.core.nth.cljs$core$IFn$_invoke$arity$2(result__$1,previous_index);\nvar s = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45338,(0),null);\nvar color = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45338,(1),null);\nvar previous_what = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45338,(2),null);\nif(((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(previous_what,new cljs.core.Keyword(null,\"newline\",\"newline\",1790071323))) || (cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(previous_what,new cljs.core.Keyword(null,\"indent\",\"indent\",-148200125))))){\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2((zprint.zprint.count_right_blanks.cljs$core$IFn$_invoke$arity$1 ? zprint.zprint.count_right_blanks.cljs$core$IFn$_invoke$arity$1(s) : zprint.zprint.count_right_blanks.call(null,s)),right_ind)){\nreturn result__$1;\n} else {\nvar new_previous = new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [[cljs.core.str.cljs$core$IFn$_invoke$arity$1((zprint.zprint.trimr_blanks.cljs$core$IFn$_invoke$arity$1 ? zprint.zprint.trimr_blanks.cljs$core$IFn$_invoke$arity$1(s) : zprint.zprint.trimr_blanks.call(null,s))),cljs.core.str.cljs$core$IFn$_invoke$arity$1(zprint.zprint.blanks(right_ind))].join(''),color,previous_what], null);\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(result__$1,previous_index,new_previous);\n}\n} else {\nreturn result__$1;\n}\n} else {\nreturn result__$1;\n}\n}\n} else {\nreturn null;\n}\n}));\n\n(zprint.zprint.concat_no_nil.cljs$lang$maxFixedArity = (0));\n\n/** @this {Function} */\n(zprint.zprint.concat_no_nil.cljs$lang$applyTo = (function (seq45330){\nvar self__4806__auto__ = this;\nreturn self__4806__auto__.cljs$core$IFn$_invoke$arity$variadic(cljs.core.seq(seq45330));\n}));\n\n/**\n * Concatentate multiple sequences, but if any of them are nil or empty\n *   collections, return nil. If any of them are :noseq, just skip them.\n */\nzprint.zprint.concat_no_nil_pre_right = (function zprint$zprint$concat_no_nil_pre_right(var_args){\nvar args__4824__auto__ = [];\nvar len__4818__auto___46221 = arguments.length;\nvar i__4819__auto___46222 = (0);\nwhile(true){\nif((i__4819__auto___46222 < len__4818__auto___46221)){\nargs__4824__auto__.push((arguments[i__4819__auto___46222]));\n\nvar G__46223 = (i__4819__auto___46222 + (1));\ni__4819__auto___46222 = G__46223;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4825__auto__ = ((((0) < args__4824__auto__.length))?(new cljs.core.IndexedSeq(args__4824__auto__.slice((0)),(0),null)):null);\nreturn zprint.zprint.concat_no_nil_pre_right.cljs$core$IFn$_invoke$arity$variadic(argseq__4825__auto__);\n});\n\n(zprint.zprint.concat_no_nil_pre_right.cljs$core$IFn$_invoke$arity$variadic = (function (rest){\nvar result = cljs.core.reduce.cljs$core$IFn$_invoke$arity$3((function (v,o){\nif(cljs.core.coll_QMARK_(o)){\nif(cljs.core.empty_QMARK_(o)){\nreturn cljs.core.reduced(null);\n} else {\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(cljs.core.conj_BANG_,v,o);\n}\n} else {\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(new cljs.core.Keyword(null,\"noseq\",\"noseq\",405935768),o)){\nreturn v;\n} else {\nif((o == null)){\nreturn cljs.core.reduced(null);\n} else {\nreturn cljs.core.conj_BANG_.cljs$core$IFn$_invoke$arity$2(v,o);\n}\n}\n}\n}),cljs.core.transient$(cljs.core.PersistentVector.EMPTY),rest);\nif(cljs.core.truth_(result)){\nreturn cljs.core.persistent_BANG_(result);\n} else {\nreturn null;\n}\n}));\n\n(zprint.zprint.concat_no_nil_pre_right.cljs$lang$maxFixedArity = (0));\n\n/** @this {Function} */\n(zprint.zprint.concat_no_nil_pre_right.cljs$lang$applyTo = (function (seq45342){\nvar self__4806__auto__ = this;\nreturn self__4806__auto__.cljs$core$IFn$_invoke$arity$variadic(cljs.core.seq(seq45342));\n}));\n\n/**\n * Remove a single thing from a sequence.\n */\nzprint.zprint.remove_one = (function zprint$zprint$remove_one(s,index){\nreturn cljs.core.concat.cljs$core$IFn$_invoke$arity$2(cljs.core.take.cljs$core$IFn$_invoke$arity$2(index,s),cljs.core.drop.cljs$core$IFn$_invoke$arity$2((index + (1)),s));\n});\n/**\n * Ensure that whatever we have is a vector.\n */\nzprint.zprint.force_vector = (function zprint$zprint$force_vector(coll){\nif(cljs.core.vector_QMARK_(coll)){\nreturn coll;\n} else {\nreturn cljs.core.into.cljs$core$IFn$_invoke$arity$2(cljs.core.PersistentVector.EMPTY,coll);\n}\n});\n/**\n * Takes a string, and returns the fn-style if it is a keyword and\n *   without the : it can be found in the fn-map.\n */\nzprint.zprint.keyword_fn_QMARK_ = (function zprint$zprint$keyword_fn_QMARK_(options,s){\nvar vec__45343 = clojure.string.split.cljs$core$IFn$_invoke$arity$2(s,/^:/);\nvar left = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45343,(0),null);\nvar right = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45343,(1),null);\nif(cljs.core.truth_(right)){\nvar fexpr__45346 = new cljs.core.Keyword(null,\"fn-map\",\"fn-map\",565481146).cljs$core$IFn$_invoke$arity$1(options);\nreturn (fexpr__45346.cljs$core$IFn$_invoke$arity$1 ? fexpr__45346.cljs$core$IFn$_invoke$arity$1(right) : fexpr__45346.call(null,right));\n} else {\nreturn null;\n}\n});\n/**\n * Given the options map, return the max length.  This might be\n *   a constant number, but it might be based on the depth as well.\n *   Returns nil of there is no max-length set.\n */\nzprint.zprint.get_max_length = (function zprint$zprint$get_max_length(p__45347){\nvar map__45348 = p__45347;\nvar map__45348__$1 = cljs.core.__destructure_map(map__45348);\nvar options = map__45348__$1;\nvar max_length = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__45348__$1,new cljs.core.Keyword(null,\"max-length\",\"max-length\",-254826109));\nvar depth = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__45348__$1,new cljs.core.Keyword(null,\"depth\",\"depth\",1768663640));\nif(cljs.core.truth_(max_length)){\nif(cljs.core.vector_QMARK_(max_length)){\nreturn cljs.core.nth.cljs$core$IFn$_invoke$arity$2(max_length,(function (){var x__4298__auto__ = (depth - (1));\nvar y__4299__auto__ = (cljs.core.count(max_length) - (1));\nreturn ((x__4298__auto__ < y__4299__auto__) ? x__4298__auto__ : y__4299__auto__);\n})());\n} else {\nreturn max_length;\n}\n} else {\nreturn null;\n}\n});\n/**\n * Given an options map, return another options map with no\n *   :max-length key.  This is to that you can call a routine that\n *   normally deals with :max-length and get it to do the normal\n *   thing.\n */\nzprint.zprint.no_max_length = (function zprint$zprint$no_max_length(options){\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(options,new cljs.core.Keyword(null,\"max-length\",\"max-length\",-254826109),(10000));\n});\n/**\n * Take the vector carrying the intermediate results, and\n *   do the right thing with a new string. Vector is\n *   [ 0 out - vector accumulating line lengths \n *  1 cur-len - length of current line\n *  just-eol? - did we just do an eol?\n *  ]\n *   s - string to add to current line\n *   tag - element type of string (comment's don't count in length)\n *   eol? - should we terminate line after adding count of s\n */\nzprint.zprint.accumulate_ll = (function zprint$zprint$accumulate_ll(count_comment_QMARK_,p__45349,s,tag,eol_QMARK_){\nvar vec__45350 = p__45349;\nvar out = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45350,(0),null);\nvar cur_len = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45350,(1),null);\nvar just_eol_QMARK_ = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45350,(2),null);\nvar just_comment_QMARK_ = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45350,(3),null);\nvar in$ = vec__45350;\nvar comment_QMARK_ = ((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(tag,new cljs.core.Keyword(null,\"comment\",\"comment\",532206069))) || (cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(tag,new cljs.core.Keyword(null,\"comment-inline\",\"comment-inline\",712944405))));\nvar count_s = ((((comment_QMARK_) && (cljs.core.not(count_comment_QMARK_))))?(0):cljs.core.count(s));\nif(cljs.core.truth_((function (){var or__4212__auto__ = (function (){var and__4210__auto__ = eol_QMARK_;\nif(cljs.core.truth_(and__4210__auto__)){\nreturn cljs.core.not((function (){var and__4210__auto____$1 = just_eol_QMARK_;\nif(cljs.core.truth_(and__4210__auto____$1)){\nreturn (count_s === (0));\n} else {\nreturn and__4210__auto____$1;\n}\n})());\n} else {\nreturn and__4210__auto__;\n}\n})();\nif(cljs.core.truth_(or__4212__auto__)){\nreturn or__4212__auto__;\n} else {\nreturn comment_QMARK_;\n}\n})())){\nreturn new cljs.core.PersistentVector(null, 4, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.conj.cljs$core$IFn$_invoke$arity$2(out,(cur_len + count_s)),(0),true,comment_QMARK_], null);\n} else {\nreturn new cljs.core.PersistentVector(null, 4, 5, cljs.core.PersistentVector.EMPTY_NODE, [out,(cur_len + count_s),null,comment_QMARK_], null);\n\n}\n});\nzprint.zprint.generate_ll = (function zprint$zprint$generate_ll(count_comment_QMARK_,p__45354,p__45355){\nvar vec__45356 = p__45354;\nvar out = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45356,(0),null);\nvar cur_len = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45356,(1),null);\nvar just_eol_QMARK_ = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45356,(2),null);\nvar just_comment_QMARK_ = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45356,(3),null);\nvar in$ = vec__45356;\nvar vec__45359 = p__45355;\nvar s = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45359,(0),null);\nvar _ = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45359,(1),null);\nvar tag = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45359,(2),null);\nvar element = vec__45359;\nvar vec__45362 = ((((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(tag,new cljs.core.Keyword(null,\"whitespace\",\"whitespace\",-1340035483))) || (((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(tag,new cljs.core.Keyword(null,\"indent\",\"indent\",-148200125))) || (cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(tag,new cljs.core.Keyword(null,\"newline\",\"newline\",1790071323)))))))?zprint.zprint.split_lf_2(s):(new cljs.core.List(null,s,null,(1),null)));\nvar l = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45362,(0),null);\nvar r = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45362,(1),null);\nvar in$__$1 = zprint.zprint.accumulate_ll(count_comment_QMARK_,in$,l,tag,(!((r == null))));\nvar in$__$2 = ((cljs.core.empty_QMARK_(r))?in$__$1:zprint.zprint.accumulate_ll(count_comment_QMARK_,in$__$1,r,tag,null));\nreturn in$__$2;\n});\n/**\n * Take a style-vec, and output a sequence of numbers, one for each\n *   line, which contains the actual length. Must take the current\n *   indent to have a prayer of getting this right, but it is used\n *   only for the first line.  The ind can be an integer or a seq of\n *   integers, in which case only the first integer is used. Newlines\n *   can come anywhere in an element in a style-vec, it will account\n *   for both sides.  Will break lines on comments even if no newlines\n *   in them.  This doesn't count the length of comment lines unless\n *   [:comment :count?] is true, so that we don't format based on\n *   comment size -- that is handled with the wrap-comments elsewhere.\n *   Note that only vectors with :whitespace, :indent, or :newline are scanned\n *   for newlines, and if consecutive newlines appear, only the first\n *   is counted as a newline -- the second is counted as a regular \n *   character. A single comment is counted as two lines. Lots of edge\n *   conditions that are really quite important.\n */\nzprint.zprint.line_lengths_iter = (function zprint$zprint$line_lengths_iter(options,ind,style_vec){\nvar count_comment_QMARK_ = new cljs.core.Keyword(null,\"count?\",\"count?\",-122202128).cljs$core$IFn$_invoke$arity$1(new cljs.core.Keyword(null,\"comment\",\"comment\",532206069).cljs$core$IFn$_invoke$arity$1(options));\nvar ind__$1 = ((cljs.core.coll_QMARK_(ind))?cljs.core.first(ind):ind);\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options))){\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),cljs.core.pr_str.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\"line-lengths-iter: style-vec:\",style_vec], 0))], 0));\n} else {\n}\n\nvar next_vec = style_vec;\nvar current_string = null;\nvar line_length = ind__$1;\nvar previous_comment_QMARK_ = null;\nvar out = cljs.core.PersistentVector.EMPTY;\nwhile(true){\nif(((cljs.core.empty_QMARK_(next_vec)) && (cljs.core.empty_QMARK_(current_string)))){\nif((((line_length === (0))) && (cljs.core.not(previous_comment_QMARK_)))){\nreturn out;\n} else {\nif(cljs.core.truth_(previous_comment_QMARK_)){\nreturn cljs.core.conj.cljs$core$IFn$_invoke$arity$variadic(out,line_length,cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([(0)], 0));\n} else {\nreturn cljs.core.conj.cljs$core$IFn$_invoke$arity$2(out,line_length);\n\n}\n}\n} else {\nvar advance_QMARK_ = cljs.core.empty_QMARK_(current_string);\nvar vec__45376 = ((advance_QMARK_)?cljs.core.first(next_vec):null);\nvar next_string = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45376,(0),null);\nvar _ = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45376,(1),null);\nvar tag = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45376,(2),null);\nvar comment_QMARK_ = ((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(tag,new cljs.core.Keyword(null,\"comment\",\"comment\",532206069))) || (cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(tag,new cljs.core.Keyword(null,\"comment-inline\",\"comment-inline\",712944405))));\nvar s = ((advance_QMARK_)?next_string:current_string);\nvar vec__45379 = (cljs.core.truth_(s)?((((comment_QMARK_) && (cljs.core.not(count_comment_QMARK_))))?new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [\"\"], null):(cljs.core.truth_((function (){var or__4212__auto__ = ((advance_QMARK_) && (((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(tag,new cljs.core.Keyword(null,\"whitespace\",\"whitespace\",-1340035483))) || (((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(tag,new cljs.core.Keyword(null,\"newline\",\"newline\",1790071323))) || (cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(tag,new cljs.core.Keyword(null,\"indent\",\"indent\",-148200125))))))));\nif(or__4212__auto__){\nreturn or__4212__auto__;\n} else {\nreturn current_string;\n}\n})())?zprint.zprint.split_lf_2(s):new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [s], null)\n)):null);\nvar l = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45379,(0),null);\nvar r = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45379,(1),null);\nvar force_newline_QMARK_ = (function (){var and__4210__auto__ = previous_comment_QMARK_;\nif(cljs.core.truth_(and__4210__auto__)){\nreturn (!(cljs.core.empty_QMARK_(l)));\n} else {\nreturn and__4210__auto__;\n}\n})();\nvar r__$1 = (cljs.core.truth_(force_newline_QMARK_)?[cljs.core.str.cljs$core$IFn$_invoke$arity$1(l),cljs.core.str.cljs$core$IFn$_invoke$arity$1(r)].join(''):r);\nvar l__$1 = (cljs.core.truth_(force_newline_QMARK_)?null:l);\nvar new_line_length = (line_length + cljs.core.count(l__$1));\nvar G__46234 = ((advance_QMARK_)?cljs.core.next(next_vec):next_vec);\nvar G__46235 = r__$1;\nvar G__46236 = (cljs.core.truth_(r__$1)?(0):new_line_length);\nvar G__46237 = comment_QMARK_;\nvar G__46238 = (cljs.core.truth_(r__$1)?cljs.core.conj.cljs$core$IFn$_invoke$arity$2(out,new_line_length):out);\nnext_vec = G__46234;\ncurrent_string = G__46235;\nline_length = G__46236;\nprevious_comment_QMARK_ = G__46237;\nout = G__46238;\ncontinue;\n}\nbreak;\n}\n});\n/**\n * Take a style-vec, and output a sequence of numbers, one for each\n *   line, which contains the actual length. Must take the current\n *   indent to have a prayer of getting this right, but it is used\n *   only for the first line.  The ind can be an integer or a seq of\n *   integers, in which case only the first integer is used. Newlines\n *   can come anywhere in an element in a style-vec, it will account\n *   for both sides.  Will break lines on comments even if no newlines\n *   in them.  This doesn't count the length of comment lines unless\n *   [:comment :count?] is true, so that we don't format based on\n *   comment size -- that is handled with the wrap-comments at the\n *   end. Note that only vectors with :whitespace or :indent are scanned\n *   for newlines, and if consecutive newlines appear, only the first\n *   is counted as a newline -- the second is counted as a regular \n *   character.\n */\nzprint.zprint.line_lengths = (function zprint$zprint$line_lengths(options,ind,style_vec){\nvar length_vec = cljs.core.first((function (){var count_comment_QMARK_ = new cljs.core.Keyword(null,\"count?\",\"count?\",-122202128).cljs$core$IFn$_invoke$arity$1(new cljs.core.Keyword(null,\"comment\",\"comment\",532206069).cljs$core$IFn$_invoke$arity$1(options));\nvar vec__45384 = cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(cljs.core.partial.cljs$core$IFn$_invoke$arity$2(zprint.zprint.generate_ll,count_comment_QMARK_),new cljs.core.PersistentVector(null, 4, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.PersistentVector.EMPTY,((cljs.core.coll_QMARK_(ind))?cljs.core.first(ind):ind),null,null], null),style_vec);\nvar _ = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45384,(0),null);\nvar ___$1 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45384,(1),null);\nvar just_eol_QMARK_ = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45384,(2),null);\nvar just_comment_QMARK_ = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45384,(3),null);\nvar result = vec__45384;\nif(cljs.core.truth_((function (){var and__4210__auto__ = just_eol_QMARK_;\nif(cljs.core.truth_(and__4210__auto__)){\nreturn cljs.core.not(just_comment_QMARK_);\n} else {\nreturn and__4210__auto__;\n}\n})())){\nreturn result;\n} else {\nreturn zprint.zprint.accumulate_ll(count_comment_QMARK_,cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(result,(2),null),\"\",null,true);\n}\n})());\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options))){\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),cljs.core.pr_str.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\"line-lengths: style-vec:\",style_vec,\"ind:\",ind,\"length-vec:\",length_vec], 0))], 0));\n} else {\n}\n\nreturn length_vec;\n});\n/**\n * This looks at a style vec and doesn't do all that style-lines does.\n *   It just looks for a new-line in the strings, and returns true if it\n *   doesn't find one.\n */\nzprint.zprint.single_line_QMARK_ = (function zprint$zprint$single_line_QMARK_(style_vec){\nreturn cljs.core.not(cljs.core.reduce.cljs$core$IFn$_invoke$arity$3((function (p1__45387_SHARP_,p2__45388_SHARP_){\nvar or__4212__auto__ = p1__45387_SHARP_;\nif(cljs.core.truth_(or__4212__auto__)){\nreturn or__4212__auto__;\n} else {\nreturn p2__45388_SHARP_;\n}\n}),false,cljs.core.map.cljs$core$IFn$_invoke$arity$2((function (p1__45389_SHARP_){\nreturn clojure.string.includes_QMARK_(cljs.core.first(p1__45389_SHARP_),\"\\n\");\n}),style_vec)));\n});\n/**\n * Given a style-vec, come up with a string that gives some hint of \n *   where this style-vec came from.\n */\nzprint.zprint.find_what = (function zprint$zprint$find_what(style_vec){\nvar s_vec = style_vec;\nwhile(true){\nif(cljs.core.truth_(s_vec)){\nvar vec__45402 = cljs.core.first(s_vec);\nvar what = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45402,(0),null);\nvar _ = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45402,(1),null);\nvar this$ = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45402,(2),null);\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(this$,new cljs.core.Keyword(null,\"element\",\"element\",1974019749))){\nreturn what;\n} else {\nvar G__46245 = cljs.core.next(s_vec);\ns_vec = G__46245;\ncontinue;\n}\n} else {\nreturn null;\n}\nbreak;\n}\n});\n/**\n * Look at a style vec ready to be given to concat-no-nil, and see if\n *   the first thing in there is a newline of some sort.\n */\nzprint.zprint.first_nl_QMARK_ = (function zprint$zprint$first_nl_QMARK_(style_vec){\nvar vec__45405 = cljs.core.first(style_vec);\nvar s = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45405,(0),null);\nvar color = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45405,(1),null);\nvar what = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45405,(2),null);\nreturn ((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(what,new cljs.core.Keyword(null,\"newline\",\"newline\",1790071323))) || (cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(what,new cljs.core.Keyword(null,\"indent\",\"indent\",-148200125))));\n});\n/**\n * Given an indent ind and a style-vec coll, place a newline (actually an\n *   indent) at the front of coll.  If the first thing in coll is a newline,\n *   then don't add any spaces after the newline that we prepend.\n */\nzprint.zprint.prepend_nl = (function zprint$zprint$prepend_nl(options,ind,coll){\nreturn zprint.zprint.concat_no_nil.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 4, 5, cljs.core.PersistentVector.EMPTY_NODE, [[\"\\n\",cljs.core.str.cljs$core$IFn$_invoke$arity$1(zprint.zprint.blanks(((zprint.zprint.first_nl_QMARK_(coll))?(0):ind)))].join(''),new cljs.core.Keyword(null,\"none\",\"none\",1333468478),new cljs.core.Keyword(null,\"indent\",\"indent\",-148200125),(1)], null)], null),coll], 0));\n});\n/**\n * Take a style output, and tell us how many lines it takes to print it\n *   and the maximum width that it reaches. Returns \n *   [<line-count> <max-width> [line-lengths]].\n *   Doesn't require any max-width inside the style-vec. Also returns the\n *   line lengths in case that is helpful (since we have them anyway).\n *   If (:dbg-ge options) has value, then uses find-what to see if what it\n *   finds matches the value, and if it does, place the value in the\n *   resulting vector.\n */\nzprint.zprint.style_lines = (function zprint$zprint$style_lines(options,ind,style_vec){\nif(cljs.core.truth_((function (){var and__4210__auto__ = style_vec;\nif(cljs.core.truth_(and__4210__auto__)){\nreturn (((!(cljs.core.empty_QMARK_(style_vec)))) && (cljs.core.not(zprint.zprint.contains_nil_QMARK_(style_vec))));\n} else {\nreturn and__4210__auto__;\n}\n})())){\nvar lengths = zprint.zprint.line_lengths_iter(options,ind,style_vec);\nvar count_lengths = cljs.core.count(lengths);\nvar result = new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [count_lengths,(((count_lengths === (0)))?(0):cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core.max,lengths)),lengths], null);\nvar dbg_ge = new cljs.core.Keyword(null,\"dbg-ge\",\"dbg-ge\",257927017).cljs$core$IFn$_invoke$arity$1(options);\nvar what = (cljs.core.truth_((function (){var and__4210__auto__ = dbg_ge;\nif(cljs.core.truth_(and__4210__auto__)){\nreturn cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(zprint.zprint.find_what(style_vec),dbg_ge);\n} else {\nreturn and__4210__auto__;\n}\n})())?dbg_ge:null);\nif(cljs.core.truth_(what)){\nreturn cljs.core.conj.cljs$core$IFn$_invoke$arity$2(result,what);\n} else {\nreturn result;\n}\n} else {\nreturn null;\n}\n});\n/**\n * Given output from style-lines and options, see if it fits the width.  \n *   Return the number of lines it takes if it fits, nil otherwise.\n */\nzprint.zprint.fzfit = (function zprint$zprint$fzfit(p__45408,p__45409){\nvar map__45410 = p__45408;\nvar map__45410__$1 = cljs.core.__destructure_map(map__45410);\nvar options = map__45410__$1;\nvar width = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__45410__$1,new cljs.core.Keyword(null,\"width\",\"width\",-384071477));\nvar rightcnt = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__45410__$1,new cljs.core.Keyword(null,\"rightcnt\",\"rightcnt\",-45750070));\nvar dbg_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__45410__$1,new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771));\nvar vec__45411 = p__45409;\nvar line_count = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45411,(0),null);\nvar max_width = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45411,(1),null);\nvar style_lines_return = vec__45411;\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options))){\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),\"fzfit: fixed-rightcnt:\",(zprint.zprint.fix_rightcnt.cljs$core$IFn$_invoke$arity$1 ? zprint.zprint.fix_rightcnt.cljs$core$IFn$_invoke$arity$1(rightcnt) : zprint.zprint.fix_rightcnt.call(null,rightcnt)),\"line-count:\",line_count,\"max-width:\",max_width,\"width:\",width], 0));\n} else {\n}\n\nif(cljs.core.truth_(style_lines_return)){\nif((max_width <= (width - (zprint.zprint.fix_rightcnt.cljs$core$IFn$_invoke$arity$1 ? zprint.zprint.fix_rightcnt.cljs$core$IFn$_invoke$arity$1(rightcnt) : zprint.zprint.fix_rightcnt.call(null,rightcnt))))){\nreturn line_count;\n} else {\nreturn null;\n}\n} else {\nreturn null;\n}\n});\n/**\n * Given the return from style-lines  and options, \n *   return true if it fits on a single line.\n */\nzprint.zprint.fzfit_one_line = (function zprint$zprint$fzfit_one_line(options,style_lines_return){\nvar lines = zprint.zprint.fzfit(options,style_lines_return);\nreturn ((typeof lines === 'number') && (cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(lines,(1))));\n});\n/**\n * Increase the rightmost count, if any, and return one if not.\n */\nzprint.zprint.rightmost = (function zprint$zprint$rightmost(options){\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(options,new cljs.core.Keyword(null,\"rightcnt\",\"rightcnt\",-45750070),(new cljs.core.Keyword(null,\"rightcnt\",\"rightcnt\",-45750070).cljs$core$IFn$_invoke$arity$2(options,(0)) + (1)));\n});\n/**\n * Remove the rightmost count.\n */\nzprint.zprint.not_rightmost = (function zprint$zprint$not_rightmost(options){\nreturn cljs.core.dissoc.cljs$core$IFn$_invoke$arity$2(options,new cljs.core.Keyword(null,\"rightcnt\",\"rightcnt\",-45750070));\n});\n/**\n * Handle the complexity of commas and rightmost-pair with options.\n *   If it isn't a rightmost, it loses rightmost status.\n *   If it is a rightmost, and in the rightmost pair, it gain one rightmost\n *   since it has the right end thing (and we don't care about the comma).\n *   If it is the rightmost of the non-rightmost-pair, then the comma\n *   matters, and we handle that appropriately.  Whew!\n */\nzprint.zprint.c_r_pair = (function zprint$zprint$c_r_pair(commas_QMARK_,rightmost_pair_QMARK_,rightmost_QMARK_,options){\nif(cljs.core.not(rightmost_QMARK_)){\nreturn zprint.zprint.not_rightmost(options);\n} else {\nif(cljs.core.truth_(rightmost_pair_QMARK_)){\nreturn options;\n} else {\nif(cljs.core.truth_(commas_QMARK_)){\nreturn zprint.zprint.rightmost(zprint.zprint.not_rightmost(options));\n} else {\nreturn zprint.zprint.not_rightmost(options);\n}\n}\n}\n});\n/**\n * Handle issue with rightcnt.\n */\nzprint.zprint.fix_rightcnt = (function zprint$zprint$fix_rightcnt(rightcnt){\nif(typeof rightcnt === 'number'){\nreturn rightcnt;\n} else {\nreturn (0);\n}\n});\nzprint.zprint.str__GT_key = cljs.core.PersistentHashMap.fromArrays([\"]\",\"'\",\")\",\"`\",\"~@\",\"~\",\"#{\",\"(\",\"#(\",\"{\",\"}\",\"[\",\"#_\",\"@\"],[new cljs.core.Keyword(null,\"bracket\",\"bracket\",-600276523),new cljs.core.Keyword(null,\"quote\",\"quote\",-262615245),new cljs.core.Keyword(null,\"paren\",\"paren\",-294107600),new cljs.core.Keyword(null,\"syntax-quote\",\"syntax-quote\",-1233164847),new cljs.core.Keyword(null,\"unquote-splicing\",\"unquote-splicing\",1295267556),new cljs.core.Keyword(null,\"unquote\",\"unquote\",1649741032),new cljs.core.Keyword(null,\"hash-brace\",\"hash-brace\",-1522139685),new cljs.core.Keyword(null,\"paren\",\"paren\",-294107600),new cljs.core.Keyword(null,\"hash-paren\",\"hash-paren\",-1158425562),new cljs.core.Keyword(null,\"brace\",\"brace\",-1705077624),new cljs.core.Keyword(null,\"brace\",\"brace\",-1705077624),new cljs.core.Keyword(null,\"bracket\",\"bracket\",-600276523),new cljs.core.Keyword(null,\"uneval\",\"uneval\",1932037707),new cljs.core.Keyword(null,\"deref\",\"deref\",-145586795)]);\n/**\n * Look up the thing in the zprint-color-map.  Accepts keywords or\n *   strings.\n */\nzprint.zprint.zcolor_map = (function zprint$zprint$zcolor_map(p__45414,key_or_str){\nvar map__45415 = p__45414;\nvar map__45415__$1 = cljs.core.__destructure_map(map__45415);\nvar options = map__45415__$1;\nvar color_map = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__45415__$1,new cljs.core.Keyword(null,\"color-map\",\"color-map\",-207789684));\nvar G__45420 = (((key_or_str instanceof cljs.core.Keyword))?key_or_str:(zprint.zprint.str__GT_key.cljs$core$IFn$_invoke$arity$1 ? zprint.zprint.str__GT_key.cljs$core$IFn$_invoke$arity$1(key_or_str) : zprint.zprint.str__GT_key.call(null,key_or_str)));\nreturn (color_map.cljs$core$IFn$_invoke$arity$1 ? color_map.cljs$core$IFn$_invoke$arity$1(G__45420) : color_map.call(null,G__45420));\n});\n/**\n * Take a style-vec, and if hangflow? is true, return a\n *   vector [hang-or-flow style-vec], else return style-vec.\n *   But a nil style-vec returns nil.\n */\nzprint.zprint.hangflow = (function zprint$zprint$hangflow(hangflow_QMARK_,hang_or_flow,style_vec){\nif(cljs.core.truth_(style_vec)){\nif(cljs.core.truth_(hangflow_QMARK_)){\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [hang_or_flow,style_vec], null);\n} else {\nreturn style_vec;\n}\n} else {\nreturn null;\n}\n});\n/**\n * Try to hang something and if it doesn't hang at all, then flow it,\n *   but strongly prefer hang.  Has hang and flow indents, and fzfn is the\n *   fzprint-? function to use with zloc.  Callers need to know whether this\n *   was hang or flow, so it returns [{:hang | :flow} style-vec] all the time.\n */\nzprint.zprint.fzprint_hang_unless_fail = (function zprint$zprint$fzprint_hang_unless_fail(options,hindent,findent,fzfn,zloc){\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options))){\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),\"fzprint-hang-unless-fail: hindent:\",hindent,\"findent:\",findent,\"zloc:\",(function (){var G__45424 = (zprint.zfns.zfirst.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zfirst.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zfirst.call(null,zloc));\nreturn (zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1(G__45424) : zprint.zfns.zstring.call(null,G__45424));\n})()], 0));\n} else {\n}\n\nvar hanging = ((cljs.core.not_EQ_.cljs$core$IFn$_invoke$arity$2(hindent,findent))?(function (){var G__45428 = zprint.zprint.in_hang(options);\nvar G__45429 = hindent;\nvar G__45430 = zloc;\nreturn (fzfn.cljs$core$IFn$_invoke$arity$3 ? fzfn.cljs$core$IFn$_invoke$arity$3(G__45428,G__45429,G__45430) : fzfn.call(null,G__45428,G__45429,G__45430));\n})():null);\nvar value__45260__auto__ = (cljs.core.truth_((function (){var and__4210__auto__ = hanging;\nif(cljs.core.truth_(and__4210__auto__)){\nreturn zprint.zprint.fzfit(options,zprint.zprint.style_lines(options,hindent,hanging));\n} else {\nreturn and__4210__auto__;\n}\n})())?new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,\"hang\",\"hang\",-1007256173),hanging], null):(function (){\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options))){\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),\"fzprint-hang-unless-fail: hang failed, doing flow\"], 0));\n} else {\n}\n\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,\"flow\",\"flow\",590489032),zprint.zprint.prepend_nl(options,findent,(fzfn.cljs$core$IFn$_invoke$arity$3 ? fzfn.cljs$core$IFn$_invoke$arity$3(options,findent,zloc) : fzfn.call(null,options,findent,zloc)))], null);\n})()\n);\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options))){\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),\"fzprint-hang-unless-fail: exit:\",cljs.core.pr_str.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([value__45260__auto__], 0))], 0));\n} else {\n}\n\nreturn value__45260__auto__;\n});\n/**\n * Given a style-vec with exactly one thing in it, replace the color\n *   with whatever local color we have determined is correct.\n */\nzprint.zprint.replace_color = (function zprint$zprint$replace_color(local_color,style_vec){\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(cljs.core.count(style_vec),(1))){\nvar vec__45441 = style_vec;\nvar vec__45444 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45441,(0),null);\nvar string = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45444,(0),null);\nvar color = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45444,(1),null);\nvar element = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45444,(2),null);\nreturn new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [string,local_color,element], null)], null);\n} else {\nreturn style_vec;\n}\n});\n/**\n * This routine tries to figure out if existing hang should be used without\n *   even bothering to do a flow and compare them with good-enough?.\n */\nzprint.zprint.use_hang_QMARK_ = (function zprint$zprint$use_hang_QMARK_(caller,p__45447,ind,hang_count,hanging_line_count){\nvar map__45448 = p__45447;\nvar map__45448__$1 = cljs.core.__destructure_map(map__45448);\nvar options = map__45448__$1;\nvar map__45449 = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__45448__$1,caller);\nvar map__45449__$1 = cljs.core.__destructure_map(map__45449);\nvar hang_accept = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__45449__$1,new cljs.core.Keyword(null,\"hang-accept\",\"hang-accept\",2078386607));\nvar ha_depth_factor = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__45449__$1,new cljs.core.Keyword(null,\"ha-depth-factor\",\"ha-depth-factor\",534448962));\nvar ha_width_factor = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__45449__$1,new cljs.core.Keyword(null,\"ha-width-factor\",\"ha-width-factor\",1818280581));\nvar depth = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__45448__$1,new cljs.core.Keyword(null,\"depth\",\"depth\",1768663640));\nvar width = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__45448__$1,new cljs.core.Keyword(null,\"width\",\"width\",-384071477));\nif(cljs.core.truth_((function (){var and__4210__auto__ = hanging_line_count;\nif(cljs.core.truth_(and__4210__auto__)){\nvar and__4210__auto____$1 = hang_accept;\nif(cljs.core.truth_(and__4210__auto____$1)){\nreturn (hang_count > (0));\n} else {\nreturn and__4210__auto____$1;\n}\n} else {\nreturn and__4210__auto__;\n}\n})())){\nvar hang_accept__$1 = ((hang_accept + (depth * ha_depth_factor)) + ((ind / width) * ha_width_factor));\nreturn (((hanging_line_count - (1)) / hang_count) <= hang_accept__$1);\n} else {\nreturn null;\n}\n});\n/**\n * Print a single pair of things (though it might not be exactly a\n *   pair, given comments and :extend and the like), like bindings in\n *   a let, clauses in a cond, keys and values in a map.  Controlled\n *   by various maps, the key of which is caller.  Returns \n *   [:hang <style-vec>] or [:flow <style-vec>] so that the upstream folks\n *   know whether this was a hang or flow and can do the right thing\n *   based on that.\n */\nzprint.zprint.fzprint_two_up = (function zprint$zprint$fzprint_two_up(caller,p__45457,ind,commas_QMARK_,justify_width,rightmost_pair_QMARK_,p__45458){\nvar map__45460 = p__45457;\nvar map__45460__$1 = cljs.core.__destructure_map(map__45460);\nvar options = map__45460__$1;\nvar map__45461 = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__45460__$1,caller);\nvar map__45461__$1 = cljs.core.__destructure_map(map__45461);\nvar hang_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__45461__$1,new cljs.core.Keyword(null,\"hang?\",\"hang?\",-579442854));\nvar flow_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__45461__$1,new cljs.core.Keyword(null,\"flow?\",\"flow?\",96929057));\nvar indent_arg = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__45461__$1,new cljs.core.Keyword(null,\"indent-arg\",\"indent-arg\",58691874));\nvar key_depth_color = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__45461__$1,new cljs.core.Keyword(null,\"key-depth-color\",\"key-depth-color\",1448522819));\nvar indent = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__45461__$1,new cljs.core.Keyword(null,\"indent\",\"indent\",-148200125));\nvar key_value_color = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__45461__$1,new cljs.core.Keyword(null,\"key-value-color\",\"key-value-color\",676042889));\nvar dbg_cnt_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__45461__$1,new cljs.core.Keyword(null,\"dbg-cnt?\",\"dbg-cnt?\",-1638028976));\nvar dbg_local_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__45461__$1,new cljs.core.Keyword(null,\"dbg-local?\",\"dbg-local?\",-895545325));\nvar key_color = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__45461__$1,new cljs.core.Keyword(null,\"key-color\",\"key-color\",-209002572));\nvar one_line_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__45460__$1,new cljs.core.Keyword(null,\"one-line?\",\"one-line?\",2055953111));\nvar dbg_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__45460__$1,new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771));\nvar dbg_indent = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__45460__$1,new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778));\nvar in_hang_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__45460__$1,new cljs.core.Keyword(null,\"in-hang?\",\"in-hang?\",-1065695639));\nvar do_in_hang_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__45460__$1,new cljs.core.Keyword(null,\"do-in-hang?\",\"do-in-hang?\",-1235364947));\nvar map_depth = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__45460__$1,new cljs.core.Keyword(null,\"map-depth\",\"map-depth\",-191378641));\nvar vec__45462 = p__45458;\nvar lloc = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45462,(0),null);\nvar rloc = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45462,(1),null);\nvar xloc = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45462,(2),null);\nvar pair = vec__45462;\nif(cljs.core.truth_(dbg_cnt_QMARK_)){\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\"two-up: caller:\",caller,\"hang?\",hang_QMARK_,\"dbg?\",dbg_QMARK_], 0));\n} else {\n}\n\nif(cljs.core.truth_((function (){var or__4212__auto__ = dbg_QMARK_;\nif(cljs.core.truth_(or__4212__auto__)){\nreturn or__4212__auto__;\n} else {\nreturn dbg_local_QMARK_;\n}\n})())){\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([(function (){var or__4212__auto__ = dbg_indent;\nif(cljs.core.truth_(or__4212__auto__)){\nreturn or__4212__auto__;\n} else {\nreturn \"\";\n}\n})(),\"==========================\",[\"\\n\",cljs.core.str.cljs$core$IFn$_invoke$arity$1((function (){var or__4212__auto__ = dbg_indent;\nif(cljs.core.truth_(or__4212__auto__)){\nreturn or__4212__auto__;\n} else {\nreturn \"\";\n}\n})())].join(''),cljs.core.pr_str.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\"fzprint-two-up:\",(zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1(lloc) : zprint.zfns.zstring.call(null,lloc)),\"tag:\",(zprint.zfns.ztag.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.ztag.cljs$core$IFn$_invoke$arity$1(lloc) : zprint.zfns.ztag.call(null,lloc)),\"caller:\",caller,\"count:\",cljs.core.count(pair),\"ind:\",ind,\"indent:\",indent,\"indent-arg:\",indent_arg,\"justify-width:\",justify_width,\"one-line?:\",one_line_QMARK_,\"hang?:\",hang_QMARK_,\"in-hang?\",in_hang_QMARK_,\"do-in-hang?\",do_in_hang_QMARK_,\"flow?\",flow_QMARK_,\"commas?\",commas_QMARK_,\"rightmost-pair?\",rightmost_pair_QMARK_], 0))], 0));\n} else {\n}\n\nvar local_hang_QMARK_ = (function (){var or__4212__auto__ = one_line_QMARK_;\nif(cljs.core.truth_(or__4212__auto__)){\nreturn or__4212__auto__;\n} else {\nreturn hang_QMARK_;\n}\n})();\nvar indent__$1 = (function (){var or__4212__auto__ = indent;\nif(cljs.core.truth_(or__4212__auto__)){\nreturn or__4212__auto__;\n} else {\nreturn indent_arg;\n}\n})();\nvar local_options = ((cljs.core.not(local_hang_QMARK_))?cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(options,new cljs.core.Keyword(null,\"one-line?\",\"one-line?\",2055953111),true):options);\nvar loptions = zprint.zprint.c_r_pair(commas_QMARK_,rightmost_pair_QMARK_,null,options);\nvar roptions = zprint.zprint.c_r_pair(commas_QMARK_,rightmost_pair_QMARK_,new cljs.core.Keyword(null,\"rightmost\",\"rightmost\",800279518),options);\nvar local_roptions = zprint.zprint.c_r_pair(commas_QMARK_,rightmost_pair_QMARK_,new cljs.core.Keyword(null,\"rightmost\",\"rightmost\",800279518),local_options);\nvar value_color_map = (function (){var and__4210__auto__ = key_value_color;\nif(cljs.core.truth_(and__4210__auto__)){\nvar G__45471 = (zprint.zfns.zsexpr.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zsexpr.cljs$core$IFn$_invoke$arity$1(lloc) : zprint.zfns.zsexpr.call(null,lloc));\nreturn (key_value_color.cljs$core$IFn$_invoke$arity$1 ? key_value_color.cljs$core$IFn$_invoke$arity$1(G__45471) : key_value_color.call(null,G__45471));\n} else {\nreturn and__4210__auto__;\n}\n})();\nvar local_roptions__$1 = (cljs.core.truth_(value_color_map)?zprint.config.merge_deep.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([local_roptions,new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"color-map\",\"color-map\",-207789684),value_color_map], null)], 0)):local_roptions);\nvar roptions__$1 = (cljs.core.truth_(value_color_map)?zprint.config.merge_deep.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([roptions,new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"color-map\",\"color-map\",-207789684),value_color_map], null)], 0)):roptions);\nvar modifier_set = new cljs.core.Keyword(null,\"modifiers\",\"modifiers\",50378834).cljs$core$IFn$_invoke$arity$1((options.cljs$core$IFn$_invoke$arity$1 ? options.cljs$core$IFn$_invoke$arity$1(caller) : options.call(null,caller)));\nvar modifier_QMARK_ = (function (){var or__4212__auto__ = (function (){var and__4210__auto__ = modifier_set;\nif(cljs.core.truth_(and__4210__auto__)){\nvar and__4210__auto____$1 = (function (){var G__45472 = (zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1(lloc) : zprint.zfns.zstring.call(null,lloc));\nreturn (modifier_set.cljs$core$IFn$_invoke$arity$1 ? modifier_set.cljs$core$IFn$_invoke$arity$1(G__45472) : modifier_set.call(null,G__45472));\n})();\nif(cljs.core.truth_(and__4210__auto____$1)){\nreturn (cljs.core.count(pair) > (2));\n} else {\nreturn and__4210__auto____$1;\n}\n} else {\nreturn and__4210__auto__;\n}\n})();\nif(cljs.core.truth_(or__4212__auto__)){\nreturn or__4212__auto__;\n} else {\nreturn (zprint.zprint.middle_element_QMARK_.cljs$core$IFn$_invoke$arity$2 ? zprint.zprint.middle_element_QMARK_.cljs$core$IFn$_invoke$arity$2(options,rloc) : zprint.zprint.middle_element_QMARK_.call(null,options,rloc));\n}\n})();\nvar local_color = cljs.core.get.cljs$core$IFn$_invoke$arity$2(key_depth_color,(map_depth - (1)));\nvar local_color__$1 = (cljs.core.truth_(key_color)?(function (){var G__45473 = (zprint.zfns.zsexpr.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zsexpr.cljs$core$IFn$_invoke$arity$1(lloc) : zprint.zfns.zsexpr.call(null,lloc));\nreturn (key_color.cljs$core$IFn$_invoke$arity$1 ? key_color.cljs$core$IFn$_invoke$arity$1(G__45473) : key_color.call(null,G__45473));\n})():local_color);\nvar arg_1 = (zprint.zprint.fzprint_STAR_.cljs$core$IFn$_invoke$arity$3 ? zprint.zprint.fzprint_STAR_.cljs$core$IFn$_invoke$arity$3(loptions,ind,lloc) : zprint.zprint.fzprint_STAR_.call(null,loptions,ind,lloc));\nvar arg_1_newline_QMARK_ = (function (){var and__4210__auto__ = cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(cljs.core.count(pair),(1));\nif(and__4210__auto__){\nreturn (zprint.zfns.znewline_QMARK_.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.znewline_QMARK_.cljs$core$IFn$_invoke$arity$1(lloc) : zprint.zfns.znewline_QMARK_.call(null,lloc));\n} else {\nreturn and__4210__auto__;\n}\n})();\nvar arg_1__$1 = (cljs.core.truth_(local_color__$1)?zprint.zprint.replace_color(local_color__$1,arg_1):arg_1);\nvar vec__45465 = zprint.zprint.style_lines(options,ind,arg_1__$1);\nvar arg_1_line_count = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45465,(0),null);\nvar arg_1_max_width = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45465,(1),null);\nvar arg_1_lines = vec__45465;\nvar _ = (cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options))?cljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),\"fzprint-two-up before modifier: arg-1-line-count:\",arg_1_line_count,\"arg-1-max-width:\",arg_1_max_width], 0)):null);\nvar modifier_QMARK___$1 = (cljs.core.truth_((function (){var or__4212__auto__ = (function (){var and__4210__auto__ = arg_1_line_count;\nif(cljs.core.truth_(and__4210__auto__)){\nreturn (arg_1_line_count > (1));\n} else {\nreturn and__4210__auto__;\n}\n})();\nif(cljs.core.truth_(or__4212__auto__)){\nreturn or__4212__auto__;\n} else {\nreturn arg_1_newline_QMARK_;\n}\n})())?null:modifier_QMARK_);\nvar combined_arg_1 = (cljs.core.truth_(modifier_QMARK___$1)?zprint.zprint.concat_no_nil.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([arg_1__$1,new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 4, 5, cljs.core.PersistentVector.EMPTY_NODE, [\" \",new cljs.core.Keyword(null,\"none\",\"none\",1333468478),new cljs.core.Keyword(null,\"whitespace\",\"whitespace\",-1340035483),(1)], null)], null),(function (){var G__45474 = zprint.zprint.in_hang(loptions);\nvar G__45475 = (ind + arg_1_max_width);\nvar G__45476 = rloc;\nreturn (zprint.zprint.fzprint_STAR_.cljs$core$IFn$_invoke$arity$3 ? zprint.zprint.fzprint_STAR_.cljs$core$IFn$_invoke$arity$3(G__45474,G__45475,G__45476) : zprint.zprint.fzprint_STAR_.call(null,G__45474,G__45475,G__45476));\n})()], 0)):arg_1__$1);\nvar arg_1__$2 = (cljs.core.truth_(combined_arg_1)?combined_arg_1:arg_1__$1);\nvar modifier_QMARK___$2 = (cljs.core.truth_(combined_arg_1)?modifier_QMARK___$1:null);\nvar vec__45468 = (cljs.core.truth_(combined_arg_1)?zprint.zprint.style_lines(options,ind,arg_1__$2):arg_1_lines);\nvar arg_1_line_count__$1 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45468,(0),null);\nvar arg_1_max_width__$1 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45468,(1),null);\nvar arg_1_lines__$1 = vec__45468;\nvar ___$1 = (cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options))?cljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),\"fzprint-two-up after modifier: arg-1-line-count:\",arg_1_line_count__$1,\"arg-1-max-width:\",arg_1_max_width__$1], 0)):null);\nvar lloc__$1 = (cljs.core.truth_(modifier_QMARK___$2)?rloc:lloc);\nvar rloc__$1 = (cljs.core.truth_(modifier_QMARK___$2)?xloc:rloc);\nvar arg_1_fit_oneline_QMARK_ = ((cljs.core.not(flow_QMARK_)) && (zprint.zprint.fzfit_one_line(loptions,arg_1_lines__$1)));\nvar arg_1_fit_QMARK_ = (function (){var or__4212__auto__ = arg_1_fit_oneline_QMARK_;\nif(or__4212__auto__){\nreturn or__4212__auto__;\n} else {\nif(cljs.core.not(one_line_QMARK_)){\nreturn zprint.zprint.fzfit(loptions,arg_1_lines__$1);\n} else {\nreturn null;\n}\n}\n})();\nvar arg_1_width = ((function (){var or__4212__auto__ = arg_1_max_width__$1;\nif(cljs.core.truth_(or__4212__auto__)){\nreturn or__4212__auto__;\n} else {\nreturn (0);\n}\n})() - ind);\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options))){\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),cljs.core.pr_str.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\"fzprint-two-up: arg-1:\",arg_1__$2], 0))], 0));\n} else {\n}\n\nif(cljs.core.truth_((function (){var and__4210__auto__ = arg_1__$2;\nif(cljs.core.truth_(and__4210__auto__)){\nvar or__4212__auto__ = arg_1_fit_QMARK_;\nif(cljs.core.truth_(or__4212__auto__)){\nreturn or__4212__auto__;\n} else {\nreturn cljs.core.not(in_hang_QMARK_);\n}\n} else {\nreturn and__4210__auto__;\n}\n})())){\nif(cljs.core.truth_(arg_1_newline_QMARK_)){\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,\"flow\",\"flow\",590489032),arg_1__$2], null);\n} else {\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(cljs.core.count(pair),(1))){\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,\"hang\",\"hang\",-1007256173),(zprint.zprint.fzprint_STAR_.cljs$core$IFn$_invoke$arity$3 ? zprint.zprint.fzprint_STAR_.cljs$core$IFn$_invoke$arity$3(roptions__$1,ind,lloc__$1) : zprint.zprint.fzprint_STAR_.call(null,roptions__$1,ind,lloc__$1))], null);\n} else {\nif(cljs.core.truth_((function (){var or__4212__auto__ = cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(cljs.core.count(pair),(2));\nif(or__4212__auto__){\nreturn or__4212__auto__;\n} else {\nvar and__4210__auto__ = modifier_QMARK___$2;\nif(cljs.core.truth_(and__4210__auto__)){\nreturn cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(cljs.core.count(pair),(3));\n} else {\nreturn and__4210__auto__;\n}\n}\n})())){\nvar hanging_width = (cljs.core.truth_(justify_width)?justify_width:arg_1_width);\nvar hanging_spaces = (cljs.core.truth_(justify_width)?((justify_width - arg_1_width) + (1)):(1));\nvar hanging_indent = (((1) + hanging_width) + ind);\nvar flow_indent = (indent__$1 + ind);\nif(cljs.core.truth_((function (){var and__4210__auto__ = (zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1(lloc__$1) : zprint.zfns.zstring.call(null,lloc__$1));\nif(cljs.core.truth_(and__4210__auto__)){\nvar and__4210__auto____$1 = zprint.zprint.keyword_fn_QMARK_(options,(zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1(lloc__$1) : zprint.zfns.zstring.call(null,lloc__$1)));\nif(cljs.core.truth_(and__4210__auto____$1)){\nreturn (zprint.zfns.zvector_QMARK_.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zvector_QMARK_.cljs$core$IFn$_invoke$arity$1(rloc__$1) : zprint.zfns.zvector_QMARK_.call(null,rloc__$1));\n} else {\nreturn and__4210__auto____$1;\n}\n} else {\nreturn and__4210__auto__;\n}\n})())){\nvar vec__45480 = zprint.zprint.fzprint_hang_unless_fail(loptions,hanging_indent,flow_indent,zprint.zprint.fzprint_binding_vec,rloc__$1);\nvar hang_or_flow = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45480,(0),null);\nvar style_vec = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45480,(1),null);\nvar arg_1__$3 = ((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(hang_or_flow,new cljs.core.Keyword(null,\"hang\",\"hang\",-1007256173)))?zprint.zprint.concat_no_nil.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([arg_1__$2,new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 4, 5, cljs.core.PersistentVector.EMPTY_NODE, [zprint.zprint.blanks(hanging_spaces),new cljs.core.Keyword(null,\"none\",\"none\",1333468478),new cljs.core.Keyword(null,\"whitespace\",\"whitespace\",-1340035483),(2)], null)], null)], 0)):arg_1__$2);\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [hang_or_flow,zprint.zprint.concat_no_nil.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([arg_1__$3,style_vec], 0))], null);\n} else {\nvar ___$2 = (cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options))?cljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),\"fzprint-two-up: before hang.  hanging tried?\",((arg_1_fit_oneline_QMARK_) || (((cljs.core.not(flow_QMARK_)) && ((flow_indent >= hanging_indent)))))], 0)):null);\nvar hanging = ((((arg_1_fit_oneline_QMARK_) || (((cljs.core.not(flow_QMARK_)) && ((flow_indent >= hanging_indent))))))?(function (){var G__45483 = (((flow_indent < hanging_indent))?zprint.zprint.in_hang(local_roptions__$1):local_roptions__$1);\nvar G__45484 = hanging_indent;\nvar G__45485 = rloc__$1;\nreturn (zprint.zprint.fzprint_STAR_.cljs$core$IFn$_invoke$arity$3 ? zprint.zprint.fzprint_STAR_.cljs$core$IFn$_invoke$arity$3(G__45483,G__45484,G__45485) : zprint.zprint.fzprint_STAR_.call(null,G__45483,G__45484,G__45485));\n})():null);\nvar hang_count = (zprint.zfns.zcount.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zcount.cljs$core$IFn$_invoke$arity$1(rloc__$1) : zprint.zfns.zcount.call(null,rloc__$1));\nvar ___$3 = zprint.zprint.log_lines(options,\"fzprint-two-up: hanging:\",hanging_indent,hanging);\nvar hanging_lines = zprint.zprint.style_lines(options,hanging_indent,hanging);\nvar fit_QMARK_ = zprint.zprint.fzfit_one_line(local_roptions__$1,hanging_lines);\nvar hanging_lines__$1 = ((fit_QMARK_)?hanging_lines:(cljs.core.truth_((function (){var and__4210__auto__ = cljs.core.not(one_line_QMARK_);\nif(and__4210__auto__){\nreturn hang_QMARK_;\n} else {\nreturn and__4210__auto__;\n}\n})())?hanging_lines:null));\nvar hanging_line_count = cljs.core.first(hanging_lines__$1);\nvar ___$4 = (cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options))?cljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),\"fzprint-two-up: fit?\",fit_QMARK_,\"hanging-lines:\",hanging_lines__$1], 0)):null);\nvar ___$5 = zprint.zprint.log_lines(options,\"fzprint-two-up: hanging-2:\",hanging_indent,hanging);\nvar flow_it_QMARK_ = ((cljs.core.not(hanging_lines__$1)) || (((((((cljs.core.not(hanging_lines__$1)) && (cljs.core.not(one_line_QMARK_)))) || (cljs.core.not((function (){var or__4212__auto____$2 = fit_QMARK_;\nif(or__4212__auto____$2){\nreturn or__4212__auto____$2;\n} else {\nreturn one_line_QMARK_;\n}\n})())))) && ((((flow_indent < hanging_indent)) || (cljs.core.not(hanging_lines__$1)))))));\nvar flow_it_QMARK___$1 = (cljs.core.truth_(zprint.zprint.use_hang_QMARK_(caller,options,ind,hang_count,hanging_line_count))?false:flow_it_QMARK_);\nvar ___$6 = (cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options))?cljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),\"fzprint-two-up: before flow. flow-it?\",flow_it_QMARK___$1], 0)):null);\nvar flow = ((flow_it_QMARK___$1)?(zprint.zprint.fzprint_STAR_.cljs$core$IFn$_invoke$arity$3 ? zprint.zprint.fzprint_STAR_.cljs$core$IFn$_invoke$arity$3(roptions__$1,flow_indent,rloc__$1) : zprint.zprint.fzprint_STAR_.call(null,roptions__$1,flow_indent,rloc__$1)):null);\nvar ___$7 = zprint.zprint.log_lines(options,\"fzprint-two-up: flow:\",(indent__$1 + ind),flow);\nvar flow_lines = zprint.zprint.style_lines(options,(indent__$1 + ind),flow);\nif(cljs.core.truth_(dbg_local_QMARK_)){\ncljs.core.prn.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\"fzprint-two-up: local-hang:\",local_hang_QMARK_], 0));\n\ncljs.core.prn.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\"fzprint-two-up: one-line?:\",one_line_QMARK_], 0));\n\ncljs.core.prn.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\"fzprint-two-up: hanging-indent:\",hanging_indent], 0));\n\ncljs.core.prn.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\"fzprint-two-up: hanging-lines:\",hanging_lines__$1], 0));\n\ncljs.core.prn.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\"fzprint-two-up: flow?:\",flow_QMARK_], 0));\n\ncljs.core.prn.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\"fzprint-two-up: flow-it?:\",flow_it_QMARK___$1], 0));\n\ncljs.core.prn.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\"fzprint-two-up: fit?:\",fit_QMARK_], 0));\n\ncljs.core.prn.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\"fzprint-two-up: flow-indent:\",flow_indent], 0));\n\ncljs.core.prn.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\"fzprint-two-up: hanging:\",(zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1(lloc__$1) : zprint.zfns.zstring.call(null,lloc__$1)),hanging], 0));\n\ncljs.core.prn.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\"fzprint-two-up: (+ indent ind):\",(indent__$1 + ind)], 0));\n\ncljs.core.prn.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\"fzprint-two-up: flow:\",(zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1(lloc__$1) : zprint.zfns.zstring.call(null,lloc__$1)),flow], 0));\n} else {\n}\n\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options))){\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),\"fzprint-two-up: before good-enough\"], 0));\n} else {\n}\n\nif(fit_QMARK_){\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,\"hang\",\"hang\",-1007256173),zprint.zprint.concat_no_nil.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([arg_1__$2,new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 4, 5, cljs.core.PersistentVector.EMPTY_NODE, [zprint.zprint.blanks(hanging_spaces),new cljs.core.Keyword(null,\"none\",\"none\",1333468478),new cljs.core.Keyword(null,\"whitespace\",\"whitespace\",-1340035483),(3)], null)], null),hanging], 0))], null);\n} else {\nif(cljs.core.truth_((function (){var or__4212__auto__ = hanging_lines__$1;\nif(cljs.core.truth_(or__4212__auto__)){\nreturn or__4212__auto__;\n} else {\nreturn flow_lines;\n}\n})())){\nif(cljs.core.truth_(zprint.zprint.good_enough_QMARK_(caller,roptions__$1,new cljs.core.Keyword(null,\"none-two-up\",\"none-two-up\",-457831686),hang_count,(hanging_indent - flow_indent),hanging_lines__$1,flow_lines))){\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,\"hang\",\"hang\",-1007256173),zprint.zprint.concat_no_nil.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([arg_1__$2,new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 4, 5, cljs.core.PersistentVector.EMPTY_NODE, [zprint.zprint.blanks(hanging_spaces),new cljs.core.Keyword(null,\"none\",\"none\",1333468478),new cljs.core.Keyword(null,\"whitespace\",\"whitespace\",-1340035483),(4)], null)], null),hanging], 0))], null);\n} else {\nif(cljs.core.truth_(justify_width)){\nreturn null;\n} else {\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,\"flow\",\"flow\",590489032),zprint.zprint.concat_no_nil.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([arg_1__$2,zprint.zprint.prepend_nl(options,(indent__$1 + ind),flow)], 0))], null);\n}\n}\n} else {\nreturn null;\n}\n}\n}\n} else {\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,\"flow\",\"flow\",590489032),zprint.zprint.concat_no_nil.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([arg_1__$2,(function (){var G__45486 = options;\nvar G__45487 = (indent__$1 + ind);\nvar G__45488 = (cljs.core.truth_(modifier_QMARK___$2)?cljs.core.nnext(pair):cljs.core.next(pair));\nvar G__45489 = new cljs.core.Keyword(null,\"force-nl\",\"force-nl\",-755040826);\nvar G__45490 = new cljs.core.Keyword(null,\"newline-first\",\"newline-first\",-638470720);\nreturn (zprint.zprint.fzprint_flow_seq.cljs$core$IFn$_invoke$arity$5 ? zprint.zprint.fzprint_flow_seq.cljs$core$IFn$_invoke$arity$5(G__45486,G__45487,G__45488,G__45489,G__45490) : zprint.zprint.fzprint_flow_seq.call(null,G__45486,G__45487,G__45488,G__45489,G__45490));\n})()], 0))], null);\n\n}\n}\n}\n} else {\nreturn null;\n}\n});\n/**\n * Figure the width for a justification of a set of pairs in coll.  \n *   Also, decide if it makes any sense to justify the pairs at all.\n *   For instance, they all need to be one-line.\n */\nzprint.zprint.fzprint_justify_width = (function zprint$zprint$fzprint_justify_width(caller,p__45499,ind,coll){\nvar map__45500 = p__45499;\nvar map__45500__$1 = cljs.core.__destructure_map(map__45500);\nvar options = map__45500__$1;\nvar map__45501 = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__45500__$1,caller);\nvar map__45501__$1 = cljs.core.__destructure_map(map__45501);\nvar justify_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__45501__$1,new cljs.core.Keyword(null,\"justify?\",\"justify?\",294994148));\nvar firsts = cljs.core.remove.cljs$core$IFn$_invoke$arity$2(cljs.core.nil_QMARK_,cljs.core.map.cljs$core$IFn$_invoke$arity$2((function (p1__45491_SHARP_){\nif((cljs.core.count(p1__45491_SHARP_) > (1))){\nvar G__45502 = options;\nvar G__45503 = ind;\nvar G__45504 = cljs.core.first(p1__45491_SHARP_);\nreturn (zprint.zprint.fzprint_STAR_.cljs$core$IFn$_invoke$arity$3 ? zprint.zprint.fzprint_STAR_.cljs$core$IFn$_invoke$arity$3(G__45502,G__45503,G__45504) : zprint.zprint.fzprint_STAR_.call(null,G__45502,G__45503,G__45504));\n} else {\nreturn null;\n}\n}),coll));\nvar style_seq = cljs.core.map.cljs$core$IFn$_invoke$arity$2(cljs.core.partial.cljs$core$IFn$_invoke$arity$3(zprint.zprint.style_lines,options,ind),firsts);\nvar each_one_line_QMARK_ = cljs.core.reduce.cljs$core$IFn$_invoke$arity$3((function (p1__45492_SHARP_,p2__45493_SHARP_){\nif(cljs.core.truth_(p1__45492_SHARP_)){\nreturn cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(cljs.core.first(p2__45493_SHARP_),(1));\n} else {\nreturn null;\n}\n}),true,style_seq);\nvar justify_width = (cljs.core.truth_(each_one_line_QMARK_)?cljs.core.reduce.cljs$core$IFn$_invoke$arity$3((function (p1__45494_SHARP_,p2__45495_SHARP_){\nvar x__4295__auto__ = p1__45494_SHARP_;\nvar y__4296__auto__ = cljs.core.second(p2__45495_SHARP_);\nreturn ((x__4295__auto__ > y__4296__auto__) ? x__4295__auto__ : y__4296__auto__);\n}),(0),style_seq):null);\nif(cljs.core.truth_(justify_width)){\nreturn (justify_width - ind);\n} else {\nreturn null;\n}\n});\n/**\n * Take a size and a collection of vectors with two or more elements\n *   per vector.  The elements are zlocs, the vectors are not.  Return\n *   the remaining character count or nil if it for sure doesn't fit.\n *   In order to be sure it doesn't fit, this version doesn't assume\n *   *any* separators, so it really underestimates the size.\n */\nzprint.zprint.fit_within_QMARK_ = (function zprint$zprint$fit_within_QMARK_(var_args){\nvar G__45506 = arguments.length;\nswitch (G__45506) {\ncase 3:\nreturn zprint.zprint.fit_within_QMARK_.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase 2:\nreturn zprint.zprint.fit_within_QMARK_.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\n(zprint.zprint.fit_within_QMARK_.cljs$core$IFn$_invoke$arity$3 = (function (size,coll,depth){\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3((function (size__$1,element){\nvar or__4212__auto__ = ((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(depth,(0)))?zprint.zprint.fit_within_QMARK_.cljs$core$IFn$_invoke$arity$3(size__$1,element,(depth + (1))):(function (){var remaining = (size__$1 - cljs.core.count((zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1(element) : zprint.zfns.zstring.call(null,element))));\nif((remaining > (0))){\nreturn remaining;\n} else {\nreturn null;\n}\n})());\nif(cljs.core.truth_(or__4212__auto__)){\nreturn or__4212__auto__;\n} else {\nreturn cljs.core.reduced(null);\n}\n}),size,coll);\n}));\n\n(zprint.zprint.fit_within_QMARK_.cljs$core$IFn$_invoke$arity$2 = (function (size,coll){\nreturn zprint.zprint.fit_within_QMARK_.cljs$core$IFn$_invoke$arity$3(size,coll,(0));\n}));\n\n(zprint.zprint.fit_within_QMARK_.cljs$lang$maxFixedArity = 3);\n\n/**\n * Convert a hangflow style-vec to a regular style-vec.\n */\nzprint.zprint.remove_hangflow = (function zprint$zprint$remove_hangflow(hf_style_vec){\nif(cljs.core.truth_(hf_style_vec)){\nreturn cljs.core.map.cljs$core$IFn$_invoke$arity$2(cljs.core.second,hf_style_vec);\n} else {\nreturn null;\n}\n});\n/**\n * Accept a sequence of pairs, and map fzprint-two-up across those pairs.\n *   If you have :one-line? set, this will return nil if it is way over,\n *   but it can't accurately tell exactly what will fit on one line, since\n *   it doesn't know the separators and such.  So, :one-line? true is a\n *   performance optimization, so it doesn't do a whole huge map just to\n *   find out that it could not possibly have fit on one line.  So, this\n *   returns a sequence of style-vecs, where the indentation for the\n *   stuff inside of the pairs is already there, but the separators of\n *   the style-vecs (including indentation and commas) is done by the\n *   caller of fzprint-map-two-up. Always returns a sequence of vector pairs:\n *   [[:hang <style-vec-for-one-pair>] [:flow <style-vec-for-one-pair>] ...].\n *   If you want a style vec instead, call remove-hangflow on the return \n *   from fzprint-map-two-up.  This will use one-line?, but not check to see\n *   that it actually fits.  If you care about that, then you should check the\n *   return yourself.  It will, however, make an estimate of whether or not\n *   it will fit and if it clearly doesn't, it will return a nil.\n */\nzprint.zprint.fzprint_map_two_up = (function zprint$zprint$fzprint_map_two_up(caller,p__45518,ind,commas_QMARK_,coll){\nvar map__45519 = p__45518;\nvar map__45519__$1 = cljs.core.__destructure_map(map__45519);\nvar options = map__45519__$1;\nvar map__45520 = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__45519__$1,caller);\nvar map__45520__$1 = cljs.core.__destructure_map(map__45520);\nvar justify_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__45520__$1,new cljs.core.Keyword(null,\"justify?\",\"justify?\",294994148));\nvar force_nl_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__45520__$1,new cljs.core.Keyword(null,\"force-nl?\",\"force-nl?\",-1299761462));\nvar width = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__45519__$1,new cljs.core.Keyword(null,\"width\",\"width\",-384071477));\nvar rightcnt = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__45519__$1,new cljs.core.Keyword(null,\"rightcnt\",\"rightcnt\",-45750070));\nvar one_line_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__45519__$1,new cljs.core.Keyword(null,\"one-line?\",\"one-line?\",2055953111));\nvar parallel_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__45519__$1,new cljs.core.Keyword(null,\"parallel?\",\"parallel?\",-25273892));\nvar caller_map = (caller.cljs$core$IFn$_invoke$arity$1 ? caller.cljs$core$IFn$_invoke$arity$1(options) : caller.call(null,options));\nvar len = cljs.core.count(coll);\nvar justify_width = (cljs.core.truth_((function (){var and__4210__auto__ = justify_QMARK_;\nif(cljs.core.truth_(and__4210__auto__)){\nreturn cljs.core.not(one_line_QMARK_);\n} else {\nreturn and__4210__auto__;\n}\n})())?zprint.zprint.fzprint_justify_width(caller,options,ind,coll):null);\nvar caller_options = (cljs.core.truth_(justify_width)?(options.cljs$core$IFn$_invoke$arity$1 ? options.cljs$core$IFn$_invoke$arity$1(caller) : options.call(null,caller)):null);\nif(cljs.core.truth_((function (){var or__4212__auto__ = new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options);\nif(cljs.core.truth_(or__4212__auto__)){\nreturn or__4212__auto__;\n} else {\nreturn new cljs.core.Keyword(null,\"dbg-print?\",\"dbg-print?\",-660113872).cljs$core$IFn$_invoke$arity$1(options);\n}\n})())){\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),\"fzprint-map-two-up: one-line?\",new cljs.core.Keyword(null,\"one-line?\",\"one-line?\",2055953111).cljs$core$IFn$_invoke$arity$1(options),\"justify?:\",justify_QMARK_], 0));\n} else {\n}\n\nif(cljs.core.not((function (){var and__4210__auto__ = one_line_QMARK_;\nif(cljs.core.truth_(and__4210__auto__)){\nvar and__4210__auto____$1 = force_nl_QMARK_;\nif(cljs.core.truth_(and__4210__auto____$1)){\nreturn (len > (1));\n} else {\nreturn and__4210__auto____$1;\n}\n} else {\nreturn and__4210__auto__;\n}\n})())){\nvar justify_width__$1 = justify_width;\nvar justify_options = (cljs.core.truth_(justify_width__$1)?zprint.config.merge_deep.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([zprint.config.merge_deep.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([options,cljs.core.PersistentArrayMap.createAsIfByAssoc([caller,(caller_options.cljs$core$IFn$_invoke$arity$1 ? caller_options.cljs$core$IFn$_invoke$arity$1(new cljs.core.Keyword(null,\"justify-hang\",\"justify-hang\",1083292243)) : caller_options.call(null,new cljs.core.Keyword(null,\"justify-hang\",\"justify-hang\",1083292243)))])], 0)),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"tuning\",\"tuning\",-48660925),(caller_options.cljs$core$IFn$_invoke$arity$1 ? caller_options.cljs$core$IFn$_invoke$arity$1(new cljs.core.Keyword(null,\"justify-tuning\",\"justify-tuning\",-958931675)) : caller_options.call(null,new cljs.core.Keyword(null,\"justify-tuning\",\"justify-tuning\",-958931675)))], null)], 0)):options);\nwhile(true){\nvar beginning_coll = cljs.core.butlast(coll);\nvar beginning_remaining = (cljs.core.truth_(one_line_QMARK_)?zprint.zprint.fit_within_QMARK_.cljs$core$IFn$_invoke$arity$2((width - ind),beginning_coll):true);\nvar _ = (cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options))?cljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),\"fzprint-map-two-up: remaining:\",(width - ind),\"beginning-remaining:\",beginning_remaining], 0)):null);\nvar beginning = (cljs.core.truth_(beginning_remaining)?zprint.zprint.zpmap.cljs$core$IFn$_invoke$arity$3(options,cljs.core.partial.cljs$core$IFn$_invoke$arity$variadic(zprint.zprint.fzprint_two_up,caller,justify_options,ind,cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([commas_QMARK_,justify_width__$1,null], 0)),beginning_coll):null);\nvar beginning__$1 = (cljs.core.truth_(zprint.zprint.contains_nil_QMARK_(beginning))?null:beginning);\nvar end_coll = new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.last(coll)], null);\nvar end_remaining = (cljs.core.truth_(one_line_QMARK_)?(function (){var and__4210__auto__ = beginning__$1;\nif(cljs.core.truth_(and__4210__auto__)){\nreturn zprint.zprint.fit_within_QMARK_.cljs$core$IFn$_invoke$arity$2((beginning_remaining - rightcnt),end_coll);\n} else {\nreturn and__4210__auto__;\n}\n})():true);\nvar ___$1 = (cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options))?cljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),\"fzprint-map-two-up: beginning-remaining:\",beginning_remaining,\"rightcnt:\",rightcnt,\"end-remaining:\",end_remaining], 0)):null);\nvar end = (cljs.core.truth_(end_remaining)?(function (){var temp__5753__auto__ = zprint.zprint.fzprint_two_up(caller,justify_options,ind,commas_QMARK_,justify_width__$1,new cljs.core.Keyword(null,\"rightmost-pair\",\"rightmost-pair\",-39229380),cljs.core.first(end_coll));\nif(cljs.core.truth_(temp__5753__auto__)){\nvar end_result = temp__5753__auto__;\nreturn new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [end_result], null);\n} else {\nreturn null;\n}\n})():null);\nvar result = ((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(len,(1)))?end:zprint.zprint.concat_no_nil.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([beginning__$1,end], 0))\n);\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options))){\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),cljs.core.pr_str.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\"fzprint-map-two-up: len:\",len,\"(nil? end):\",(end == null),\"end:\",end,\"(nil? beginning):\",(beginning__$1 == null),\"beginning:\",beginning__$1,\"(count end):\",cljs.core.count(end),\"(count beginnging):\",cljs.core.count(beginning__$1),\"justify-width:\",justify_width__$1,\"result:\",result], 0))], 0));\n} else {\n}\n\nif(cljs.core.truth_((function (){var or__4212__auto__ = result;\nif(cljs.core.truth_(or__4212__auto__)){\nreturn or__4212__auto__;\n} else {\nreturn cljs.core.not(justify_width__$1);\n}\n})())){\nreturn result;\n} else {\nvar G__46275 = null;\nvar G__46276 = options;\njustify_width__$1 = G__46275;\njustify_options = G__46276;\ncontinue;\n}\nbreak;\n}\n} else {\nreturn null;\n}\n});\n/**\n * Do a key comparison that works well for numbers as well as\n *   strings.\n */\nzprint.zprint.compare_keys = (function zprint$zprint$compare_keys(x,y){\nif(((typeof x === 'number') && (typeof y === 'number'))){\nreturn cljs.core.compare(x,y);\n} else {\nreturn cljs.core.compare(cljs.core.str.cljs$core$IFn$_invoke$arity$1(x),cljs.core.str.cljs$core$IFn$_invoke$arity$1(y));\n\n}\n});\n/**\n * Do a key comparison that places ordered keys first.\n */\nzprint.zprint.compare_ordered_keys = (function zprint$zprint$compare_ordered_keys(key_value,zdotdotdot,x,y){\nif(cljs.core.truth_((function (){var and__4210__auto__ = (key_value.cljs$core$IFn$_invoke$arity$1 ? key_value.cljs$core$IFn$_invoke$arity$1(x) : key_value.call(null,x));\nif(cljs.core.truth_(and__4210__auto__)){\nreturn (key_value.cljs$core$IFn$_invoke$arity$1 ? key_value.cljs$core$IFn$_invoke$arity$1(y) : key_value.call(null,y));\n} else {\nreturn and__4210__auto__;\n}\n})())){\nreturn cljs.core.compare((key_value.cljs$core$IFn$_invoke$arity$1 ? key_value.cljs$core$IFn$_invoke$arity$1(x) : key_value.call(null,x)),(key_value.cljs$core$IFn$_invoke$arity$1 ? key_value.cljs$core$IFn$_invoke$arity$1(y) : key_value.call(null,y)));\n} else {\nif(cljs.core.truth_((key_value.cljs$core$IFn$_invoke$arity$1 ? key_value.cljs$core$IFn$_invoke$arity$1(x) : key_value.call(null,x)))){\nreturn (-1);\n} else {\nif(cljs.core.truth_((key_value.cljs$core$IFn$_invoke$arity$1 ? key_value.cljs$core$IFn$_invoke$arity$1(y) : key_value.call(null,y)))){\nreturn (1);\n} else {\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(zdotdotdot,x)){\nreturn (1);\n} else {\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(zdotdotdot,y)){\nreturn (-1);\n} else {\nreturn zprint.zprint.compare_keys(x,y);\n\n}\n}\n}\n}\n}\n});\n/**\n * A variety of sorting and ordering options for the output of\n *   partition-all-2-nc.  It can sort, which is the default, but if\n *   the caller has a key-order vector, it will extract any keys in\n *   that vector and place them first (in order) before sorting the\n *   other keys.  If sorting is not called for, does nothing.\n */\nzprint.zprint.order_out = (function zprint$zprint$order_out(caller,p__45527,access,out){\nvar map__45532 = p__45527;\nvar map__45532__$1 = cljs.core.__destructure_map(map__45532);\nvar options = map__45532__$1;\nvar map__45533 = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__45532__$1,caller);\nvar map__45533__$1 = cljs.core.__destructure_map(map__45533);\nvar sort_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__45533__$1,new cljs.core.Keyword(null,\"sort?\",\"sort?\",-567661924));\nvar sort_in_code_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__45533__$1,new cljs.core.Keyword(null,\"sort-in-code?\",\"sort-in-code?\",111878497));\nvar key_order = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__45533__$1,new cljs.core.Keyword(null,\"key-order\",\"key-order\",-356936372));\nvar key_value = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__45533__$1,new cljs.core.Keyword(null,\"key-value\",\"key-value\",-34906839));\nvar in_code_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__45532__$1,new cljs.core.Keyword(null,\"in-code?\",\"in-code?\",194866464));\nif(cljs.core.truth_((function (){var and__4210__auto__ = sort_QMARK_;\nif(cljs.core.truth_(and__4210__auto__)){\nif(cljs.core.truth_(in_code_QMARK_)){\nreturn sort_in_code_QMARK_;\n} else {\nreturn true;\n}\n} else {\nreturn and__4210__auto__;\n}\n})())){\nreturn cljs.core.sort.cljs$core$IFn$_invoke$arity$2((function (p1__45525_SHARP_,p2__45526_SHARP_){\nreturn cljs.core.partial.cljs$core$IFn$_invoke$arity$3(zprint.zprint.compare_ordered_keys,(function (){var or__4212__auto__ = key_value;\nif(cljs.core.truth_(or__4212__auto__)){\nreturn or__4212__auto__;\n} else {\nreturn cljs.core.PersistentArrayMap.EMPTY;\n}\n})(),(zprint.zfns.zdotdotdot.cljs$core$IFn$_invoke$arity$0 ? zprint.zfns.zdotdotdot.cljs$core$IFn$_invoke$arity$0() : zprint.zfns.zdotdotdot.call(null)))((function (){var G__45535 = (access.cljs$core$IFn$_invoke$arity$1 ? access.cljs$core$IFn$_invoke$arity$1(p1__45525_SHARP_) : access.call(null,p1__45525_SHARP_));\nreturn (zprint.zfns.zsexpr.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zsexpr.cljs$core$IFn$_invoke$arity$1(G__45535) : zprint.zfns.zsexpr.call(null,G__45535));\n})(),(function (){var G__45536 = (access.cljs$core$IFn$_invoke$arity$1 ? access.cljs$core$IFn$_invoke$arity$1(p2__45526_SHARP_) : access.call(null,p2__45526_SHARP_));\nreturn (zprint.zfns.zsexpr.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zsexpr.cljs$core$IFn$_invoke$arity$1(G__45536) : zprint.zfns.zsexpr.call(null,G__45536));\n})());\n}),out);\n} else {\nreturn out;\n}\n});\n/**\n * This checks to see if an element should be considered part of a\n *   pair if it comes between other elements, and a single element on\n *   its own if it would otherwise be the first part of a pair.  Mostly\n *   this will trigger on comments, but a #_(...) element will also\n *   trigger this, as will a newline if one appears.\n */\nzprint.zprint.pair_element_QMARK_ = (function zprint$zprint$pair_element_QMARK_(zloc){\nvar or__4212__auto__ = (zprint.zfns.zcomment_QMARK_.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zcomment_QMARK_.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zcomment_QMARK_.call(null,zloc));\nif(cljs.core.truth_(or__4212__auto__)){\nreturn or__4212__auto__;\n} else {\nvar or__4212__auto____$1 = (zprint.zfns.zuneval_QMARK_.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zuneval_QMARK_.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zuneval_QMARK_.call(null,zloc));\nif(cljs.core.truth_(or__4212__auto____$1)){\nreturn or__4212__auto____$1;\n} else {\nreturn (zprint.zfns.znewline_QMARK_.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.znewline_QMARK_.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.znewline_QMARK_.call(null,zloc));\n}\n}\n});\n/**\n * This checks to see if an element should be considered the middle element\n *   of a pair.  At some point, we can expand this, but for now there is only\n *   one middle element.\n */\nzprint.zprint.middle_element_QMARK_ = (function zprint$zprint$middle_element_QMARK_(p__45538,zloc){\nvar map__45539 = p__45538;\nvar map__45539__$1 = cljs.core.__destructure_map(map__45539);\nvar options = map__45539__$1;\nvar in_code_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__45539__$1,new cljs.core.Keyword(null,\"in-code?\",\"in-code?\",194866464));\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(in_code_QMARK_,\"condp\")){\nreturn cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2((zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zstring.call(null,zloc)),\":>>\");\n} else {\nreturn null;\n}\n});\n/**\n * If given a non-collection, simply does a dissoc of the key, but\n *   if given a sequence of keys, will remove the final one.\n */\nzprint.zprint.remove_key_seq = (function zprint$zprint$remove_key_seq(m,ks){\nif(cljs.core.coll_QMARK_(ks)){\nvar this_key = cljs.core.first(ks);\nvar next_key = cljs.core.next(ks);\nif(next_key){\nvar removed_map = (function (){var G__45544 = cljs.core.get.cljs$core$IFn$_invoke$arity$2(m,this_key);\nvar G__45545 = cljs.core.next(ks);\nreturn (zprint.zprint.remove_key_seq.cljs$core$IFn$_invoke$arity$2 ? zprint.zprint.remove_key_seq.cljs$core$IFn$_invoke$arity$2(G__45544,G__45545) : zprint.zprint.remove_key_seq.call(null,G__45544,G__45545));\n})();\nif(cljs.core.empty_QMARK_(removed_map)){\nreturn cljs.core.dissoc.cljs$core$IFn$_invoke$arity$2(m,this_key);\n} else {\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(m,this_key,removed_map);\n}\n} else {\nreturn cljs.core.dissoc.cljs$core$IFn$_invoke$arity$2(m,this_key);\n}\n} else {\nreturn cljs.core.dissoc.cljs$core$IFn$_invoke$arity$2(m,ks);\n}\n});\n/**\n * Given a map and a key sequence, remove that key sequence if\n *   it appears in the map, and terminate the reduce if it changes\n *   the map.\n */\nzprint.zprint.ignore_key_seq_silent = (function zprint$zprint$ignore_key_seq_silent(m,ks){\nif(cljs.core.coll_QMARK_(ks)){\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(cljs.core.get_in.cljs$core$IFn$_invoke$arity$3(m,ks,new cljs.core.Keyword(null,\"zprint-not-found\",\"zprint-not-found\",-198220411)),new cljs.core.Keyword(null,\"zprint-not-found\",\"zprint-not-found\",-198220411))){\nreturn m;\n} else {\nreturn zprint.zprint.remove_key_seq(m,ks);\n}\n} else {\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(cljs.core.get.cljs$core$IFn$_invoke$arity$3(m,ks,new cljs.core.Keyword(null,\"zprint-not-found\",\"zprint-not-found\",-198220411)),new cljs.core.Keyword(null,\"zprint-not-found\",\"zprint-not-found\",-198220411))){\nreturn m;\n} else {\nreturn cljs.core.dissoc.cljs$core$IFn$_invoke$arity$2(m,ks);\n}\n}\n});\n/**\n * Given a map and a key sequence, remove that key sequence if\n *   it appears in the map leaving behind a key :zprint-ignored, \n *   and terminate the reduce if it changes the map.\n */\nzprint.zprint.ignore_key_seq = (function zprint$zprint$ignore_key_seq(m,ks){\nif(cljs.core.coll_QMARK_(ks)){\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(cljs.core.get_in.cljs$core$IFn$_invoke$arity$3(m,ks,new cljs.core.Keyword(null,\"zprint-not-found\",\"zprint-not-found\",-198220411)),new cljs.core.Keyword(null,\"zprint-not-found\",\"zprint-not-found\",-198220411))){\nreturn m;\n} else {\nreturn cljs.core.assoc_in(m,ks,new cljs.core.Keyword(null,\"zprint-ignored\",\"zprint-ignored\",434436784));\n}\n} else {\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(cljs.core.get.cljs$core$IFn$_invoke$arity$3(m,ks,new cljs.core.Keyword(null,\"zprint-not-found\",\"zprint-not-found\",-198220411)),new cljs.core.Keyword(null,\"zprint-not-found\",\"zprint-not-found\",-198220411))){\nreturn m;\n} else {\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(m,ks,new cljs.core.Keyword(null,\"zprint-ignored\",\"zprint-ignored\",434436784));\n}\n}\n});\n/**\n * Take a map and remove any of the key sequences specified from it.\n *   Note that this only works for sexpressions, not for actual zippers.\n */\nzprint.zprint.map_ignore = (function zprint$zprint$map_ignore(caller,p__45546,zloc){\nvar map__45547 = p__45546;\nvar map__45547__$1 = cljs.core.__destructure_map(map__45547);\nvar options = map__45547__$1;\nvar map__45548 = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__45547__$1,caller);\nvar map__45548__$1 = cljs.core.__destructure_map(map__45548);\nvar key_ignore = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__45548__$1,new cljs.core.Keyword(null,\"key-ignore\",\"key-ignore\",75506668));\nvar key_ignore_silent = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__45548__$1,new cljs.core.Keyword(null,\"key-ignore-silent\",\"key-ignore-silent\",-1720115060));\nvar ignored_silent = (cljs.core.truth_(key_ignore_silent)?cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(zprint.zprint.ignore_key_seq_silent,zloc,key_ignore_silent):zloc);\nvar ignored = (cljs.core.truth_(key_ignore)?cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(zprint.zprint.ignore_key_seq,ignored_silent,key_ignore):ignored_silent);\nreturn ignored;\n});\n/**\n * Input is (zseqnws zloc) or (zseqnws-w-nl) where one assumes that\n *   these are pairs.  Thus, a seq of zlocs.  Output is a sequence of\n *   seqs, where the seqs are usually pairs, but might be single things.\n *   Doesn't pair up comments or #_(...) unevaled sexpressions.  The\n *   ones before the first part of a pair come as a single element in\n *   what would usually be a pair, and the ones between the first and\n *   second parts of a pair come inside the pair.  There may be an\n *   arbitrary number of elements between the first and second elements\n *   of the pair (one per line).  If there are any comments or unevaled\n *   sexpressions, don't sort the keys, as we might lose track of where\n *   the comments or unevaled s-expressions go.\n */\nzprint.zprint.partition_all_2_nc = (function zprint$zprint$partition_all_2_nc(options,coll){\nif(cljs.core.empty_QMARK_(coll)){\nreturn null;\n} else {\nvar max_length = zprint.zprint.get_max_length(options);\nvar remaining = coll;\nvar no_sort_QMARK_ = null;\nvar index = (0);\nvar out = cljs.core.transient$(cljs.core.PersistentVector.EMPTY);\nwhile(true){\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options))){\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),cljs.core.pr_str.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\"partition-all-2-nc: index:\",index,\"no-sort?:\",no_sort_QMARK_,\"first remaining:\",(function (){var G__45561 = cljs.core.first(remaining);\nreturn (zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1(G__45561) : zprint.zfns.zstring.call(null,G__45561));\n})(),\"second remaining:\",(function (){var G__45562 = cljs.core.second(remaining);\nreturn (zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1(G__45562) : zprint.zfns.zstring.call(null,G__45562));\n})()], 0))], 0));\n} else {\n}\n\nif(cljs.core.not(remaining)){\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [no_sort_QMARK_,cljs.core.persistent_BANG_(out)], null);\n} else {\nvar vec__45563 = (cljs.core.truth_(zprint.zprint.pair_element_QMARK_(cljs.core.first(remaining)))?new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.next(remaining),new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.first(remaining)], null),true], null):(cljs.core.truth_((function (){var or__4212__auto__ = zprint.zprint.pair_element_QMARK_(cljs.core.second(remaining));\nif(cljs.core.truth_(or__4212__auto__)){\nreturn or__4212__auto__;\n} else {\nreturn zprint.zprint.middle_element_QMARK_(options,cljs.core.second(remaining));\n}\n})())?(function (){var vec__45566 = cljs.core.split_with(((function (remaining,no_sort_QMARK_,index,out,max_length){\nreturn (function (p1__45549_SHARP_){\nvar or__4212__auto__ = zprint.zprint.pair_element_QMARK_(p1__45549_SHARP_);\nif(cljs.core.truth_(or__4212__auto__)){\nreturn or__4212__auto__;\n} else {\nreturn zprint.zprint.middle_element_QMARK_(options,p1__45549_SHARP_);\n}\n});})(remaining,no_sort_QMARK_,index,out,max_length))\n,cljs.core.next(remaining));\nvar comment_seq = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45566,(0),null);\nvar rest_seq = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45566,(1),null);\nif(cljs.core.truth_(cljs.core.first(rest_seq))){\nreturn new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.next(rest_seq),cljs.core.into.cljs$core$IFn$_invoke$arity$2(cljs.core.PersistentVector.EMPTY,cljs.core.concat.cljs$core$IFn$_invoke$arity$variadic(new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.first(remaining)], null),comment_seq,cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.first(rest_seq)], null)], 0))),true], null);\n} else {\nreturn new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.next(remaining),new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.first(remaining)], null),true], null);\n}\n})():((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(cljs.core.count(remaining),(1)))?new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.next(remaining),new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.first(remaining)], null),null], null):new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.next(cljs.core.next(remaining)),new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.first(remaining),cljs.core.second(remaining)], null),null], null)\n)));\nvar new_remaining = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45563,(0),null);\nvar pair_vec = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45563,(1),null);\nvar new_no_sort_QMARK_ = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45563,(2),null);\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options))){\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),cljs.core.pr_str.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\"partition-all-2-nc: pair-vec: first:\",(function (){var G__45573 = cljs.core.first(pair_vec);\nreturn (zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1(G__45573) : zprint.zfns.zstring.call(null,G__45573));\n})(),\"first tag:\",(function (){var G__45574 = cljs.core.first(pair_vec);\nreturn (zprint.zfns.ztag.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.ztag.cljs$core$IFn$_invoke$arity$1(G__45574) : zprint.zfns.ztag.call(null,G__45574));\n})(),\"count:\",cljs.core.count(pair_vec),\"last:\",(function (){var G__45575 = cljs.core.last(pair_vec);\nreturn (zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1(G__45575) : zprint.zfns.zstring.call(null,G__45575));\n})()], 0))], 0));\n} else {\n}\n\nvar G__46279 = ((((index + (1)) < max_length))?new_remaining:(cljs.core.truth_((function (){var and__4210__auto__ = cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2((index + (1)),max_length);\nif(and__4210__auto__){\nreturn new_remaining;\n} else {\nreturn and__4210__auto__;\n}\n})())?(new cljs.core.List(null,(zprint.zfns.zdotdotdot.cljs$core$IFn$_invoke$arity$0 ? zprint.zfns.zdotdotdot.cljs$core$IFn$_invoke$arity$0() : zprint.zfns.zdotdotdot.call(null)),null,(1),null)):null\n));\nvar G__46280 = (function (){var or__4212__auto__ = no_sort_QMARK_;\nif(cljs.core.truth_(or__4212__auto__)){\nreturn or__4212__auto__;\n} else {\nreturn new_no_sort_QMARK_;\n}\n})();\nvar G__46281 = (index + (1));\nvar G__46282 = cljs.core.conj_BANG_.cljs$core$IFn$_invoke$arity$2(out,pair_vec);\nremaining = G__46279;\nno_sort_QMARK_ = G__46280;\nindex = G__46281;\nout = G__46282;\ncontinue;\n}\nbreak;\n}\n}\n});\n/**\n * Take a seq, and if it is contains a single symbol, simply return\n *   it in another seq.  If it contains something else, remove any non\n *   collections off of the end and return them in their own double seqs,\n *   as well as return the remainder (the beginning) as a double seq.\n */\nzprint.zprint.cleave_end = (function zprint$zprint$cleave_end(coll){\nif(cljs.core.truth_((function (){var or__4212__auto__ = (function (){var G__45577 = cljs.core.first(coll);\nreturn (zprint.zfns.zsymbol_QMARK_.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zsymbol_QMARK_.cljs$core$IFn$_invoke$arity$1(G__45577) : zprint.zfns.zsymbol_QMARK_.call(null,G__45577));\n})();\nif(cljs.core.truth_(or__4212__auto__)){\nreturn or__4212__auto__;\n} else {\nvar G__45578 = cljs.core.first(coll);\nreturn (zprint.zfns.zreader_cond_w_symbol_QMARK_.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zreader_cond_w_symbol_QMARK_.cljs$core$IFn$_invoke$arity$1(G__45578) : zprint.zfns.zreader_cond_w_symbol_QMARK_.call(null,G__45578));\n}\n})())){\nreturn (new cljs.core.List(null,coll,null,(1),null));\n} else {\nvar rev_seq = cljs.core.reverse(coll);\nvar vec__45579 = cljs.core.split_with((function (p1__45576_SHARP_){\nreturn cljs.core.not((function (){var or__4212__auto__ = (zprint.zfns.zcoll_QMARK_.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zcoll_QMARK_.cljs$core$IFn$_invoke$arity$1(p1__45576_SHARP_) : zprint.zfns.zcoll_QMARK_.call(null,p1__45576_SHARP_));\nif(cljs.core.truth_(or__4212__auto__)){\nreturn or__4212__auto__;\n} else {\nreturn (zprint.zfns.zreader_cond_w_coll_QMARK_.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zreader_cond_w_coll_QMARK_.cljs$core$IFn$_invoke$arity$1(p1__45576_SHARP_) : zprint.zfns.zreader_cond_w_coll_QMARK_.call(null,p1__45576_SHARP_));\n}\n})());\n}),rev_seq);\nvar split_non_coll = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45579,(0),null);\nvar _ = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45579,(1),null);\nvar split_non_coll__$1 = cljs.core.map.cljs$core$IFn$_invoke$arity$2(cljs.core.list,cljs.core.reverse(split_non_coll));\nvar remainder = cljs.core.take.cljs$core$IFn$_invoke$arity$2((cljs.core.count(coll) - cljs.core.count(split_non_coll__$1)),coll);\nif(cljs.core.empty_QMARK_(remainder)){\nreturn split_non_coll__$1;\n} else {\nreturn cljs.core.concat.cljs$core$IFn$_invoke$arity$2((new cljs.core.List(null,remainder,null,(1),null)),split_non_coll__$1);\n}\n}\n});\n/**\n * Similar to partition-all-2-nc, but instead of trying to pair things\n *   up (modulo comments and unevaled expressions), this begins things\n *   with a symbol, and then accumulates collections until the next symbol.\n *   Returns a seq of seqs, where the first thing in each internal seq is\n *   a protocol and the remaining thing(s) in that seq are the expressions that\n *   follow.  If there is a single thing, it is returned in its own internal\n *   seq. ((P (foo [this a) (bar-me [this] b) (barx [this y] (+ c y))) ...)\n *   Made harder by the fact that the symbol might be inside of a #?() reader\n *   conditional.  It handles comments before symbols on the symbol indent, \n *   and the comments before the collections on the collection indent.  \n *   Since it doesn't know how many collections there are, this is not trivial.  \n *   Must be called with a sequence of z-things (these days called a zseq)\n */\nzprint.zprint.partition_all_sym = (function zprint$zprint$partition_all_sym(options,modifier_set,coll){\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options))){\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),cljs.core.pr_str.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\"partition-all-sym:\",modifier_set], 0))], 0));\n} else {\n}\n\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options))){\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),\"partition-all-sym: coll:\",cljs.core.map.cljs$core$IFn$_invoke$arity$2(zprint.zfns.zstring,coll)], 0));\n} else {\n}\n\nvar part_sym = cljs.core.partition_by.cljs$core$IFn$_invoke$arity$2((function (p1__45582_SHARP_){\nvar or__4212__auto__ = (zprint.zfns.zsymbol_QMARK_.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zsymbol_QMARK_.cljs$core$IFn$_invoke$arity$1(p1__45582_SHARP_) : zprint.zfns.zsymbol_QMARK_.call(null,p1__45582_SHARP_));\nif(cljs.core.truth_(or__4212__auto__)){\nreturn or__4212__auto__;\n} else {\nvar or__4212__auto____$1 = (zprint.zfns.znil_QMARK_.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.znil_QMARK_.cljs$core$IFn$_invoke$arity$1(p1__45582_SHARP_) : zprint.zfns.znil_QMARK_.call(null,p1__45582_SHARP_));\nif(cljs.core.truth_(or__4212__auto____$1)){\nreturn or__4212__auto____$1;\n} else {\nreturn (zprint.zfns.zreader_cond_w_symbol_QMARK_.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zreader_cond_w_symbol_QMARK_.cljs$core$IFn$_invoke$arity$1(p1__45582_SHARP_) : zprint.zfns.zreader_cond_w_symbol_QMARK_.call(null,p1__45582_SHARP_));\n}\n}\n}),coll);\nvar split_non_coll = cljs.core.mapcat.cljs$core$IFn$_invoke$arity$variadic(zprint.zprint.cleave_end,cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([part_sym], 0));\nvar remaining = split_non_coll;\nvar out = cljs.core.transient$(cljs.core.PersistentVector.EMPTY);\nwhile(true){\nif(cljs.core.empty_QMARK_(remaining)){\nreturn cljs.core.persistent_BANG_(out);\n} else {\nvar vec__45595 = (cljs.core.truth_((function (){var and__4210__auto__ = (function (){var or__4212__auto__ = (function (){var G__45598 = cljs.core.ffirst(remaining);\nreturn (zprint.zfns.zsymbol_QMARK_.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zsymbol_QMARK_.cljs$core$IFn$_invoke$arity$1(G__45598) : zprint.zfns.zsymbol_QMARK_.call(null,G__45598));\n})();\nif(cljs.core.truth_(or__4212__auto__)){\nreturn or__4212__auto__;\n} else {\nvar or__4212__auto____$1 = (function (){var G__45599 = cljs.core.ffirst(remaining);\nreturn (zprint.zfns.znil_QMARK_.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.znil_QMARK_.cljs$core$IFn$_invoke$arity$1(G__45599) : zprint.zfns.znil_QMARK_.call(null,G__45599));\n})();\nif(cljs.core.truth_(or__4212__auto____$1)){\nreturn or__4212__auto____$1;\n} else {\nvar G__45600 = cljs.core.ffirst(remaining);\nreturn (zprint.zfns.zreader_cond_w_symbol_QMARK_.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zreader_cond_w_symbol_QMARK_.cljs$core$IFn$_invoke$arity$1(G__45600) : zprint.zfns.zreader_cond_w_symbol_QMARK_.call(null,G__45600));\n}\n}\n})();\nif(cljs.core.truth_(and__4210__auto__)){\nvar and__4210__auto____$1 = (!(cljs.core.empty_QMARK_(cljs.core.second(remaining))));\nif(and__4210__auto____$1){\nvar or__4212__auto__ = (!(((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2((function (){var G__45601 = cljs.core.first(cljs.core.second(remaining));\nreturn (zprint.zfns.ztag.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.ztag.cljs$core$IFn$_invoke$arity$1(G__45601) : zprint.zfns.ztag.call(null,G__45601));\n})(),new cljs.core.Keyword(null,\"comment\",\"comment\",532206069))) || (cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2((function (){var G__45602 = cljs.core.first(cljs.core.second(remaining));\nreturn (zprint.zfns.ztag.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.ztag.cljs$core$IFn$_invoke$arity$1(G__45602) : zprint.zfns.ztag.call(null,G__45602));\n})(),new cljs.core.Keyword(null,\"newline\",\"newline\",1790071323))))));\nif(or__4212__auto__){\nreturn or__4212__auto__;\n} else {\nvar G__45603 = cljs.core.last(cljs.core.second(remaining));\nreturn (zprint.zfns.zcoll_QMARK_.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zcoll_QMARK_.cljs$core$IFn$_invoke$arity$1(G__45603) : zprint.zfns.zcoll_QMARK_.call(null,G__45603));\n}\n} else {\nreturn and__4210__auto____$1;\n}\n} else {\nreturn and__4210__auto__;\n}\n})())?((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(cljs.core.count(cljs.core.first(remaining)),(1)))?new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.nthnext(remaining,(2)),cljs.core.conj_BANG_.cljs$core$IFn$_invoke$arity$2(out,cljs.core.concat.cljs$core$IFn$_invoke$arity$2(cljs.core.first(remaining),cljs.core.second(remaining)))], null):(cljs.core.truth_((function (){var and__4210__auto__ = modifier_set;\nif(cljs.core.truth_(and__4210__auto__)){\nvar G__45604 = (function (){var G__45605 = cljs.core.ffirst(remaining);\nreturn (zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1(G__45605) : zprint.zfns.zstring.call(null,G__45605));\n})();\nreturn (modifier_set.cljs$core$IFn$_invoke$arity$1 ? modifier_set.cljs$core$IFn$_invoke$arity$1(G__45604) : modifier_set.call(null,G__45604));\n} else {\nreturn and__4210__auto__;\n}\n})())?((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(cljs.core.count(cljs.core.first(remaining)),(2)))?new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.nthnext(remaining,(2)),cljs.core.conj_BANG_.cljs$core$IFn$_invoke$arity$2(out,cljs.core.concat.cljs$core$IFn$_invoke$arity$2(cljs.core.first(remaining),cljs.core.second(remaining)))], null):new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [((cljs.core.next(cljs.core.next(cljs.core.first(remaining))))?cljs.core.cons(cljs.core.next(cljs.core.next(cljs.core.first(remaining))),cljs.core.next(remaining)):cljs.core.next(remaining)),cljs.core.conj_BANG_.cljs$core$IFn$_invoke$arity$2(out,(new cljs.core.List(null,cljs.core.ffirst(remaining),(new cljs.core.List(null,cljs.core.second(cljs.core.first(remaining)),null,(1),null)),(2),null)))], null)):new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cons(cljs.core.next(cljs.core.first(remaining)),cljs.core.next(remaining)),cljs.core.conj_BANG_.cljs$core$IFn$_invoke$arity$2(out,(new cljs.core.List(null,cljs.core.ffirst(remaining),null,(1),null)))], null))):new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.next(remaining),cljs.core.conj_BANG_.cljs$core$IFn$_invoke$arity$2(out,cljs.core.first(remaining))], null)\n);\nvar next_remaining = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45595,(0),null);\nvar new_out = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45595,(1),null);\nvar G__46293 = next_remaining;\nvar G__46294 = new_out;\nremaining = G__46293;\nout = G__46294;\ncontinue;\n}\nbreak;\n}\n});\n/**\n * Create an r-str-vec with the indent appropriate for the r-str if\n *   it is preceded by a newline.\n */\nzprint.zprint.rstr_vec = (function zprint$zprint$rstr_vec(var_args){\nvar G__45608 = arguments.length;\nswitch (G__45608) {\ncase 5:\nreturn zprint.zprint.rstr_vec.cljs$core$IFn$_invoke$arity$5((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]));\n\nbreak;\ncase 4:\nreturn zprint.zprint.rstr_vec.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\n(zprint.zprint.rstr_vec.cljs$core$IFn$_invoke$arity$5 = (function (options,ind,zloc,r_str,r_type){\nreturn new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 4, 5, cljs.core.PersistentVector.EMPTY_NODE, [r_str,zprint.zprint.zcolor_map(options,(function (){var or__4212__auto__ = r_type;\nif(cljs.core.truth_(or__4212__auto__)){\nreturn or__4212__auto__;\n} else {\nreturn r_str;\n}\n})()),(function (){var or__4212__auto__ = r_type;\nif(cljs.core.truth_(or__4212__auto__)){\nreturn or__4212__auto__;\n} else {\nreturn new cljs.core.Keyword(null,\"right\",\"right\",-452581833);\n}\n})(),ind], null)], null);\n}));\n\n(zprint.zprint.rstr_vec.cljs$core$IFn$_invoke$arity$4 = (function (options,ind,zloc,r_str){\nreturn zprint.zprint.rstr_vec.cljs$core$IFn$_invoke$arity$5(options,ind,zloc,r_str,null);\n}));\n\n(zprint.zprint.rstr_vec.cljs$lang$maxFixedArity = 5);\n\nzprint.zprint.fzprint_binding_vec = (function zprint$zprint$fzprint_binding_vec(p__45609,ind,zloc){\nvar map__45610 = p__45609;\nvar map__45610__$1 = cljs.core.__destructure_map(map__45610);\nvar options = map__45610__$1;\nvar map__45611 = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__45610__$1,new cljs.core.Keyword(null,\"binding\",\"binding\",539932593));\nvar map__45611__$1 = cljs.core.__destructure_map(map__45611);\nvar nl_separator_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__45611__$1,new cljs.core.Keyword(null,\"nl-separator?\",\"nl-separator?\",-758068767));\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options))){\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),\"fzprint-binding-vec: ind:\",ind,\"zloc:\",(function (){var G__45612 = (zprint.zfns.zfirst.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zfirst.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zfirst.call(null,zloc));\nreturn (zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1(G__45612) : zprint.zfns.zstring.call(null,G__45612));\n})()], 0));\n} else {\n}\n\nvar options__$1 = zprint.zprint.rightmost(options);\nvar l_str = \"[\";\nvar r_str = \"]\";\nvar l_str_vec = new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [l_str,zprint.zprint.zcolor_map(options__$1,l_str),new cljs.core.Keyword(null,\"left\",\"left\",-399115937)], null)], null);\nvar r_str_vec = zprint.zprint.rstr_vec.cljs$core$IFn$_invoke$arity$4(options__$1,ind,zloc,r_str);\nvar value__45260__auto__ = ((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2((zprint.zfns.zcount.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zcount.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zcount.call(null,zloc)),(0)))?zprint.zprint.concat_no_nil.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([l_str_vec,r_str_vec], 0)):zprint.zprint.concat_no_nil.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([l_str_vec,(function (){var G__45613 = new cljs.core.Keyword(null,\"binding\",\"binding\",539932593).cljs$core$IFn$_invoke$arity$1(options__$1);\nvar G__45614 = (ind + (1));\nvar G__45615 = zprint.zprint.fzprint_map_two_up(new cljs.core.Keyword(null,\"binding\",\"binding\",539932593),options__$1,(ind + (1)),false,cljs.core.second(zprint.zprint.partition_all_2_nc(options__$1,(zprint.zprint.fzprint_get_zloc_seq.cljs$core$IFn$_invoke$arity$3 ? zprint.zprint.fzprint_get_zloc_seq.cljs$core$IFn$_invoke$arity$3(new cljs.core.Keyword(null,\"vector\",\"vector\",1902966158),options__$1,zloc) : zprint.zprint.fzprint_get_zloc_seq.call(null,new cljs.core.Keyword(null,\"vector\",\"vector\",1902966158),options__$1,zloc)))));\nreturn (zprint.zprint.interpose_nl_hf.cljs$core$IFn$_invoke$arity$3 ? zprint.zprint.interpose_nl_hf.cljs$core$IFn$_invoke$arity$3(G__45613,G__45614,G__45615) : zprint.zprint.interpose_nl_hf.call(null,G__45613,G__45614,G__45615));\n})(),r_str_vec], 0)));\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options__$1))){\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options__$1),\"fzprint-binding-vec exit:\",cljs.core.pr_str.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([value__45260__auto__], 0))], 0));\n} else {\n}\n\nreturn value__45260__auto__;\n});\n/**\n * Try to hang something and try to flow it, and then see which is\n *   better.  Has hang and flow indents. fzfn is the function to use \n *   to do zloc.  Note what fzfn does with the input. Presumably the\n *   caller knows what the fzfn does, so it has to count the items\n *   itself and pass it in here as zloc-count if it isn't just (zcount zloc).\n */\nzprint.zprint.fzprint_hang = (function zprint$zprint$fzprint_hang(p__45616,caller,hindent,findent,fzfn,zloc_count,zloc){\nvar map__45618 = p__45616;\nvar map__45618__$1 = cljs.core.__destructure_map(map__45618);\nvar options = map__45618__$1;\nvar one_line_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__45618__$1,new cljs.core.Keyword(null,\"one-line?\",\"one-line?\",2055953111));\nvar force_eol_blanks_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__45618__$1,new cljs.core.Keyword(null,\"force-eol-blanks?\",\"force-eol-blanks?\",1917974011));\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options))){\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),\"fzprint-hang: caller:\",caller], 0));\n} else {\n}\n\nvar hanging = (cljs.core.truth_((function (){var and__4210__auto__ = cljs.core.not_EQ_.cljs$core$IFn$_invoke$arity$2(hindent,findent);\nif(and__4210__auto__){\nvar and__4210__auto____$1 = (function (){var fexpr__45647 = (options.cljs$core$IFn$_invoke$arity$1 ? options.cljs$core$IFn$_invoke$arity$1(caller) : options.call(null,caller));\nreturn (fexpr__45647.cljs$core$IFn$_invoke$arity$1 ? fexpr__45647.cljs$core$IFn$_invoke$arity$1(new cljs.core.Keyword(null,\"hang?\",\"hang?\",-579442854)) : fexpr__45647.call(null,new cljs.core.Keyword(null,\"hang?\",\"hang?\",-579442854)));\n})();\nif(cljs.core.truth_(and__4210__auto____$1)){\nreturn cljs.core.not((function (){var G__45648 = cljs.core.first(zloc);\nreturn (zprint.zfns.znewline_QMARK_.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.znewline_QMARK_.cljs$core$IFn$_invoke$arity$1(G__45648) : zprint.zfns.znewline_QMARK_.call(null,G__45648));\n})());\n} else {\nreturn and__4210__auto____$1;\n}\n} else {\nreturn and__4210__auto__;\n}\n})())?zprint.zprint.concat_no_nil.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 4, 5, cljs.core.PersistentVector.EMPTY_NODE, [\" \",new cljs.core.Keyword(null,\"none\",\"none\",1333468478),new cljs.core.Keyword(null,\"whitespace\",\"whitespace\",-1340035483),(5)], null)], null),(function (){var G__45649 = zprint.zprint.in_hang(options);\nvar G__45650 = hindent;\nvar G__45651 = zloc;\nreturn (fzfn.cljs$core$IFn$_invoke$arity$3 ? fzfn.cljs$core$IFn$_invoke$arity$3(G__45649,G__45650,G__45651) : fzfn.call(null,G__45649,G__45650,G__45651));\n})()], 0)):null);\nvar hanging__$1 = ((cljs.core.not_EQ_.cljs$core$IFn$_invoke$arity$2(cljs.core.nth.cljs$core$IFn$_invoke$arity$2(cljs.core.second(hanging),(2)),new cljs.core.Keyword(null,\"comment-inline\",\"comment-inline\",712944405)))?hanging:null);\nvar hang_count = (function (){var or__4212__auto__ = zloc_count;\nif(cljs.core.truth_(or__4212__auto__)){\nreturn or__4212__auto__;\n} else {\nreturn (zprint.zfns.zcount.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zcount.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zcount.call(null,zloc));\n}\n})();\nvar hr_lines = zprint.zprint.style_lines(options,(hindent - (1)),hanging__$1);\nif(cljs.core.truth_((function (){var or__4212__auto__ = zprint.zprint.fzfit_one_line(options,hr_lines);\nif(or__4212__auto__){\nreturn or__4212__auto__;\n} else {\nreturn one_line_QMARK_;\n}\n})())){\nreturn hanging__$1;\n} else {\nvar flow = (function (){var result = (fzfn.cljs$core$IFn$_invoke$arity$3 ? fzfn.cljs$core$IFn$_invoke$arity$3(options,findent,zloc) : fzfn.call(null,options,findent,zloc));\nreturn zprint.zprint.concat_no_nil.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([(cljs.core.truth_((cljs.core.truth_(force_eol_blanks_QMARK_)?null:zprint.zprint.first_nl_QMARK_(result)))?new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 4, 5, cljs.core.PersistentVector.EMPTY_NODE, [\"\\n\",new cljs.core.Keyword(null,\"none\",\"none\",1333468478),new cljs.core.Keyword(null,\"indent\",\"indent\",-148200125),(42)], null)], null):new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 4, 5, cljs.core.PersistentVector.EMPTY_NODE, [[\"\\n\",cljs.core.str.cljs$core$IFn$_invoke$arity$1(zprint.zprint.blanks(findent))].join(''),new cljs.core.Keyword(null,\"none\",\"none\",1333468478),new cljs.core.Keyword(null,\"indent\",\"indent\",-148200125),(4)], null)], null)),result], 0));\n})();\nvar _ = zprint.zprint.log_lines(options,\"fzprint-hang: flow:\",findent,flow);\nvar fd_lines = zprint.zprint.style_lines(options,findent,flow);\nvar ___$1 = (cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options))?cljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),cljs.core.pr_str.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\"fzprint-hang: ending: hang-count:\",hang_count,\"hanging:\",hanging__$1,\"flow:\",flow], 0))], 0)):null);\nvar hr_good_QMARK_ = (cljs.core.truth_(hanging__$1)?zprint.zprint.good_enough_QMARK_(caller,options,new cljs.core.Keyword(null,\"none-hang\",\"none-hang\",-1101780299),hang_count,(hindent - findent),hr_lines,fd_lines):null);\nif(cljs.core.truth_(hr_good_QMARK_)){\nreturn hanging__$1;\n} else {\nreturn flow;\n}\n}\n});\n/**\n * Always prints pairs on a different line from other pairs. Takes a zloc-seq\n */\nzprint.zprint.fzprint_pairs = (function zprint$zprint$fzprint_pairs(p__45672,ind,zloc_seq){\nvar map__45673 = p__45672;\nvar map__45673__$1 = cljs.core.__destructure_map(map__45673);\nvar options = map__45673__$1;\nvar map__45674 = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__45673__$1,new cljs.core.Keyword(null,\"pair\",\"pair\",-447516312));\nvar map__45674__$1 = cljs.core.__destructure_map(map__45674);\nvar nl_separator_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__45674__$1,new cljs.core.Keyword(null,\"nl-separator?\",\"nl-separator?\",-758068767));\nvar respect_nl_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__45674__$1,new cljs.core.Keyword(null,\"respect-nl?\",\"respect-nl?\",604814635));\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options))){\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),cljs.core.pr_str.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\"fzprint-pairs:\",(function (){var G__45675 = cljs.core.first(zloc_seq);\nreturn (zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1(G__45675) : zprint.zfns.zstring.call(null,G__45675));\n})()], 0))], 0));\n} else {\n}\n\nvar value__45260__auto__ = (function (){var G__45676 = new cljs.core.Keyword(null,\"pair\",\"pair\",-447516312).cljs$core$IFn$_invoke$arity$1(options);\nvar G__45677 = ind;\nvar G__45678 = zprint.zprint.fzprint_map_two_up(new cljs.core.Keyword(null,\"pair\",\"pair\",-447516312),options,ind,false,(function (){var vec__45679 = zprint.zprint.partition_all_2_nc(options,zloc_seq);\nvar _ = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45679,(0),null);\nvar part = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45679,(1),null);\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options))){\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),cljs.core.pr_str.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\"fzprint-pairs: partition:\",cljs.core.map.cljs$core$IFn$_invoke$arity$2(cljs.core.comp.cljs$core$IFn$_invoke$arity$2(zprint.zfns.zstring,cljs.core.first),part),\"respect-nl?\",respect_nl_QMARK_], 0))], 0));\n} else {\n}\n\nreturn part;\n})());\nreturn (zprint.zprint.interpose_nl_hf.cljs$core$IFn$_invoke$arity$3 ? zprint.zprint.interpose_nl_hf.cljs$core$IFn$_invoke$arity$3(G__45676,G__45677,G__45678) : zprint.zprint.interpose_nl_hf.call(null,G__45676,G__45677,G__45678));\n})();\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options))){\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),\"fzprint-pairs: exit:\",cljs.core.pr_str.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([value__45260__auto__], 0))], 0));\n} else {\n}\n\nreturn value__45260__auto__;\n});\n/**\n * Print things with a symbol and collections following.  Kind of like with\n *   pairs, but not quite. Takes a zloc-seq.\n */\nzprint.zprint.fzprint_extend = (function zprint$zprint$fzprint_extend(p__45686,ind,zloc_seq){\nvar map__45687 = p__45686;\nvar map__45687__$1 = cljs.core.__destructure_map(map__45687);\nvar options = map__45687__$1;\nvar map__45688 = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__45687__$1,new cljs.core.Keyword(null,\"extend\",\"extend\",1836484006));\nvar map__45688__$1 = cljs.core.__destructure_map(map__45688);\nvar nl_separator_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__45688__$1,new cljs.core.Keyword(null,\"nl-separator?\",\"nl-separator?\",-758068767));\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options))){\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),\"fzprint-extend:\",(function (){var G__45689 = cljs.core.first(zloc_seq);\nreturn (zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1(G__45689) : zprint.zfns.zstring.call(null,G__45689));\n})()], 0));\n} else {\n}\n\nvar value__45260__auto__ = (function (){var G__45690 = new cljs.core.Keyword(null,\"extend\",\"extend\",1836484006).cljs$core$IFn$_invoke$arity$1(options);\nvar G__45691 = ind;\nvar G__45692 = zprint.zprint.fzprint_map_two_up(new cljs.core.Keyword(null,\"extend\",\"extend\",1836484006),cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(options,new cljs.core.Keyword(null,\"fn-style\",\"fn-style\",1330516917),new cljs.core.Keyword(null,\"fn\",\"fn\",-1175266204)),ind,false,(function (){var part = zprint.zprint.partition_all_sym(options,new cljs.core.Keyword(null,\"modifiers\",\"modifiers\",50378834).cljs$core$IFn$_invoke$arity$1(new cljs.core.Keyword(null,\"extend\",\"extend\",1836484006).cljs$core$IFn$_invoke$arity$1(options)),zloc_seq);\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options))){\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),\"fzprint-extend: partition:\",cljs.core.map.cljs$core$IFn$_invoke$arity$2((function (p1__45683_SHARP_){\nreturn cljs.core.map.cljs$core$IFn$_invoke$arity$2(zprint.zfns.zstring,p1__45683_SHARP_);\n}),part)], 0));\n} else {\n}\n\nreturn part;\n})());\nreturn (zprint.zprint.interpose_nl_hf.cljs$core$IFn$_invoke$arity$3 ? zprint.zprint.interpose_nl_hf.cljs$core$IFn$_invoke$arity$3(G__45690,G__45691,G__45692) : zprint.zprint.interpose_nl_hf.call(null,G__45690,G__45691,G__45692));\n})();\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options))){\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),\"fzprint-extend: exit:\",cljs.core.pr_str.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([value__45260__auto__], 0))], 0));\n} else {\n}\n\nreturn value__45260__auto__;\n});\n/**\n * Given a transient vector v, concatenate all of the other\n *   elements in all of the remaining collections onto v.\n */\nzprint.zprint.concatv_BANG_ = (function zprint$zprint$concatv_BANG_(var_args){\nvar args__4824__auto__ = [];\nvar len__4818__auto___46353 = arguments.length;\nvar i__4819__auto___46354 = (0);\nwhile(true){\nif((i__4819__auto___46354 < len__4818__auto___46353)){\nargs__4824__auto__.push((arguments[i__4819__auto___46354]));\n\nvar G__46359 = (i__4819__auto___46354 + (1));\ni__4819__auto___46354 = G__46359;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4825__auto__ = ((((1) < args__4824__auto__.length))?(new cljs.core.IndexedSeq(args__4824__auto__.slice((1)),(0),null)):null);\nreturn zprint.zprint.concatv_BANG_.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),argseq__4825__auto__);\n});\n\n(zprint.zprint.concatv_BANG_.cljs$core$IFn$_invoke$arity$variadic = (function (v,rest){\nvar cols = rest;\nvar out = v;\nwhile(true){\nif(cljs.core.truth_(cols)){\nvar G__46366 = cljs.core.next(cols);\nvar G__46367 = (function (){var col = cljs.core.first(cols);\nvar out__$1 = out;\nwhile(true){\nif(cljs.core.truth_(col)){\nvar G__46370 = cljs.core.next(col);\nvar G__46371 = cljs.core.conj_BANG_.cljs$core$IFn$_invoke$arity$2(out__$1,cljs.core.first(col));\ncol = G__46370;\nout__$1 = G__46371;\ncontinue;\n} else {\nreturn out__$1;\n}\nbreak;\n}\n})();\ncols = G__46366;\nout = G__46367;\ncontinue;\n} else {\nreturn out;\n}\nbreak;\n}\n}));\n\n(zprint.zprint.concatv_BANG_.cljs$lang$maxFixedArity = (1));\n\n/** @this {Function} */\n(zprint.zprint.concatv_BANG_.cljs$lang$applyTo = (function (seq45693){\nvar G__45694 = cljs.core.first(seq45693);\nvar seq45693__$1 = cljs.core.next(seq45693);\nvar self__4805__auto__ = this;\nreturn self__4805__auto__.cljs$core$IFn$_invoke$arity$variadic(G__45694,seq45693__$1);\n}));\n\n/**\n * Do a fzprint-seq like thing, but do it incrementally and\n *   if it gets too big, return nil.\n */\nzprint.zprint.fzprint_one_line = (function zprint$zprint$fzprint_one_line(options,ind,zloc_seq){\nif(cljs.core.truth_((function (){var or__4212__auto__ = new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options);\nif(cljs.core.truth_(or__4212__auto__)){\nreturn or__4212__auto__;\n} else {\nreturn new cljs.core.Keyword(null,\"dbg-print?\",\"dbg-print?\",-660113872).cljs$core$IFn$_invoke$arity$1(options);\n}\n})())){\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),\"fzprint-one-line:\"], 0));\n} else {\n}\n\nvar seq_right = zloc_seq;\nvar len = cljs.core.count(seq_right);\nvar last_index = (len - (1));\nvar gt_1_QMARK_ = (cljs.core.count(seq_right) > (1));\nvar options__$1 = cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(options,new cljs.core.Keyword(null,\"one-line?\",\"one-line?\",2055953111),true);\nvar zloc_seq__$1 = seq_right;\nvar new_ind = cljs.core.long$(ind);\nvar index = (0);\nvar out = cljs.core.transient$(cljs.core.PersistentVector.EMPTY);\nwhile(true){\nif(cljs.core.empty_QMARK_(zloc_seq__$1)){\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options__$1))){\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options__$1),\"fzprint-one-line: exiting count:\",cljs.core.count(out)], 0));\n} else {\n}\n\nreturn cljs.core.persistent_BANG_(out);\n} else {\nvar next_zloc = cljs.core.first(zloc_seq__$1);\nvar vec__45709 = ((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(index,last_index))?new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [(((!((index === (0)))))?new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 4, 5, cljs.core.PersistentVector.EMPTY_NODE, [\" \",new cljs.core.Keyword(null,\"none\",\"none\",1333468478),new cljs.core.Keyword(null,\"whitespace\",\"whitespace\",-1340035483),(6)], null)], null):null),options__$1], null):((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(index,(0)))?new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [null,zprint.zprint.not_rightmost(options__$1)], null):new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 4, 5, cljs.core.PersistentVector.EMPTY_NODE, [\" \",new cljs.core.Keyword(null,\"none\",\"none\",1333468478),new cljs.core.Keyword(null,\"whitespace\",\"whitespace\",-1340035483),(7)], null)], null),zprint.zprint.not_rightmost(options__$1)], null)\n));\nvar sep = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45709,(0),null);\nvar next_options = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45709,(1),null);\nvar next_out = (zprint.zprint.fzprint_STAR_.cljs$core$IFn$_invoke$arity$3 ? zprint.zprint.fzprint_STAR_.cljs$core$IFn$_invoke$arity$3(next_options,new_ind,next_zloc) : zprint.zprint.fzprint_STAR_.call(null,next_options,new_ind,next_zloc));\nvar _ = zprint.zprint.log_lines(options__$1,\"fzprint-one-line:\",new_ind,next_out);\nvar vec__45712 = zprint.zprint.style_lines(options__$1,new_ind,next_out);\nvar line_count = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45712,(0),null);\nvar max_width = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45712,(1),null);\nvar next_lines = vec__45712;\nif((!(zprint.zprint.fzfit_one_line(next_options,next_lines)))){\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options__$1))){\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options__$1),\"fzprint-one-line: failed, too wide or too many lines!\"], 0));\n} else {\n}\n\nreturn null;\n} else {\nvar G__46382 = cljs.core.next(zloc_seq__$1);\nvar G__46383 = (cljs.core.long$(max_width) + (1));\nvar G__46384 = (index + (1));\nvar G__46385 = zprint.zprint.concatv_BANG_.cljs$core$IFn$_invoke$arity$variadic(out,cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([sep,next_out], 0));\nzloc_seq__$1 = G__46382;\nnew_ind = G__46383;\nindex = G__46384;\nout = G__46385;\ncontinue;\n}\n}\nbreak;\n}\n});\n/**\n * Take a seq of a zloc, created by (zmap identity zloc).  Return\n *   a seq of the fzprint* of each element.  No spacing between any\n *   of these elements. Note that this is not a style-vec, but a seq\n *   of style-vecs of each of the elements.  These would need to be\n *   concatenated together to become a style-vec.  ind is either a\n *   constant or a seq of indents, one for each element in zloc-seq.\n *   Note that right gets evaluated immediately, while left yields a\n *   lazy sequence which get evaluated later.\n */\nzprint.zprint.fzprint_seq = (function zprint$zprint$fzprint_seq(options,ind,zloc_seq){\nvar max_length = zprint.zprint.get_max_length(options);\nvar len = cljs.core.count(zloc_seq);\nvar zloc_seq__$1 = (((len > max_length))?cljs.core.concat.cljs$core$IFn$_invoke$arity$2(cljs.core.take.cljs$core$IFn$_invoke$arity$2(max_length,zloc_seq),(new cljs.core.List(null,(zprint.zfns.zdotdotdot.cljs$core$IFn$_invoke$arity$0 ? zprint.zfns.zdotdotdot.cljs$core$IFn$_invoke$arity$0() : zprint.zfns.zdotdotdot.call(null)),null,(1),null))):zloc_seq);\nvar len__$1 = cljs.core.count(zloc_seq__$1);\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options))){\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),\"fzprint-seq: (count zloc-seq):\",len__$1,\"max-length:\",max_length,\"ind:\",ind], 0));\n} else {\n}\n\nif(cljs.core.empty_QMARK_(zloc_seq__$1)){\nreturn null;\n} else {\nif((max_length === (0))){\nreturn new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [\"#?#\",zprint.zprint.zcolor_map(options,new cljs.core.Keyword(null,\"keyword\",\"keyword\",811389747)),new cljs.core.Keyword(null,\"element\",\"element\",1974019749)], null)], null)], null);\n} else {\nvar left = zprint.zprint.zpmap.cljs$core$IFn$_invoke$arity$4(options,(function (p1__45717_SHARP_,p2__45718_SHARP_){\nvar G__45719 = zprint.zprint.not_rightmost(options);\nvar G__45720 = p1__45717_SHARP_;\nvar G__45721 = p2__45718_SHARP_;\nreturn (zprint.zprint.fzprint_STAR_.cljs$core$IFn$_invoke$arity$3 ? zprint.zprint.fzprint_STAR_.cljs$core$IFn$_invoke$arity$3(G__45719,G__45720,G__45721) : zprint.zprint.fzprint_STAR_.call(null,G__45719,G__45720,G__45721));\n}),((cljs.core.coll_QMARK_(ind))?ind:cljs.core.repeat.cljs$core$IFn$_invoke$arity$1(ind)),cljs.core.butlast(zloc_seq__$1));\nvar right = new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [(function (){var G__45722 = options;\nvar G__45723 = ((cljs.core.coll_QMARK_(ind))?cljs.core.last(ind):ind);\nvar G__45724 = cljs.core.last(zloc_seq__$1);\nreturn (zprint.zprint.fzprint_STAR_.cljs$core$IFn$_invoke$arity$3 ? zprint.zprint.fzprint_STAR_.cljs$core$IFn$_invoke$arity$3(G__45722,G__45723,G__45724) : zprint.zprint.fzprint_STAR_.call(null,G__45722,G__45723,G__45724));\n})()], null);\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(len__$1,(1))){\nreturn right;\n} else {\nreturn zprint.zprint.concat_no_nil.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([left,right], 0));\n\n}\n\n}\n}\n});\n/**\n * Takes zloc-seq, a seq of a zloc, created by (zmap identity zloc),\n *   and returns a style-vec of the result.  Either it fits on one\n *   line, or it is rendered on multiple lines.  You can force multiple\n *   lines with force-nl?. If the seq is empty, returns :noseq, which\n *   is what you give concat-no-nil if you want this to just disappear.\n *   If you want it to do less than everything in the original zloc,\n *   modify the result of (zmap identity zloc) to just contain what\n *   you want to print. ind is either a single indent, or a seq of\n *   indents, one for each element in zloc-seq.  Don't concatenate an\n *   indent/newline on to the beginning of the output from this routine.\n *   Let this routine do it for you, as it needs to know one is there\n *   in order to properly deal with any newlines in the actual stream.\n *   Else you will get two where you only should have one.\n */\nzprint.zprint.fzprint_flow_seq = (function zprint$zprint$fzprint_flow_seq(var_args){\nvar G__45726 = arguments.length;\nswitch (G__45726) {\ncase 5:\nreturn zprint.zprint.fzprint_flow_seq.cljs$core$IFn$_invoke$arity$5((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]));\n\nbreak;\ncase 3:\nreturn zprint.zprint.fzprint_flow_seq.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase 4:\nreturn zprint.zprint.fzprint_flow_seq.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\n(zprint.zprint.fzprint_flow_seq.cljs$core$IFn$_invoke$arity$5 = (function (options,ind,zloc_seq,force_nl_QMARK_,nl_first_QMARK_){\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options))){\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),cljs.core.pr_str.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\"fzprint-flow-seq: count zloc-seq:\",cljs.core.count(zloc_seq),\"nl-first?\",nl_first_QMARK_,\"zloc-seq:\",cljs.core.map.cljs$core$IFn$_invoke$arity$2(zprint.zfns.zstring,zloc_seq)], 0))], 0));\n} else {\n}\n\nvar coll_print = zprint.zprint.fzprint_seq(options,ind,zloc_seq);\nvar one_line = cljs.core.apply.cljs$core$IFn$_invoke$arity$2(zprint.zprint.concat_no_nil,cljs.core.interpose.cljs$core$IFn$_invoke$arity$2(new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 4, 5, cljs.core.PersistentVector.EMPTY_NODE, [\" \",new cljs.core.Keyword(null,\"none\",\"none\",1333468478),new cljs.core.Keyword(null,\"whitespace\",\"whitespace\",-1340035483),(8)], null)], null),coll_print));\nvar _ = zprint.zprint.log_lines(options,\"fzprint-flow-seq:\",ind,one_line);\nvar one_line_lines = zprint.zprint.style_lines(options,ind,one_line);\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options))){\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),cljs.core.pr_str.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\"fzprint-flow-seq: coll-print:\",coll_print], 0))], 0));\n} else {\n}\n\nvar value__45260__auto__ = ((((cljs.core.not(force_nl_QMARK_)) && (zprint.zprint.fzfit_one_line(options,one_line_lines))))?one_line:(((!(cljs.core.empty_QMARK_(coll_print))))?cljs.core.apply.cljs$core$IFn$_invoke$arity$2(zprint.zprint.concat_no_nil,(function (){var G__45728 = options;\nvar G__45729 = ind;\nvar G__45730 = coll_print;\nvar G__45731 = cljs.core.not(nl_first_QMARK_);\nreturn (zprint.zprint.precede_w_nl.cljs$core$IFn$_invoke$arity$4 ? zprint.zprint.precede_w_nl.cljs$core$IFn$_invoke$arity$4(G__45728,G__45729,G__45730,G__45731) : zprint.zprint.precede_w_nl.call(null,G__45728,G__45729,G__45730,G__45731));\n})()):new cljs.core.Keyword(null,\"noseq\",\"noseq\",405935768)));\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options))){\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),\"fzprint-flow-seq: exit:\",cljs.core.pr_str.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([value__45260__auto__], 0))], 0));\n} else {\n}\n\nreturn value__45260__auto__;\n}));\n\n(zprint.zprint.fzprint_flow_seq.cljs$core$IFn$_invoke$arity$3 = (function (options,ind,zloc_seq){\nreturn zprint.zprint.fzprint_flow_seq.cljs$core$IFn$_invoke$arity$5(options,ind,zloc_seq,null,null);\n}));\n\n(zprint.zprint.fzprint_flow_seq.cljs$core$IFn$_invoke$arity$4 = (function (options,ind,zloc_seq,force_nl_QMARK_){\nreturn zprint.zprint.fzprint_flow_seq.cljs$core$IFn$_invoke$arity$5(options,ind,zloc_seq,force_nl_QMARK_,null);\n}));\n\n(zprint.zprint.fzprint_flow_seq.cljs$lang$maxFixedArity = 5);\n\n/**\n * Try out the given zloc, and if it fits on the current line, just\n *   do that. It might fit on the same line, as this may not be the rest\n *   of the list that we are printing. If not, check it out with good-enough?\n *   and do the best you can.  Three choices, really: fits on same line, \n *   does ok as hanging, or better with flow. hindent is hang-indent, and \n *   findent is flow-indent, and each contains the initial separator.  \n *   Might be nice if the fn-style actually got sent to this fn.\n */\nzprint.zprint.fzprint_hang_one = (function zprint$zprint$fzprint_hang_one(caller,p__45732,hindent,findent,zloc){\nvar map__45733 = p__45732;\nvar map__45733__$1 = cljs.core.__destructure_map(map__45733);\nvar options = map__45733__$1;\nvar map__45734 = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__45733__$1,caller);\nvar map__45734__$1 = cljs.core.__destructure_map(map__45734);\nvar hang_avoid = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__45734__$1,new cljs.core.Keyword(null,\"hang-avoid\",\"hang-avoid\",-138703568));\nvar one_line_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__45733__$1,new cljs.core.Keyword(null,\"one-line?\",\"one-line?\",2055953111));\nvar width = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__45733__$1,new cljs.core.Keyword(null,\"width\",\"width\",-384071477));\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options))){\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),cljs.core.pr_str.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\"fzprint-hang-one:\",(zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zstring.call(null,zloc)),\" hindent:\",hindent,\"findent:\",findent], 0))], 0));\n} else {\n}\n\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"dbg-hang\",\"dbg-hang\",-1928862076).cljs$core$IFn$_invoke$arity$1(options))){\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([zprint.zprint.dots(new cljs.core.Keyword(null,\"pdepth\",\"pdepth\",-1943862342).cljs$core$IFn$_invoke$arity$1(options)),\"h1 caller:\",caller,(function (){var G__45735 = (cljs.core.truth_((zprint.zfns.zcoll_QMARK_.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zcoll_QMARK_.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zcoll_QMARK_.call(null,zloc)))?(zprint.zfns.zfirst.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zfirst.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zfirst.call(null,zloc)):zloc);\nreturn (zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1(G__45735) : zprint.zfns.zstring.call(null,G__45735));\n})()], 0));\n} else {\n}\n\nvar local_options = ((((cljs.core.not(one_line_QMARK_)) && (cljs.core.not(new cljs.core.Keyword(null,\"hang?\",\"hang?\",-579442854).cljs$core$IFn$_invoke$arity$1((caller.cljs$core$IFn$_invoke$arity$1 ? caller.cljs$core$IFn$_invoke$arity$1(options) : caller.call(null,options)))))))?cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(options,new cljs.core.Keyword(null,\"one-line?\",\"one-line?\",2055953111),true):options);\nvar hindent__$1 = (function (){var or__4212__auto__ = hindent;\nif(cljs.core.truth_(or__4212__auto__)){\nreturn or__4212__auto__;\n} else {\nreturn findent;\n}\n})();\nvar hang_count = (zprint.zfns.zcount.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zcount.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zcount.call(null,zloc));\nvar hanging = ((((cljs.core.not_EQ_.cljs$core$IFn$_invoke$arity$2(hindent__$1,findent)) && (((cljs.core.not(hang_avoid)) || ((hang_count < ((width - hindent__$1) * hang_avoid)))))))?(function (){var G__45736 = zprint.zprint.in_hang(local_options);\nvar G__45737 = hindent__$1;\nvar G__45738 = zloc;\nreturn (zprint.zprint.fzprint_STAR_.cljs$core$IFn$_invoke$arity$3 ? zprint.zprint.fzprint_STAR_.cljs$core$IFn$_invoke$arity$3(G__45736,G__45737,G__45738) : zprint.zprint.fzprint_STAR_.call(null,G__45736,G__45737,G__45738));\n})():null);\nvar hanging__$1 = zprint.zprint.concat_no_nil.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 4, 5, cljs.core.PersistentVector.EMPTY_NODE, [\" \",new cljs.core.Keyword(null,\"none\",\"none\",1333468478),new cljs.core.Keyword(null,\"whitespace\",\"whitespace\",-1340035483),(9)], null)], null),hanging], 0));\nvar _ = zprint.zprint.log_lines(options,\"fzprint-hang-one: hanging:\",(hindent__$1 - (1)),hanging__$1);\nvar hr_lines = zprint.zprint.style_lines(options,(hindent__$1 - (1)),hanging__$1);\n\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options))){\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),\"fzprint-hang-one: hr-lines:\",hr_lines,\"hang-count:\",hang_count], 0));\n} else {\n}\n\nif(cljs.core.truth_((function (){var or__4212__auto__ = zprint.zprint.fzfit_one_line(options,hr_lines);\nif(or__4212__auto__){\nreturn or__4212__auto__;\n} else {\nreturn one_line_QMARK_;\n}\n})())){\nreturn hanging__$1;\n} else {\nvar flow = zprint.zprint.prepend_nl(options,findent,(zprint.zprint.fzprint_STAR_.cljs$core$IFn$_invoke$arity$3 ? zprint.zprint.fzprint_STAR_.cljs$core$IFn$_invoke$arity$3(options,findent,zloc) : zprint.zprint.fzprint_STAR_.call(null,options,findent,zloc)));\nvar ___$1 = zprint.zprint.log_lines(options,\"fzprint-hang-one: flow:\",findent,flow);\nvar fd_lines = zprint.zprint.style_lines(options,findent,flow);\nvar ___$2 = (cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options))?cljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),\"fzprint-hang-one: fd-lines:\",fd_lines], 0)):null);\nvar ___$3 = (cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options))?cljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),\"fzprint-hang-one: ending: hang-count:\",hang_count,\"hanging:\",cljs.core.pr_str.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([hanging__$1], 0)),\"flow:\",cljs.core.pr_str.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([flow], 0))], 0)):null);\nvar hr_good_QMARK_ = (function (){var and__4210__auto__ = new cljs.core.Keyword(null,\"hang?\",\"hang?\",-579442854).cljs$core$IFn$_invoke$arity$1((caller.cljs$core$IFn$_invoke$arity$1 ? caller.cljs$core$IFn$_invoke$arity$1(options) : caller.call(null,options)));\nif(cljs.core.truth_(and__4210__auto__)){\nreturn zprint.zprint.good_enough_QMARK_(caller,options,new cljs.core.Keyword(null,\"none-hang-one\",\"none-hang-one\",-1392848107),hang_count,(hindent__$1 - findent),hr_lines,fd_lines);\n} else {\nreturn and__4210__auto__;\n}\n})();\nif(cljs.core.truth_(hr_good_QMARK_)){\nreturn hanging__$1;\n} else {\nreturn flow;\n}\n}\n});\n/**\n * Given a seq of zlocs, work backwards from the end, and see how\n *   many elements are pairs of constants (using zconstant?).  So that\n *   (... :a (stuff) :b (bother)) returns 4, since both :a and :b are\n *   zconstant? true. This is made more difficult by having to skip\n *   comments along the way as part of the pair check, but keep track\n *   of the ones we skip so the count is right in the end.  We don't\n *   expect any spaces in this but newlines must be handled, because \n *   this seq should have been produced by zmap or its equivalent.\n *   Returns two things: [paired-item-count actual-paired-items],\n *   where paired-item-count is the number of things from the end of\n *   the seq you have to trim off to get the constant pairs included,\n *   and the actual-paired-items is the count of the items to be checked\n *   against the constant-pair-min (which is exclusive of comments and\n *   newlines).\n */\nzprint.zprint.count_constant_pairs = (function zprint$zprint$count_constant_pairs(zloc_seq){\nvar zloc_seq_rev = cljs.core.reverse(zloc_seq);\nvar element_count = (0);\nvar paired_element_count = (0);\nvar constant_required_QMARK_ = null;\nvar pair_size = (0);\nvar actual_pair_size = (0);\nwhile(true){\nvar element = cljs.core.first(zloc_seq_rev);\nif(cljs.core.empty_QMARK_(zloc_seq_rev)){\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [(element_count - pair_size),(paired_element_count - actual_pair_size)], null);\n} else {\nvar comment_or_newline_QMARK_ = (zprint.zprint.zcomment_or_newline_QMARK_.cljs$core$IFn$_invoke$arity$1 ? zprint.zprint.zcomment_or_newline_QMARK_.cljs$core$IFn$_invoke$arity$1(element) : zprint.zprint.zcomment_or_newline_QMARK_.call(null,element));\nif(cljs.core.truth_((function (){var and__4210__auto__ = cljs.core.not(comment_or_newline_QMARK_);\nif(and__4210__auto__){\nvar and__4210__auto____$1 = constant_required_QMARK_;\nif(cljs.core.truth_(and__4210__auto____$1)){\nreturn cljs.core.not((zprint.zfns.zconstant_QMARK_.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zconstant_QMARK_.cljs$core$IFn$_invoke$arity$1(element) : zprint.zfns.zconstant_QMARK_.call(null,element)));\n} else {\nreturn and__4210__auto____$1;\n}\n} else {\nreturn and__4210__auto__;\n}\n})())){\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [(element_count - pair_size),(paired_element_count - actual_pair_size)], null);\n} else {\nvar G__46442 = cljs.core.next(zloc_seq_rev);\nvar G__46443 = (element_count + (1));\nvar G__46444 = (cljs.core.truth_(comment_or_newline_QMARK_)?paired_element_count:(paired_element_count + (1)));\nvar G__46445 = (cljs.core.truth_(comment_or_newline_QMARK_)?constant_required_QMARK_:cljs.core.not(constant_required_QMARK_));\nvar G__46446 = (cljs.core.truth_((function (){var and__4210__auto__ = constant_required_QMARK_;\nif(cljs.core.truth_(and__4210__auto__)){\nreturn cljs.core.not(comment_or_newline_QMARK_);\n} else {\nreturn and__4210__auto__;\n}\n})())?(0):(pair_size + (1)));\nvar G__46447 = (cljs.core.truth_((function (){var and__4210__auto__ = constant_required_QMARK_;\nif(cljs.core.truth_(and__4210__auto__)){\nreturn cljs.core.not(comment_or_newline_QMARK_);\n} else {\nreturn and__4210__auto__;\n}\n})())?(0):(cljs.core.truth_(comment_or_newline_QMARK_)?actual_pair_size:(actual_pair_size + (1))));\nzloc_seq_rev = G__46442;\nelement_count = G__46443;\npaired_element_count = G__46444;\nconstant_required_QMARK_ = G__46445;\npair_size = G__46446;\nactual_pair_size = G__46447;\ncontinue;\n}\n}\nbreak;\n}\n});\n/**\n * Argument is a zloc-seq.  Output is a [pair-seq non-paired-item-count],\n *   if any.  If there are no pair-seqs, pair-seq must be nil, not an\n *   empty seq.  This will largely ignore newlines and comments.\n */\nzprint.zprint.constant_pair = (function zprint$zprint$constant_pair(caller,p__45740,zloc_seq){\nvar map__45741 = p__45740;\nvar map__45741__$1 = cljs.core.__destructure_map(map__45741);\nvar options = map__45741__$1;\nvar map__45742 = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__45741__$1,caller);\nvar map__45742__$1 = cljs.core.__destructure_map(map__45742);\nvar constant_pair_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__45742__$1,new cljs.core.Keyword(null,\"constant-pair?\",\"constant-pair?\",-1009181437));\nvar constant_pair_min = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__45742__$1,new cljs.core.Keyword(null,\"constant-pair-min\",\"constant-pair-min\",1245759721));\nif(cljs.core.truth_(constant_pair_QMARK_)){\nvar vec__45743 = zprint.zprint.count_constant_pairs(zloc_seq);\nvar paired_item_count = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45743,(0),null);\nvar actual_paired_items = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45743,(1),null);\nvar non_paired_item_count = (cljs.core.count(zloc_seq) - paired_item_count);\nvar _ = (cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options))?cljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),\"constant-pair: non-paired-items:\",non_paired_item_count,\"paired-item-count:\",paired_item_count,\"actual-paired-items:\",actual_paired_items], 0)):null);\nvar pair_seq = (((actual_paired_items >= constant_pair_min))?cljs.core.drop.cljs$core$IFn$_invoke$arity$2(non_paired_item_count,zloc_seq):null);\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [pair_seq,non_paired_item_count], null);\n} else {\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [null,cljs.core.count(zloc_seq)], null);\n}\n});\n/**\n * If this zloc is a comment or a newline, return true.\n */\nzprint.zprint.zcomment_or_newline_QMARK_ = (function zprint$zprint$zcomment_or_newline_QMARK_(zloc){\nvar or__4212__auto__ = (zprint.zfns.zcomment_QMARK_.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zcomment_QMARK_.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zcomment_QMARK_.call(null,zloc));\nif(cljs.core.truth_(or__4212__auto__)){\nreturn or__4212__auto__;\n} else {\nreturn (zprint.zfns.znewline_QMARK_.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.znewline_QMARK_.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.znewline_QMARK_.call(null,zloc));\n}\n});\n/**\n * Given a style-vec, ensure it starts with a newline.  If it doesn't,\n *   then put one in.  We could take the whole newline, but the indent is\n *   really the only unique thing.\n */\nzprint.zprint.ensure_start_w_nl = (function zprint$zprint$ensure_start_w_nl(ind,style_vec){\nvar element_type = cljs.core.nth.cljs$core$IFn$_invoke$arity$2(cljs.core.first(style_vec),(2));\nif(((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(element_type,new cljs.core.Keyword(null,\"newline\",\"newline\",1790071323))) || (cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(element_type,new cljs.core.Keyword(null,\"indent\",\"indent\",-148200125))))){\nreturn style_vec;\n} else {\nreturn zprint.zprint.concat_no_nil.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 4, 5, cljs.core.PersistentVector.EMPTY_NODE, [[\"\\n\",cljs.core.str.cljs$core$IFn$_invoke$arity$1(zprint.zprint.blanks(ind))].join(''),new cljs.core.Keyword(null,\"none\",\"none\",1333468478),new cljs.core.Keyword(null,\"indent\",\"indent\",-148200125),(6)], null)], null),style_vec], 0));\n}\n});\n/**\n * Given a style-vec, ensure it ends with a newline.  If it doesn't,\n *   then put one in.\n */\nzprint.zprint.ensure_end_w_nl = (function zprint$zprint$ensure_end_w_nl(ind,style_vec){\nvar element_type = cljs.core.nth.cljs$core$IFn$_invoke$arity$2(cljs.core.last(style_vec),(2));\nif(((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(element_type,new cljs.core.Keyword(null,\"newline\",\"newline\",1790071323))) || (cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(element_type,new cljs.core.Keyword(null,\"indent\",\"indent\",-148200125))))){\nreturn style_vec;\n} else {\nreturn zprint.zprint.concat_no_nil.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([style_vec,new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 4, 5, cljs.core.PersistentVector.EMPTY_NODE, [[\"\\n\",cljs.core.str.cljs$core$IFn$_invoke$arity$1(zprint.zprint.blanks(ind))].join(''),new cljs.core.Keyword(null,\"none\",\"none\",1333468478),new cljs.core.Keyword(null,\"indent\",\"indent\",-148200125),(7)], null)], null)], 0));\n}\n});\n/**\n * zloc-seq is a seq of zlocs of a collection.  We already know\n *   that the given zloc won't fit on the current line. [Besides, we\n *   ensure that if there are two things remaining anyway. ???] So\n *   now, try hanging and see if that is better than flow.  Unless\n *   :hang? is nil, in which case we will just flow.  hindent is\n *   hang-indent, and findent is flow-indent. This should never be\n *   called with :one-line because this is only called from fzprint-list*\n *   after the one-line processing is done. If the hindent equals the\n *   flow indent, then just do flow.  Do only zloc-count non-whitespace\n *   elements of zloc-seq if it exists.\n */\nzprint.zprint.fzprint_hang_remaining = (function zprint$zprint$fzprint_hang_remaining(var_args){\nvar G__45747 = arguments.length;\nswitch (G__45747) {\ncase 7:\nreturn zprint.zprint.fzprint_hang_remaining.cljs$core$IFn$_invoke$arity$7((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]),(arguments[(5)]),(arguments[(6)]));\n\nbreak;\ncase 6:\nreturn zprint.zprint.fzprint_hang_remaining.cljs$core$IFn$_invoke$arity$6((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]),(arguments[(5)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\n(zprint.zprint.fzprint_hang_remaining.cljs$core$IFn$_invoke$arity$7 = (function (caller,p__45748,hindent,findent,zloc_seq,fn_style,zloc_count){\nvar map__45749 = p__45748;\nvar map__45749__$1 = cljs.core.__destructure_map(map__45749);\nvar options = map__45749__$1;\nvar map__45750 = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__45749__$1,caller);\nvar map__45750__$1 = cljs.core.__destructure_map(map__45750);\nvar hang_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__45750__$1,new cljs.core.Keyword(null,\"hang?\",\"hang?\",-579442854));\nvar constant_pair_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__45750__$1,new cljs.core.Keyword(null,\"constant-pair?\",\"constant-pair?\",-1009181437));\nvar constant_pair_min = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__45750__$1,new cljs.core.Keyword(null,\"constant-pair-min\",\"constant-pair-min\",1245759721));\nvar hang_avoid = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__45750__$1,new cljs.core.Keyword(null,\"hang-avoid\",\"hang-avoid\",-138703568));\nvar hang_expand = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__45750__$1,new cljs.core.Keyword(null,\"hang-expand\",\"hang-expand\",1086807559));\nvar hang_diff = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__45750__$1,new cljs.core.Keyword(null,\"hang-diff\",\"hang-diff\",-1575205424));\nvar nl_separator_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__45750__$1,new cljs.core.Keyword(null,\"nl-separator?\",\"nl-separator?\",-758068767));\nvar respect_nl_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__45750__$1,new cljs.core.Keyword(null,\"respect-nl?\",\"respect-nl?\",604814635));\nvar dbg_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__45749__$1,new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771));\nvar width = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__45749__$1,new cljs.core.Keyword(null,\"width\",\"width\",-384071477));\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"dbg-hang\",\"dbg-hang\",-1928862076).cljs$core$IFn$_invoke$arity$1(options))){\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([zprint.zprint.dots(new cljs.core.Keyword(null,\"pdepth\",\"pdepth\",-1943862342).cljs$core$IFn$_invoke$arity$1(options)),\"hr:\",(function (){var G__45751 = cljs.core.first(zloc_seq);\nreturn (zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1(G__45751) : zprint.zfns.zstring.call(null,G__45751));\n})()], 0));\n} else {\n}\n\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options))){\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),cljs.core.pr_str.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\"fzprint-hang-remaining first:\",(function (){var G__45752 = cljs.core.first(zloc_seq);\nreturn (zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1(G__45752) : zprint.zfns.zstring.call(null,G__45752));\n})(),\"hindent:\",hindent,\"findent:\",findent,\"caller:\",caller,\"nl-separator?:\",nl_separator_QMARK_,\"(count zloc-seq):\",cljs.core.count(zloc_seq)], 0))], 0));\n} else {\n}\n\nvar seq_right = zloc_seq;\nvar seq_right__$1 = (cljs.core.truth_(zloc_count)?cljs.core.take.cljs$core$IFn$_invoke$arity$2(zloc_count,seq_right):seq_right);\nvar vec__45753 = zprint.zprint.constant_pair(caller,options,seq_right__$1);\nvar pair_seq = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45753,(0),null);\nvar non_paired_item_count = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45753,(1),null);\nvar _ = (cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options))?cljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),\"fzprint-hang-remaining count pair-seq:\",cljs.core.count(pair_seq)], 0)):null);\nvar ___$1 = (cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options))?cljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),\"fzprint-hang-remaining: first hang?\",hang_QMARK_,\"hang-avoid\",hang_avoid,\"findent:\",findent,\"hindent:\",hindent,\"(count seq-right):\",cljs.core.count(seq_right__$1),\"thing:\",(cljs.core.truth_(hang_avoid)?((width - hindent) * hang_avoid):null)], 0)):null);\nvar hang_QMARK___$1 = (function (){var and__4210__auto__ = hang_QMARK_;\nif(cljs.core.truth_(and__4210__auto__)){\nreturn ((cljs.core.not_EQ_.cljs$core$IFn$_invoke$arity$2(hindent,findent)) && (((cljs.core.not(hang_avoid)) || ((cljs.core.count(seq_right__$1) < ((width - hindent) * hang_avoid))))));\n} else {\nreturn and__4210__auto__;\n}\n})();\nvar ___$2 = (cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options))?cljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),\"fzprint-hang-remaining: second hang?\",hang_QMARK___$1], 0)):null);\nvar hanging = (function (){var hang_result = (cljs.core.truth_(hang_QMARK___$1)?((cljs.core.not(pair_seq))?zprint.zprint.fzprint_flow_seq.cljs$core$IFn$_invoke$arity$5(zprint.zprint.in_hang(options),hindent,seq_right__$1,new cljs.core.Keyword(null,\"force-nl\",\"force-nl\",-755040826),null):(((!((non_paired_item_count === (0)))))?zprint.zprint.concat_no_nil.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([(function (){var value__45260__auto__ = zprint.zprint.ensure_end_w_nl(hindent,zprint.zprint.fzprint_flow_seq.cljs$core$IFn$_invoke$arity$5(zprint.zprint.not_rightmost(zprint.zprint.in_hang(options)),hindent,cljs.core.take.cljs$core$IFn$_invoke$arity$2(non_paired_item_count,seq_right__$1),new cljs.core.Keyword(null,\"force-nl\",\"force-nl\",-755040826),null));\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options))){\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),\"fzprint-hang-remaining: mapv:\",cljs.core.pr_str.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([value__45260__auto__], 0))], 0));\n} else {\n}\n\nreturn value__45260__auto__;\n})(),(function (){var value__45260__auto__ = zprint.zprint.fzprint_pairs(zprint.zprint.in_hang(options),hindent,pair_seq);\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options))){\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),\"fzprint-hang-remaining: fzprint-hang:\",cljs.core.pr_str.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([value__45260__auto__], 0))], 0));\n} else {\n}\n\nreturn value__45260__auto__;\n})()], 0)):zprint.zprint.fzprint_pairs(zprint.zprint.in_hang(options),hindent,pair_seq))):null);\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [hang_result,zprint.zprint.style_lines(options,hindent,hang_result)], null);\n})();\nvar vec__45756 = zprint.zprint.zat(options,hanging);\nvar hanging__$1 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45756,(0),null);\nvar vec__45759 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45756,(1),null);\nvar hanging_line_count = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45759,(0),null);\nvar hanging_lines = vec__45759;\nvar hang_count = cljs.core.count(seq_right__$1);\nvar flow_QMARK_ = cljs.core.not(zprint.zprint.use_hang_QMARK_(caller,options,hindent,hang_count,hanging_line_count));\nvar flow = ((flow_QMARK_)?(function (){var flow_result = ((cljs.core.not(pair_seq))?zprint.zprint.fzprint_flow_seq.cljs$core$IFn$_invoke$arity$5(options,findent,seq_right__$1,new cljs.core.Keyword(null,\"force-nl\",\"force-nl\",-755040826),new cljs.core.Keyword(null,\"nl-first\",\"nl-first\",-462968863)):(((!((non_paired_item_count === (0)))))?zprint.zprint.concat_no_nil.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([zprint.zprint.ensure_end_w_nl(findent,zprint.zprint.fzprint_flow_seq.cljs$core$IFn$_invoke$arity$5(zprint.zprint.not_rightmost(options),findent,cljs.core.take.cljs$core$IFn$_invoke$arity$2(non_paired_item_count,seq_right__$1),new cljs.core.Keyword(null,\"force-nl\",\"force-nl\",-755040826),new cljs.core.Keyword(null,\"nl-first\",\"nl-first\",-462968863))),zprint.zprint.fzprint_pairs(options,findent,pair_seq)], 0)):zprint.zprint.fzprint_pairs(options,findent,pair_seq)));\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [flow_result,zprint.zprint.style_lines(options,findent,((cljs.core.not(pair_seq))?cljs.core.next(flow_result):flow_result))], null);\n})():null);\nvar vec__45762 = (cljs.core.truth_(flow)?zprint.zprint.zat(options,flow):null);\nvar flow__$1 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45762,(0),null);\nvar flow_lines = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45762,(1),null);\nvar ___$3 = zprint.zprint.log_lines(options,\"fzprint-hang-remaining: hanging:\",hindent,hanging__$1);\nvar ___$4 = (cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options))?cljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),\"fzprint-hang-remaining: hanging-lines:\",hanging_lines,\"hang-count:\",hang_count], 0)):null);\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options))){\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),\"fzprint-hang-remaining: flow-lines:\",flow_lines], 0));\n} else {\n}\n\nif(cljs.core.truth_(dbg_QMARK_)){\nif((hang_count === (0))){\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\"hang-count = 0:\",cljs.core.str.cljs$core$IFn$_invoke$arity$1(cljs.core.map.cljs$core$IFn$_invoke$arity$2(zprint.zfns.zstring,zloc_seq))], 0));\n} else {\n}\n} else {\n}\n\nzprint.zprint.log_lines(options,\"fzprint-hang-remaining: flow\",findent,flow__$1);\n\nif(cljs.core.truth_((function (){var and__4210__auto__ = hanging_lines;\nif(cljs.core.truth_(and__4210__auto__)){\nreturn cljs.core.not(flow_lines);\n} else {\nreturn and__4210__auto__;\n}\n})())){\nif(zprint.zprint.first_nl_QMARK_(hanging__$1)){\nreturn hanging__$1;\n} else {\nreturn zprint.zprint.concat_no_nil.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 4, 5, cljs.core.PersistentVector.EMPTY_NODE, [\" \",new cljs.core.Keyword(null,\"none\",\"none\",1333468478),new cljs.core.Keyword(null,\"whitespace\",\"whitespace\",-1340035483),(10)], null)], null),hanging__$1], 0));\n}\n} else {\nif(cljs.core.truth_(flow_lines)){\nif(cljs.core.truth_(zprint.zprint.good_enough_QMARK_(caller,options,fn_style,hang_count,(hindent - findent),hanging_lines,flow_lines))){\nif(zprint.zprint.first_nl_QMARK_(hanging__$1)){\nreturn hanging__$1;\n} else {\nreturn zprint.zprint.concat_no_nil.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 4, 5, cljs.core.PersistentVector.EMPTY_NODE, [\" \",new cljs.core.Keyword(null,\"none\",\"none\",1333468478),new cljs.core.Keyword(null,\"whitespace\",\"whitespace\",-1340035483),(10)], null)], null),hanging__$1], 0));\n}\n} else {\nreturn zprint.zprint.ensure_start_w_nl(findent,flow__$1);\n}\n} else {\nreturn null;\n}\n}\n}));\n\n(zprint.zprint.fzprint_hang_remaining.cljs$core$IFn$_invoke$arity$6 = (function (caller,options,hindent,findent,zloc,fn_style){\nreturn zprint.zprint.fzprint_hang_remaining.cljs$core$IFn$_invoke$arity$7(caller,options,hindent,findent,zloc,fn_style,null);\n}));\n\n(zprint.zprint.fzprint_hang_remaining.cljs$lang$maxFixedArity = 7);\n\n/**\n * Get the zloc seq, with or without newlines, as indicated by the options.\n */\nzprint.zprint.fzprint_get_zloc_seq = (function zprint$zprint$fzprint_get_zloc_seq(caller,options,zloc){\nvar caller_options = (caller.cljs$core$IFn$_invoke$arity$1 ? caller.cljs$core$IFn$_invoke$arity$1(options) : caller.call(null,options));\nvar zloc_seq = (cljs.core.truth_(new cljs.core.Keyword(null,\"respect-nl?\",\"respect-nl?\",604814635).cljs$core$IFn$_invoke$arity$1(caller_options))?(zprint.zfns.zmap_w_nl.cljs$core$IFn$_invoke$arity$2 ? zprint.zfns.zmap_w_nl.cljs$core$IFn$_invoke$arity$2(cljs.core.identity,zloc) : zprint.zfns.zmap_w_nl.call(null,cljs.core.identity,zloc)):(cljs.core.truth_(new cljs.core.Keyword(null,\"respect-bl?\",\"respect-bl?\",298921998).cljs$core$IFn$_invoke$arity$1(caller_options))?(zprint.zfns.zmap_w_bl.cljs$core$IFn$_invoke$arity$2 ? zprint.zfns.zmap_w_bl.cljs$core$IFn$_invoke$arity$2(cljs.core.identity,zloc) : zprint.zfns.zmap_w_bl.call(null,cljs.core.identity,zloc)):(zprint.zfns.zmap.cljs$core$IFn$_invoke$arity$2 ? zprint.zfns.zmap.cljs$core$IFn$_invoke$arity$2(cljs.core.identity,zloc) : zprint.zfns.zmap.call(null,cljs.core.identity,zloc))\n));\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options))){\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),cljs.core.pr_str.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\"fzprint-get-zloc-seq:\",cljs.core.map.cljs$core$IFn$_invoke$arity$2(zprint.zfns.zstring,zloc_seq)], 0))], 0));\n} else {\n}\n\nreturn zloc_seq;\n});\n/**\n * Given an zloc, is it a newline or a comment?\n */\nzprint.zprint.newline_or_comment_QMARK_ = (function zprint$zprint$newline_or_comment_QMARK_(zloc){\nif(cljs.core.truth_(zloc)){\nvar zloc_tag = (zprint.zfns.ztag.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.ztag.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.ztag.call(null,zloc));\nreturn ((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(zloc_tag,new cljs.core.Keyword(null,\"newline\",\"newline\",1790071323))) || (cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(zloc_tag,new cljs.core.Keyword(null,\"comment\",\"comment\",532206069))));\n} else {\nreturn null;\n}\n});\n/**\n * Given a seq of style-vecs, look at the last one, and if it is a\n *   :newline, then remove it.  But the last one might be a single\n *   one, in which case we will remove the whole thing, and it might be\n *   the last one in a sequence, in which case we will remove just that\n *   one.  If there is nothing left, return [[[\"\" :none :none]]].\n */\nzprint.zprint.remove_last_newline = (function zprint$zprint$remove_last_newline(ssv){\nvar last_style_vec = cljs.core.last(ssv);\nif((!(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(cljs.core.nth.cljs$core$IFn$_invoke$arity$2(cljs.core.last(last_style_vec),(2)),new cljs.core.Keyword(null,\"newline\",\"newline\",1790071323))))){\nreturn ssv;\n} else {\nvar last_len = cljs.core.count(last_style_vec);\nvar total_len = cljs.core.count(ssv);\nvar remove_one = cljs.core.concat.cljs$core$IFn$_invoke$arity$2(cljs.core.butlast(ssv),((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(last_len,(1)))?cljs.core.PersistentVector.EMPTY:(new cljs.core.PersistentVector(null,1,(5),cljs.core.PersistentVector.EMPTY_NODE,[cljs.core.butlast(last_style_vec)],null))));\nif(cljs.core.empty_QMARK_(remove_one)){\nreturn new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [\"\",new cljs.core.Keyword(null,\"none\",\"none\",1333468478),new cljs.core.Keyword(null,\"none\",\"none\",1333468478)], null)], null)], null);\n} else {\nreturn remove_one;\n}\n}\n});\n/**\n * Given a single style-vec, look at the last element, and if it is a\n *   :newline, remove it.  If there is nothing left, return :noseq\n */\nzprint.zprint.remove_one_newline = (function zprint$zprint$remove_one_newline(style_vec){\nvar last_style_vec = cljs.core.last(style_vec);\nif((!(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(cljs.core.nth.cljs$core$IFn$_invoke$arity$2(last_style_vec,(2)),new cljs.core.Keyword(null,\"newline\",\"newline\",1790071323))))){\nreturn style_vec;\n} else {\nvar remaining = cljs.core.butlast(style_vec);\nif(cljs.core.empty_QMARK_(remaining)){\nreturn new cljs.core.Keyword(null,\"noseq\",\"noseq\",405935768);\n} else {\nreturn remaining;\n}\n}\n});\n/**\n * Given [[[\";stuff\" :none :comment]]] or \n *   [[[\";bother\" :none :comment-inline 1]]] add [\"\n * \" :none :newline]\n *   to the inside of it.\n */\nzprint.zprint.add_newline_to_comment = (function zprint$zprint$add_newline_to_comment(indent,fzprint_STAR__return){\nvar the_type = cljs.core.nth.cljs$core$IFn$_invoke$arity$2(cljs.core.first(fzprint_STAR__return),(2));\nif(((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(the_type,new cljs.core.Keyword(null,\"comment\",\"comment\",532206069))) || (cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(the_type,new cljs.core.Keyword(null,\"comment-inline\",\"comment-inline\",712944405))))){\nreturn cljs.core.concat.cljs$core$IFn$_invoke$arity$2(fzprint_STAR__return,new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 4, 5, cljs.core.PersistentVector.EMPTY_NODE, [[\"\\n\",cljs.core.str.cljs$core$IFn$_invoke$arity$1(zprint.zprint.blanks(indent))].join(''),new cljs.core.Keyword(null,\"none\",\"none\",1333468478),new cljs.core.Keyword(null,\"newline\",\"newline\",1790071323),(1)], null)], null));\n} else {\nreturn fzprint_STAR__return;\n}\n});\n/**\n * Given a zloc-seq, gather newlines and comments up to the next\n *   zloc into a seq.  Returns [seq next-zloc next-count].\n */\nzprint.zprint.gather_up_to_next_zloc = (function zprint$zprint$gather_up_to_next_zloc(zloc_seq){\nvar nloc_seq = zloc_seq;\nvar out = cljs.core.PersistentVector.EMPTY;\nvar next_count = (0);\nwhile(true){\nif(cljs.core.not(zprint.zprint.newline_or_comment_QMARK_(cljs.core.first(nloc_seq)))){\nreturn new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [out,cljs.core.first(nloc_seq),next_count], null);\n} else {\nvar G__46470 = cljs.core.next(nloc_seq);\nvar G__46471 = cljs.core.conj.cljs$core$IFn$_invoke$arity$2(out,cljs.core.first(nloc_seq));\nvar G__46472 = (next_count + (1));\nnloc_seq = G__46470;\nout = G__46471;\nnext_count = G__46472;\ncontinue;\n}\nbreak;\n}\n});\n/**\n * Using the information returned from fzprint-up-to-first-zloc or\n *   fzprint-up-to-next-zloc, find the next zloc and return \n *   [pre-next-style-vec next-zloc next-count zloc-seq]\n */\nzprint.zprint.fzprint_up_to_next_zloc = (function zprint$zprint$fzprint_up_to_next_zloc(caller,options,ind,p__45766){\nvar vec__45767 = p__45766;\nvar _ = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45767,(0),null);\nvar ___$1 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45767,(1),null);\nvar current_count = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45767,(2),null);\nvar zloc_seq = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45767,(3),null);\nvar next_data = vec__45767;\nvar starting_count = (current_count + (1));\nvar nloc_seq = cljs.core.nthnext(zloc_seq,starting_count);\nif((!(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(new cljs.core.Keyword(null,\"ztype\",\"ztype\",-562179020).cljs$core$IFn$_invoke$arity$1(options),new cljs.core.Keyword(null,\"zipper\",\"zipper\",1500694438))))){\nreturn new cljs.core.PersistentVector(null, 4, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,\"noseq\",\"noseq\",405935768),cljs.core.first(nloc_seq),starting_count,zloc_seq], null);\n} else {\nvar vec__45770 = zprint.zprint.gather_up_to_next_zloc(nloc_seq);\nvar pre_next_zloc_seq = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45770,(0),null);\nvar next_zloc = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45770,(1),null);\nvar next_count = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45770,(2),null);\nvar next_count__$1 = (starting_count + next_count);\nif(cljs.core.empty_QMARK_(pre_next_zloc_seq)){\nreturn new cljs.core.PersistentVector(null, 4, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,\"noseq\",\"noseq\",405935768),next_zloc,next_count__$1,zloc_seq], null);\n} else {\nvar coll_print = zprint.zprint.fzprint_flow_seq.cljs$core$IFn$_invoke$arity$3(options,ind,pre_next_zloc_seq);\nvar coll_print__$1 = cljs.core.mapv.cljs$core$IFn$_invoke$arity$2(cljs.core.vector,coll_print);\nvar coll_print__$2 = ((cljs.core.not_EQ_.cljs$core$IFn$_invoke$arity$2(starting_count,(0)))?zprint.zprint.remove_last_newline(coll_print__$1):coll_print__$1);\nvar coll_out = cljs.core.apply.cljs$core$IFn$_invoke$arity$2(zprint.zprint.concat_no_nil,coll_print__$2);\nvar coll_out__$1 = (((function (){var and__4210__auto__ = cljs.core.not_EQ_.cljs$core$IFn$_invoke$arity$2(starting_count,(0));\nif(and__4210__auto__){\nvar first_type = cljs.core.nth.cljs$core$IFn$_invoke$arity$2(cljs.core.first(coll_out),(2));\nreturn ((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(first_type,new cljs.core.Keyword(null,\"comment\",\"comment\",532206069))) || (cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(first_type,new cljs.core.Keyword(null,\"comment-inline\",\"comment-inline\",712944405))));\n} else {\nreturn and__4210__auto__;\n}\n})())?zprint.zprint.ensure_start_w_nl(ind,coll_out):coll_out);\nvar coll_out__$2 = ((cljs.core.not_EQ_.cljs$core$IFn$_invoke$arity$2(starting_count,(0)))?coll_out__$1:zprint.zprint.ensure_end_w_nl(ind,coll_out__$1));\nreturn new cljs.core.PersistentVector(null, 4, 5, cljs.core.PersistentVector.EMPTY_NODE, [coll_out__$2,next_zloc,next_count__$1,zloc_seq], null);\n}\n}\n});\n/**\n * Returns [pre-first-style-vec first-zloc first-count zloc-seq], where\n *   pre-first-style-vec will be :noseq if there isn't anything, and first-count\n *   is what you give to nthnext to get to the first-zloc in zloc-seq.\n */\nzprint.zprint.fzprint_up_to_first_zloc = (function zprint$zprint$fzprint_up_to_first_zloc(caller,options,ind,zloc){\nif((!(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(new cljs.core.Keyword(null,\"ztype\",\"ztype\",-562179020).cljs$core$IFn$_invoke$arity$1(options),new cljs.core.Keyword(null,\"zipper\",\"zipper\",1500694438))))){\nreturn new cljs.core.PersistentVector(null, 4, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,\"noseq\",\"noseq\",405935768),cljs.core.first(zloc),(0),zloc], null);\n} else {\nvar zloc_seq = zprint.zprint.fzprint_get_zloc_seq(caller,options,zloc);\nreturn zprint.zprint.fzprint_up_to_next_zloc(caller,options,ind,new cljs.core.PersistentVector(null, 4, 5, cljs.core.PersistentVector.EMPTY_NODE, [null,null,(-1),zloc_seq], null));\n}\n});\n/**\n * Using return from fzprint-up-to-first-zloc or fzprint-up-to-next-zloc,\n *   [pre-next-style-vec next-zloc next-count zloc-seq], return a zloc-seq\n *   pointer to just beyond the specific zloc which was found by the\n *   fzprint-up-to-first or fzprint-up-to-next call.  You don't give this\n *   a number, you give it the data structure from the thing that you found.\n */\nzprint.zprint.get_zloc_seq_right = (function zprint$zprint$get_zloc_seq_right(p__45773){\nvar vec__45774 = p__45773;\nvar _ = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45774,(0),null);\nvar ___$1 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45774,(1),null);\nvar next_count = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45774,(2),null);\nvar zloc_seq = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45774,(3),null);\nvar input_data = vec__45774;\nif((next_count >= cljs.core.count(zloc_seq))){\nthrow (new Error([\"get-zloc-seq-right input data inconsistent:\",cljs.core.str.cljs$core$IFn$_invoke$arity$1(input_data)].join('')));\n} else {\nvar zloc_seq__$1 = cljs.core.nthnext(zloc_seq,(next_count + (1)));\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(\"get-zloc-seq-right:\"))){\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(\"get-zloc-seq-right:\"),cljs.core.pr_str.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([cljs.core.map.cljs$core$IFn$_invoke$arity$2(zprint.zfns.zstring,zloc_seq__$1)], 0))], 0));\n} else {\n}\n\nreturn zloc_seq__$1;\n}\n});\n/**\n * Is this a newline or equivalent?  Comments and newlines are both\n *   newlines for the purposed of this routine.\n */\nzprint.zprint.at_newline_QMARK_ = (function zprint$zprint$at_newline_QMARK_(zloc){\nvar this_tag = (zprint.zfns.ztag.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.ztag.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.ztag.call(null,zloc));\nreturn ((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(this_tag,new cljs.core.Keyword(null,\"comment\",\"comment\",532206069))) || (cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(this_tag,new cljs.core.Keyword(null,\"newline\",\"newline\",1790071323))));\n});\n/**\n * Given a zloc that is down inside of a collection, presumably\n *   a list, return a vector containing the number of printing elements\n *   we had to traverse to get to it as well as the newline.\n */\nzprint.zprint.next_newline = (function zprint$zprint$next_newline(zloc){\nvar nloc = zloc;\nvar index = (0);\nwhile(true){\nvar next_right = (zprint.zutil.right_STAR_.cljs$core$IFn$_invoke$arity$1 ? zprint.zutil.right_STAR_.cljs$core$IFn$_invoke$arity$1(nloc) : zprint.zutil.right_STAR_.call(null,nloc));\nif(cljs.core.truth_(next_right)){\nif(zprint.zprint.at_newline_QMARK_(nloc)){\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [index,nloc], null);\n} else {\nvar G__46479 = (zprint.zutil.right_STAR_.cljs$core$IFn$_invoke$arity$1 ? zprint.zutil.right_STAR_.cljs$core$IFn$_invoke$arity$1(nloc) : zprint.zutil.right_STAR_.call(null,nloc));\nvar G__46480 = (((!(zprint.zutil.whitespace_QMARK_(nloc))))?(index + (1)):index);\nnloc = G__46479;\nindex = G__46480;\ncontinue;\n}\n} else {\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [index,nloc], null);\n}\nbreak;\n}\n});\n/**\n * Given a string, return the number of characters to the right\n *   of any newlines in the string.  Will return nil if no newlines\n *   in the string.\n */\nzprint.zprint.length_after_newline = (function zprint$zprint$length_after_newline(s){\nvar nl_split = clojure.string.split.cljs$core$IFn$_invoke$arity$2([cljs.core.str.cljs$core$IFn$_invoke$arity$1(s),\" \"].join(''),/\\n/);\nvar nl_num = (cljs.core.count(nl_split) - (1));\nif((nl_num === (0))){\nreturn null;\n} else {\nreturn (cljs.core.count(cljs.core.last(nl_split)) - (1));\n}\n});\n/**\n * Given a tag into which you can go down from rewrite-clj, which must be\n *   a collection of some kind, return the size the l-str.  All of the tag\n *   values into which you can go down must be in this list for indent-before\n *   to work correctly.  It uses these values when it steps up out of one of\n *   these things to see how big the thing would have been if it showed up\n *   as characters.\n */\nzprint.zprint.tag_l_size = (function zprint$zprint$tag_l_size(t){\nvar G__45777 = t;\nvar G__45777__$1 = (((G__45777 instanceof cljs.core.Keyword))?G__45777.fqn:null);\nswitch (G__45777__$1) {\ncase \"list\":\nreturn (1);\n\nbreak;\ncase \"vector\":\nreturn (1);\n\nbreak;\ncase \"set\":\nreturn (2);\n\nbreak;\ncase \"map\":\nreturn (1);\n\nbreak;\ncase \"uneval\":\nreturn (2);\n\nbreak;\ncase \"reader-macro\":\nreturn (1);\n\nbreak;\ncase \"meta\":\nreturn (1);\n\nbreak;\ncase \"quote\":\nreturn (1);\n\nbreak;\ncase \"syntax-quote\":\nreturn (1);\n\nbreak;\ncase \"fn\":\nreturn (2);\n\nbreak;\ncase \"unquote\":\nreturn (1);\n\nbreak;\ncase \"deref\":\nreturn (1);\n\nbreak;\ncase \"namespaced-map\":\nreturn (1);\n\nbreak;\ndefault:\nreturn (0);\n\n}\n});\n/**\n * Take a zloc and move left if possible, or move up if necessary.\n *   Return a vector with [up-size new-zloc]\n */\nzprint.zprint.left_or_up = (function zprint$zprint$left_or_up(zloc){\nvar ploc = zloc;\nvar total_up = (0);\nwhile(true){\nvar next_left = (zprint.zutil.left_STAR_.cljs$core$IFn$_invoke$arity$1 ? zprint.zutil.left_STAR_.cljs$core$IFn$_invoke$arity$1(ploc) : zprint.zutil.left_STAR_.call(null,ploc));\nif(cljs.core.truth_(next_left)){\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [total_up,next_left], null);\n} else {\nvar moving_up = (zprint.zutil.up_STAR_.cljs$core$IFn$_invoke$arity$1 ? zprint.zutil.up_STAR_.cljs$core$IFn$_invoke$arity$1(ploc) : zprint.zutil.up_STAR_.call(null,ploc));\nvar up_tag = (cljs.core.truth_(moving_up)?(zprint.zutil.tag.cljs$core$IFn$_invoke$arity$1 ? zprint.zutil.tag.cljs$core$IFn$_invoke$arity$1(moving_up) : zprint.zutil.tag.call(null,moving_up)):null);\nvar up_size = zprint.zprint.tag_l_size(up_tag);\nif(cljs.core.not(moving_up)){\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [total_up,null], null);\n} else {\nvar G__46487 = moving_up;\nvar G__46488 = (total_up + up_size);\nploc = G__46487;\ntotal_up = G__46488;\ncontinue;\n}\n}\nbreak;\n}\n});\n/**\n * Given a zloc, find the amount of printing space before it on its\n *   current line.\n */\nzprint.zprint.length_before = (function zprint$zprint$length_before(zloc){\nvar vec__45778 = zprint.zprint.left_or_up(zloc);\nvar up_size = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45778,(0),null);\nvar next_zloc = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45778,(1),null);\nvar ploc = next_zloc;\nvar indent_before = up_size;\nwhile(true){\nif(cljs.core.not(ploc)){\nreturn indent_before;\n} else {\nvar zstr = (cljs.core.truth_(ploc)?(zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1(ploc) : zprint.zfns.zstring.call(null,ploc)):\"\");\nvar length_right_of_newline = zprint.zprint.length_after_newline(zstr);\nvar vec__45784 = zprint.zprint.left_or_up(ploc);\nvar up_size__$1 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45784,(0),null);\nvar next_zloc__$1 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45784,(1),null);\nif(cljs.core.truth_(length_right_of_newline)){\nreturn (length_right_of_newline + indent_before);\n} else {\nvar G__46489 = next_zloc__$1;\nvar G__46490 = ((indent_before + cljs.core.count(zstr)) + up_size__$1);\nploc = G__46489;\nindent_before = G__46490;\ncontinue;\n}\n}\nbreak;\n}\n});\n/**\n * Return the next actual element, ignoring comments and whitespace\n *   and everything else but real elements.\n */\nzprint.zprint.next_actual = (function zprint$zprint$next_actual(zloc){\nvar nloc = zloc;\nwhile(true){\nif(cljs.core.not(nloc)){\nreturn nloc;\n} else {\nvar next_nloc = zprint.zutil.zrightnws(nloc);\nvar next_tag = (zprint.zutil.tag.cljs$core$IFn$_invoke$arity$1 ? zprint.zutil.tag.cljs$core$IFn$_invoke$arity$1(next_nloc) : zprint.zutil.tag.call(null,next_nloc));\nif((!(((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(next_tag,new cljs.core.Keyword(null,\"newline\",\"newline\",1790071323))) || (cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(next_tag,new cljs.core.Keyword(null,\"comment\",\"comment\",532206069))))))){\nreturn next_nloc;\n} else {\nvar G__46491 = next_nloc;\nnloc = G__46491;\ncontinue;\n}\n}\nbreak;\n}\n});\n/**\n * Return the first actual element, ignoring comments and whitespace\n *   and everything else but real elements.\n */\nzprint.zprint.first_actual = (function zprint$zprint$first_actual(zloc){\nif(zprint.zprint.at_newline_QMARK_(zloc)){\nreturn zprint.zprint.next_actual(zloc);\n} else {\nreturn zloc;\n}\n});\n/**\n * Should we hang this zloc, or flow it.  We assume that we are at\n *   the start of the collection (though this could be generalized to\n *   deal with other starting locations easily enough).  Return true\n *   if we should hang it based just on the information in the zloc\n *   itself.  The criteria are: If there is a newline after the second\n *   thing in the zloc, and the amount of space prior to the third thing\n *   is the same as the amount of space prior to the second thing, then\n *   the incoming zloc was hung and we should do the same. Of course, it\n *   would also only be hung if the second thing was on the same line as\n *   the first thing.\n */\nzprint.zprint.hang_zloc_QMARK_ = (function zprint$zprint$hang_zloc_QMARK_(zloc){\nvar zloc__$1 = zprint.zprint.first_actual(zloc);\nvar vec__45787 = zprint.zprint.next_newline(zloc__$1);\nvar count_prior_to_newline = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45787,(0),null);\nvar newline = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45787,(1),null);\nif((count_prior_to_newline < (2))){\nreturn false;\n} else {\nvar second_element = zprint.zutil.zrightnws(((zprint.zutil.whitespace_QMARK_(zloc__$1))?zprint.zutil.zrightnws(zloc__$1):zloc__$1));\nvar second_indent = zprint.zprint.length_before(second_element);\nvar third_element = zprint.zprint.next_actual(second_element);\nvar third_indent = zprint.zprint.length_before(third_element);\nvar and__4210__auto__ = second_element;\nif(cljs.core.truth_(and__4210__auto__)){\nvar and__4210__auto____$1 = third_element;\nif(cljs.core.truth_(and__4210__auto____$1)){\nreturn cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(second_indent,third_indent);\n} else {\nreturn and__4210__auto____$1;\n}\n} else {\nreturn and__4210__auto__;\n}\n}\n});\n/**\n * Take a style-vec that was once output from indent-zmap, and fix\n *   up all of the :indent elements in it by adding (- actual-ind ind)\n *   to them.  If we find a multiple thing in here, call indent-shift\n *   recursively with the ind and cur-ind that is approprite.  All of\n *   the actual indents are correct already -- all we are doing is\n *   setting up their base.  There is no attempt to determine if we\n *   are exceeding any configured width.\n */\nzprint.zprint.indent_shift = (function zprint$zprint$indent_shift(caller,options,ind,actual_ind,svec){\nvar shift_ind = actual_ind;\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options))){\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),cljs.core.pr_str.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\"indent-shift: ind:\",ind,\"actual-ind:\",actual_ind,\"shift-ind:\",shift_ind,\"svec:\",svec], 0))], 0));\n} else {\n}\n\nvar cur_seq = svec;\nvar cur_ind = actual_ind;\nvar out = cljs.core.PersistentVector.EMPTY;\nwhile(true){\nif(cljs.core.not(cur_seq)){\nreturn out;\n} else {\nvar this_seq = cljs.core.first(cur_seq);\nvar new_seq = ((cljs.core.vector_QMARK_(cljs.core.first(this_seq)))?(zprint.zprint.indent_shift.cljs$core$IFn$_invoke$arity$5 ? zprint.zprint.indent_shift.cljs$core$IFn$_invoke$arity$5(caller,options,ind,cur_ind,this_seq) : zprint.zprint.indent_shift.call(null,caller,options,ind,cur_ind,this_seq)):(function (){var vec__45799 = this_seq;\nvar s = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45799,(0),null);\nvar color = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45799,(1),null);\nvar type = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45799,(2),null);\nvar next_seq = cljs.core.first(cljs.core.next(cur_seq));\nvar this_shift = (cljs.core.truth_((function (){var and__4210__auto__ = next_seq;\nif(cljs.core.truth_(and__4210__auto__)){\nreturn (((!(cljs.core.vector_QMARK_(cljs.core.first(next_seq))))) && (cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(cljs.core.nth.cljs$core$IFn$_invoke$arity$2(next_seq,(2)),new cljs.core.Keyword(null,\"indent\",\"indent\",-148200125))));\n} else {\nreturn and__4210__auto__;\n}\n})())?(0):shift_ind);\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(type,new cljs.core.Keyword(null,\"indent\",\"indent\",-148200125))){\nreturn new cljs.core.PersistentVector(null, 4, 5, cljs.core.PersistentVector.EMPTY_NODE, [[cljs.core.str.cljs$core$IFn$_invoke$arity$1(s),cljs.core.str.cljs$core$IFn$_invoke$arity$1(zprint.zprint.blanks(this_shift))].join(''),color,type,(42)], null);\n} else {\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(type,new cljs.core.Keyword(null,\"right\",\"right\",-452581833))){\nreturn new cljs.core.PersistentVector(null, 4, 5, cljs.core.PersistentVector.EMPTY_NODE, [s,color,type,shift_ind], null);\n} else {\nreturn this_seq;\n\n}\n}\n})());\nvar _ = (cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options))?cljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),cljs.core.pr_str.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\"indent-shift: cur-ind:\",cur_ind,\"this-seq:\",this_seq,\"new-seq:\",new_seq], 0))], 0)):null);\nvar vec__45796 = zprint.zprint.style_lines(options,cur_ind,new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new_seq], null));\nvar linecnt = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45796,(0),null);\nvar max_width = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45796,(1),null);\nvar lines = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45796,(2),null);\nvar last_width = cljs.core.last(lines);\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options))){\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),cljs.core.pr_str.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\"indent-shift: last-width:\",last_width,\"new-seq:\",new_seq], 0))], 0));\n} else {\n}\n\nvar G__46492 = cljs.core.next(cur_seq);\nvar G__46493 = last_width;\nvar G__46494 = cljs.core.conj.cljs$core$IFn$_invoke$arity$2(out,new_seq);\ncur_seq = G__46492;\ncur_ind = G__46493;\nout = G__46494;\ncontinue;\n}\nbreak;\n}\n});\n/**\n * Implement :indent-only?.  This routine is the central one through\n *   which all :indent-only? processing flows, and replaces all of the\n *   detailed logic in fzprint-list*, fzprint-vec*, and fzprint-map*.\n *   This is called directly by fzprint-vec*, which handles both vectors\n *   and sets, and through fzprint-indent by fzprint-list* and\n *   fzprint-map*.  Thus, all of the data structures get their\n *   :indent-only? processing handled by ident-zmap.  coll-print is\n *   the output from fzprint-seq, which is a style-vec in the making\n *   without spacing, but with extra [] around the elements.  Everything\n *   is based off of ind, and we know nothing to the left of that.\n *   ind must be the left end of everything, not the right of l-str!\n *   The actual-ind is to the right of l-str.  When we get a newline,\n *   replace any spaces after it with our own, and that would be to\n *   bring it to ind + indent.  \n */\nzprint.zprint.indent_zmap = (function zprint$zprint$indent_zmap(var_args){\nvar G__45803 = arguments.length;\nswitch (G__45803) {\ncase 7:\nreturn zprint.zprint.indent_zmap.cljs$core$IFn$_invoke$arity$7((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]),(arguments[(5)]),(arguments[(6)]));\n\nbreak;\ncase 6:\nreturn zprint.zprint.indent_zmap.cljs$core$IFn$_invoke$arity$6((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]),(arguments[(5)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\n(zprint.zprint.indent_zmap.cljs$core$IFn$_invoke$arity$7 = (function (caller,p__45804,ind,actual_ind,coll_print,indent,first_indent_only_QMARK_){\nvar map__45805 = p__45804;\nvar map__45805__$1 = cljs.core.__destructure_map(map__45805);\nvar options = map__45805__$1;\nvar map__45806 = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__45805__$1,caller);\nvar map__45806__$1 = cljs.core.__destructure_map(map__45806);\nvar wrap_after_multi_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__45806__$1,new cljs.core.Keyword(null,\"wrap-after-multi?\",\"wrap-after-multi?\",1010808052));\nvar width = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__45805__$1,new cljs.core.Keyword(null,\"width\",\"width\",-384071477));\nvar rightcnt = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__45805__$1,new cljs.core.Keyword(null,\"rightcnt\",\"rightcnt\",-45750070));\nvar coll_print__$1 = (zprint.zprint.merge_fzprint_seq.cljs$core$IFn$_invoke$arity$1 ? zprint.zprint.merge_fzprint_seq.cljs$core$IFn$_invoke$arity$1(coll_print) : zprint.zprint.merge_fzprint_seq.call(null,coll_print));\nvar last_index = (cljs.core.count(coll_print__$1) - (1));\nvar rightcnt__$1 = zprint.zprint.fix_rightcnt(rightcnt);\nvar actual_indent = (ind + indent);\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options))){\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),cljs.core.pr_str.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\"indent-zmap: ind:\",ind,\"actual-ind:\",actual_ind,\"first-indent-only?\",first_indent_only_QMARK_,\"indent:\",indent,\"actual-indent:\",actual_indent,\"coll-print:\",coll_print__$1], 0))], 0));\n} else {\n}\n\nvar cur_seq = coll_print__$1;\nvar cur_ind = actual_ind;\nvar index = (0);\nvar beginning_QMARK_ = true;\nvar l_str_indent_QMARK_ = true;\nvar out = cljs.core.PersistentVector.EMPTY;\nwhile(true){\nif(cljs.core.not(cur_seq)){\nreturn out;\n} else {\nvar this_seq = cljs.core.first(cur_seq);\nif(cljs.core.truth_(this_seq)){\nvar multi_QMARK_ = (cljs.core.count(this_seq) > (1));\nvar _ = zprint.zprint.log_lines(options,\"indent-zmap:\",ind,this_seq);\nvar ___$1 = (cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options))?cljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),cljs.core.pr_str.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\"indent-zmap loop: cur-ind:\",cur_ind,\"multi?\",multi_QMARK_,\"(count this-seq):\",cljs.core.count(this_seq),\"this-seq:\",this_seq,\"out:\",out], 0))], 0)):null);\nvar this_seq__$1 = ((multi_QMARK_)?zprint.zprint.indent_shift(caller,options,actual_ind,cur_ind,this_seq):this_seq);\nvar vec__45818 = zprint.zprint.style_lines(options,cur_ind,this_seq__$1);\nvar linecnt = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45818,(0),null);\nvar max_width = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45818,(1),null);\nvar lines = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45818,(2),null);\nvar last_width = cljs.core.last(lines);\nvar thetype = cljs.core.nth.cljs$core$IFn$_invoke$arity$2(cljs.core.last(this_seq__$1),(2));\nvar len = (last_width - cur_ind);\nvar ___$2 = (cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options))?cljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),\"linecnt:\",linecnt,\"last-width:\",last_width,\"len:\",len,\"type:\",thetype], 0)):null);\nvar len__$1 = (function (){var x__4295__auto__ = (0);\nvar y__4296__auto__ = len;\nreturn ((x__4295__auto__ > y__4296__auto__) ? x__4295__auto__ : y__4296__auto__);\n})();\nvar newline_QMARK_ = cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(thetype,new cljs.core.Keyword(null,\"newline\",\"newline\",1790071323));\nvar comma_QMARK_ = cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(thetype,new cljs.core.Keyword(null,\"comma\",\"comma\",1699024745));\nvar isempty_QMARK_ = cljs.core.empty_QMARK_(cljs.core.first(cljs.core.first(this_seq__$1)));\nvar comment_QMARK_ = ((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(thetype,new cljs.core.Keyword(null,\"comment\",\"comment\",532206069))) || (cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(thetype,new cljs.core.Keyword(null,\"comment-inline\",\"comment-inline\",712944405))));\nvar l_str_indent_QMARK___$1 = ((l_str_indent_QMARK_) && (((comment_QMARK_) || (newline_QMARK_))));\nvar actual_indent__$1 = (cljs.core.truth_((function (){var and__4210__auto__ = (index > (0));\nif(and__4210__auto__){\nreturn first_indent_only_QMARK_;\n} else {\nreturn and__4210__auto__;\n}\n})())?ind:(ind + indent));\nvar width__$1 = ((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(index,last_index))?(width - rightcnt__$1):width);\nvar fit_QMARK_ = ((cur_ind + len__$1) <= width__$1);\nvar new_ind = ((newline_QMARK_)?actual_indent__$1:((cur_ind + (1)) + len__$1)\n);\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options))){\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),cljs.core.pr_str.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\"------ this-seq:\",this_seq__$1,\"lines:\",lines,\"linecnt:\",linecnt,\"multi?\",multi_QMARK_,\"thetype:\",thetype,\"newline?:\",newline_QMARK_,\"comment?:\",comment_QMARK_,\"comma?:\",comma_QMARK_,\"l-str-indent?:\",l_str_indent_QMARK___$1,\"first-indent-only?\",first_indent_only_QMARK_,\"actual-indent:\",actual_indent__$1,\"index:\",index,\"beginning?:\",beginning_QMARK_,\"max-width:\",max_width,\"last-width:\",last_width,\"len:\",len__$1,\"cur-ind:\",cur_ind,\"isempty?:\",isempty_QMARK_,\"new-ind:\",new_ind,\"width:\",width__$1,\"fit?\",fit_QMARK_], 0))], 0));\n} else {\n}\n\nvar G__46503 = cljs.core.next(cur_seq);\nvar G__46504 = new_ind;\nvar G__46505 = (index + (1));\nvar G__46506 = ((((isempty_QMARK_) && (beginning_QMARK_))) || (((newline_QMARK_) || (cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(thetype,new cljs.core.Keyword(null,\"indent\",\"indent\",-148200125))))));\nvar G__46507 = l_str_indent_QMARK___$1;\nvar G__46508 = ((isempty_QMARK_)?out:cljs.core.concat.cljs$core$IFn$_invoke$arity$2(out,((newline_QMARK_)?new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 4, 5, cljs.core.PersistentVector.EMPTY_NODE, [[\"\\n\",cljs.core.str.cljs$core$IFn$_invoke$arity$1((function (){var next_seq = cljs.core.first(cljs.core.next(cur_seq));\nvar newline_next_QMARK_ = (cljs.core.truth_(next_seq)?cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(cljs.core.nth.cljs$core$IFn$_invoke$arity$2(cljs.core.first(next_seq),(2)),new cljs.core.Keyword(null,\"newline\",\"newline\",1790071323)):null);\nif(cljs.core.truth_(newline_next_QMARK_)){\nreturn \"\";\n} else {\nreturn zprint.zprint.blanks(((l_str_indent_QMARK___$1)?actual_ind:actual_indent__$1));\n}\n})())].join(''),new cljs.core.Keyword(null,\"none\",\"none\",1333468478),new cljs.core.Keyword(null,\"indent\",\"indent\",-148200125),(12)], null)], null):(((index === (0)))?this_seq__$1:((((beginning_QMARK_) || (comma_QMARK_)))?this_seq__$1:zprint.zprint.concat_no_nil.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 4, 5, cljs.core.PersistentVector.EMPTY_NODE, [\" \",new cljs.core.Keyword(null,\"none\",\"none\",1333468478),new cljs.core.Keyword(null,\"whitespace\",\"whitespace\",-1340035483),(12)], null)], null),this_seq__$1], 0)))\n))));\ncur_seq = G__46503;\ncur_ind = G__46504;\nindex = G__46505;\nbeginning_QMARK_ = G__46506;\nl_str_indent_QMARK_ = G__46507;\nout = G__46508;\ncontinue;\n} else {\nreturn null;\n}\n}\nbreak;\n}\n}));\n\n(zprint.zprint.indent_zmap.cljs$core$IFn$_invoke$arity$6 = (function (caller,options,ind,actual_ind,coll_print,indent){\nreturn zprint.zprint.indent_zmap.cljs$core$IFn$_invoke$arity$7(caller,options,ind,actual_ind,coll_print,indent,null);\n}));\n\n(zprint.zprint.indent_zmap.cljs$lang$maxFixedArity = 7);\n\nzprint.zprint.hang_indent = new cljs.core.PersistentHashSet(null, new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,\"hang\",\"hang\",-1007256173),null,new cljs.core.Keyword(null,\"none-body\",\"none-body\",-171554854),null,new cljs.core.Keyword(null,\"none\",\"none\",1333468478),null], null), null);\nzprint.zprint.flow_indent = new cljs.core.PersistentHashSet(null, new cljs.core.PersistentArrayMap(null, 16, [new cljs.core.Keyword(null,\"gt3-force-nl\",\"gt3-force-nl\",-1297517534),null,new cljs.core.Keyword(null,\"fn\",\"fn\",-1175266204),null,new cljs.core.Keyword(null,\"arg1-body\",\"arg1-body\",-1677449564),null,new cljs.core.Keyword(null,\"arg2\",\"arg2\",1729550917),null,new cljs.core.Keyword(null,\"force-nl\",\"force-nl\",-755040826),null,new cljs.core.Keyword(null,\"flow\",\"flow\",590489032),null,new cljs.core.Keyword(null,\"noarg1\",\"noarg1\",2031519464),null,new cljs.core.Keyword(null,\"noarg1-body\",\"noarg1-body\",774553320),null,new cljs.core.Keyword(null,\"gt2-force-nl\",\"gt2-force-nl\",-1746243317),null,new cljs.core.Keyword(null,\"force-nl-body\",\"force-nl-body\",1789087439),null,new cljs.core.Keyword(null,\"arg2-fn\",\"arg2-fn\",1172769072),null,new cljs.core.Keyword(null,\"binding\",\"binding\",539932593),null,new cljs.core.Keyword(null,\"arg1-force-nl\",\"arg1-force-nl\",-945624718),null,new cljs.core.Keyword(null,\"hang\",\"hang\",-1007256173),null,new cljs.core.Keyword(null,\"flow-body\",\"flow-body\",1355242804),null,new cljs.core.Keyword(null,\"arg1\",\"arg1\",951899358),null], null), null);\n/**\n * Given a vector of vectors, decide if we should merge these individually\n *   into the top level vector.\n */\nzprint.zprint.newline_seq_QMARK_ = (function zprint$zprint$newline_seq_QMARK_(newline_vec){\nvar starts_with_nl_vec = cljs.core.mapv.cljs$core$IFn$_invoke$arity$2((function (p1__45822_SHARP_){\nreturn clojure.string.starts_with_QMARK_(cljs.core.first(p1__45822_SHARP_),\"\\n\");\n}),newline_vec);\nvar true_seq = cljs.core.distinct.cljs$core$IFn$_invoke$arity$1(starts_with_nl_vec);\nreturn ((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(cljs.core.count(true_seq),(1))) && (cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(cljs.core.first(true_seq),true)));\n});\n/**\n * Given the output from fzprint-seq, which is a seq of the\n *   output of fzprint*, apply a function to each of them that has\n *   more than one element (since less has no meaning) and when the\n *   function returns true, merge the vector in as individual elements.\n */\nzprint.zprint.merge_fzprint_seq = (function zprint$zprint$merge_fzprint_seq(fzprint_seq_vec){\nreturn cljs.core.into.cljs$core$IFn$_invoke$arity$2(cljs.core.PersistentVector.EMPTY,cljs.core.reduce.cljs$core$IFn$_invoke$arity$3((function (p1__45824_SHARP_,p2__45823_SHARP_){\nif(zprint.zprint.newline_seq_QMARK_(p2__45823_SHARP_)){\nreturn cljs.core.into.cljs$core$IFn$_invoke$arity$2(cljs.core.PersistentVector.EMPTY,cljs.core.concat.cljs$core$IFn$_invoke$arity$2(p1__45824_SHARP_,cljs.core.mapv.cljs$core$IFn$_invoke$arity$2(cljs.core.vector,p2__45823_SHARP_)));\n} else {\nreturn cljs.core.conj.cljs$core$IFn$_invoke$arity$2(p1__45824_SHARP_,p2__45823_SHARP_);\n}\n}),cljs.core.PersistentVector.EMPTY,fzprint_seq_vec));\n});\n/**\n * This function assumes that :indent-only? was set for the caller\n *   in the options (since anything else doesn't make sense).  It takes\n *   a zloc and the ind, which is where we are on the line this point,\n *   and will process the zloc to include any newlines.  Of course we\n *   have to have all of the white space in the zloc too, since we\n *   need to ask some questions about what we are starting with at\n *   some point.  We don't add newlines and we let the newlines that\n *   are in there do their thing.  We might add newlines if we move\n *   beyond the right margin, but for now, we don't (and it isn't\n *   entirely clear how or if that would work).  This routine has to\n *   make decisions about the indent, that is whether to hang or flow\n *   the expression. It does that based on what was done in the input\n *   if the configuration allows.\n */\nzprint.zprint.fzprint_indent = (function zprint$zprint$fzprint_indent(var_args){\nvar G__45827 = arguments.length;\nswitch (G__45827) {\ncase 9:\nreturn zprint.zprint.fzprint_indent.cljs$core$IFn$_invoke$arity$9((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]),(arguments[(5)]),(arguments[(6)]),(arguments[(7)]),(arguments[(8)]));\n\nbreak;\ncase 8:\nreturn zprint.zprint.fzprint_indent.cljs$core$IFn$_invoke$arity$8((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]),(arguments[(5)]),(arguments[(6)]),(arguments[(7)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\n(zprint.zprint.fzprint_indent.cljs$core$IFn$_invoke$arity$9 = (function (caller,l_str,r_str,options,ind,zloc,fn_style,arg_1_indent,first_indent_only_QMARK_){\nvar flow_indent = new cljs.core.Keyword(null,\"indent\",\"indent\",-148200125).cljs$core$IFn$_invoke$arity$1((caller.cljs$core$IFn$_invoke$arity$1 ? caller.cljs$core$IFn$_invoke$arity$1(options) : caller.call(null,options)));\nvar flow_indent__$1 = ((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(caller,new cljs.core.Keyword(null,\"map\",\"map\",1371690461)))?cljs.core.count(l_str):flow_indent);\nvar l_str_len = cljs.core.count(l_str);\nvar flow_indent__$2 = (((((flow_indent__$1 > l_str_len)) && (cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(caller,new cljs.core.Keyword(null,\"list\",\"list\",765357683)))))?(cljs.core.truth_(arg_1_indent)?flow_indent__$1:l_str_len):flow_indent__$1);\nvar actual_ind = (ind + l_str_len);\nvar _ = (cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options))?cljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),cljs.core.pr_str.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\"fzprint-indent: caller:\",caller,\"l-str-len:\",l_str_len,\"ind:\",ind,\"fn-style:\",fn_style,\"arg-1-indent:\",arg_1_indent,\"flow-indent:\",flow_indent__$2,\"actual-ind:\",actual_ind,\"comma?\",new cljs.core.Keyword(null,\"comma?\",\"comma?\",1532168963).cljs$core$IFn$_invoke$arity$1((caller.cljs$core$IFn$_invoke$arity$1 ? caller.cljs$core$IFn$_invoke$arity$1(options) : caller.call(null,options)))], 0))], 0)):null);\nvar zloc_seq = (cljs.core.truth_(new cljs.core.Keyword(null,\"comma?\",\"comma?\",1532168963).cljs$core$IFn$_invoke$arity$1((caller.cljs$core$IFn$_invoke$arity$1 ? caller.cljs$core$IFn$_invoke$arity$1(options) : caller.call(null,options))))?(zprint.zfns.zmap_w_nl_comma.cljs$core$IFn$_invoke$arity$2 ? zprint.zfns.zmap_w_nl_comma.cljs$core$IFn$_invoke$arity$2(cljs.core.identity,zloc) : zprint.zfns.zmap_w_nl_comma.call(null,cljs.core.identity,zloc)):(zprint.zfns.zmap_w_nl.cljs$core$IFn$_invoke$arity$2 ? zprint.zfns.zmap_w_nl.cljs$core$IFn$_invoke$arity$2(cljs.core.identity,zloc) : zprint.zfns.zmap_w_nl.call(null,cljs.core.identity,zloc)));\nvar coll_print = zprint.zprint.fzprint_seq(options,ind,zloc_seq);\nvar ___$1 = (cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options))?cljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),cljs.core.pr_str.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\"fzprint-indent: coll-print:\",coll_print], 0))], 0)):null);\nvar indent_only_style = new cljs.core.Keyword(null,\"indent-only-style\",\"indent-only-style\",708921086).cljs$core$IFn$_invoke$arity$1((caller.cljs$core$IFn$_invoke$arity$1 ? caller.cljs$core$IFn$_invoke$arity$1(options) : caller.call(null,options)));\nvar already_hung_QMARK_ = (cljs.core.truth_((function (){var and__4210__auto__ = indent_only_style;\nif(cljs.core.truth_(and__4210__auto__)){\nreturn cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(indent_only_style,new cljs.core.Keyword(null,\"input-hang\",\"input-hang\",-542766364));\n} else {\nreturn and__4210__auto__;\n}\n})())?zprint.zprint.hang_zloc_QMARK_((zprint.zutil.down_STAR_.cljs$core$IFn$_invoke$arity$1 ? zprint.zutil.down_STAR_.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zutil.down_STAR_.call(null,zloc))):null);\nvar raw_indent = (cljs.core.truth_((function (){var and__4210__auto__ = arg_1_indent;\nif(cljs.core.truth_(and__4210__auto__)){\nreturn already_hung_QMARK_;\n} else {\nreturn and__4210__auto__;\n}\n})())?(arg_1_indent - ind):flow_indent__$2);\nvar indent = raw_indent;\nvar coll_print_contains_nil_QMARK_ = zprint.zprint.contains_nil_QMARK_(coll_print);\nvar ___$2 = (cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options))?cljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),cljs.core.pr_str.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\"fzprint-indent:\",(zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zstring.call(null,zloc)),\"ind:\",ind,\"fn-style:\",fn_style,\"indent-only-style:\",indent_only_style,\"already-hung?:\",already_hung_QMARK_,\"arg-1-indent:\",arg_1_indent,\"l-str-len:\",cljs.core.count(l_str),\"actual-ind:\",actual_ind,\"raw-indent:\",raw_indent,\"coll-print-contains-nil?:\",coll_print_contains_nil_QMARK_,\"indent:\",indent], 0))], 0)):null);\nvar coll_print__$1 = (cljs.core.truth_(coll_print_contains_nil_QMARK_)?null:coll_print);\nvar output = zprint.zprint.indent_zmap.cljs$core$IFn$_invoke$arity$7(caller,options,ind,actual_ind,coll_print__$1,indent,first_indent_only_QMARK_);\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options))){\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),cljs.core.pr_str.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\"fzprint-indent: output:\",output], 0))], 0));\n} else {\n}\n\nreturn output;\n}));\n\n(zprint.zprint.fzprint_indent.cljs$core$IFn$_invoke$arity$8 = (function (caller,l_str,r_str,options,ind,zloc,fn_style,arg_1_indent){\nreturn zprint.zprint.fzprint_indent.cljs$core$IFn$_invoke$arity$9(caller,l_str,r_str,options,ind,zloc,fn_style,arg_1_indent,null);\n}));\n\n(zprint.zprint.fzprint_indent.cljs$lang$maxFixedArity = 9);\n\n/**\n * Find the location, counting from zero, and counting every element \n *   in the seq, of the first zthing?.  Return its index if it is found, \n *   nil if not.\n */\nzprint.zprint.zfind_seq = (function zprint$zprint$zfind_seq(zthing_QMARK_,zloc_seq){\nvar nloc = zloc_seq;\nvar i = (0);\nwhile(true){\nif((!((nloc == null)))){\nif(cljs.core.truth_((function (){var G__45834 = cljs.core.first(nloc);\nreturn (zthing_QMARK_.cljs$core$IFn$_invoke$arity$1 ? zthing_QMARK_.cljs$core$IFn$_invoke$arity$1(G__45834) : zthing_QMARK_.call(null,G__45834));\n})())){\nreturn i;\n} else {\nvar G__46512 = cljs.core.next(nloc);\nvar G__46513 = (i + (1));\nnloc = G__46512;\ni = G__46513;\ncontinue;\n}\n} else {\nreturn null;\n}\nbreak;\n}\n});\nzprint.zprint.body_set = new cljs.core.PersistentHashSet(null, new cljs.core.PersistentArrayMap(null, 12, [new cljs.core.Keyword(null,\"arg2-pair\",\"arg2-pair\",-1268132126),null,new cljs.core.Keyword(null,\"fn\",\"fn\",-1175266204),null,new cljs.core.Keyword(null,\"arg1-body\",\"arg1-body\",-1677449564),null,new cljs.core.Keyword(null,\"arg2\",\"arg2\",1729550917),null,new cljs.core.Keyword(null,\"pair-fn\",\"pair-fn\",-360146586),null,new cljs.core.Keyword(null,\"noarg1-body\",\"noarg1-body\",774553320),null,new cljs.core.Keyword(null,\"arg1-pair-body\",\"arg1-pair-body\",541801100),null,new cljs.core.Keyword(null,\"arg2-fn\",\"arg2-fn\",1172769072),null,new cljs.core.Keyword(null,\"binding\",\"binding\",539932593),null,new cljs.core.Keyword(null,\"flow-body\",\"flow-body\",1355242804),null,new cljs.core.Keyword(null,\"arg1->\",\"arg1->\",1319654329),null,new cljs.core.Keyword(null,\"none-body\",\"none-body\",-171554854),null], null), null);\nzprint.zprint.body_map = new cljs.core.PersistentArrayMap(null, 6, [new cljs.core.Keyword(null,\"arg1-body\",\"arg1-body\",-1677449564),new cljs.core.Keyword(null,\"arg1\",\"arg1\",951899358),new cljs.core.Keyword(null,\"arg1-pair-body\",\"arg1-pair-body\",541801100),new cljs.core.Keyword(null,\"arg1-pair\",\"arg1-pair\",-38672953),new cljs.core.Keyword(null,\"none-body\",\"none-body\",-171554854),new cljs.core.Keyword(null,\"none\",\"none\",1333468478),new cljs.core.Keyword(null,\"flow-body\",\"flow-body\",1355242804),new cljs.core.Keyword(null,\"flow\",\"flow\",590489032),new cljs.core.Keyword(null,\"noarg1-body\",\"noarg1-body\",774553320),new cljs.core.Keyword(null,\"noarg1\",\"noarg1\",2031519464),new cljs.core.Keyword(null,\"force-nl-body\",\"force-nl-body\",1789087439),new cljs.core.Keyword(null,\"force-nl\",\"force-nl\",-755040826)], null);\nzprint.zprint.noarg1_set = new cljs.core.PersistentHashSet(null, new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(null,\"noarg1\",\"noarg1\",2031519464),null,new cljs.core.Keyword(null,\"arg1->\",\"arg1->\",1319654329),null], null), null);\nzprint.zprint.noarg1_map = new cljs.core.PersistentArrayMap(null, 5, [new cljs.core.Keyword(null,\"arg1\",\"arg1\",951899358),new cljs.core.Keyword(null,\"none\",\"none\",1333468478),new cljs.core.Keyword(null,\"arg1-pair\",\"arg1-pair\",-38672953),new cljs.core.Keyword(null,\"pair-fn\",\"pair-fn\",-360146586),new cljs.core.Keyword(null,\"arg1-extend\",\"arg1-extend\",-157225050),new cljs.core.Keyword(null,\"extend\",\"extend\",1836484006),new cljs.core.Keyword(null,\"arg2\",\"arg2\",1729550917),new cljs.core.Keyword(null,\"arg1\",\"arg1\",951899358),new cljs.core.Keyword(null,\"arg2-pair\",\"arg2-pair\",-1268132126),new cljs.core.Keyword(null,\"arg1-pair\",\"arg1-pair\",-38672953)], null);\n/**\n * Set noarg1 in the options if it is the right fn-type.\n */\nzprint.zprint.noarg1 = (function zprint$zprint$noarg1(options,fn_type){\nif(cljs.core.truth_((zprint.zprint.noarg1_set.cljs$core$IFn$_invoke$arity$1 ? zprint.zprint.noarg1_set.cljs$core$IFn$_invoke$arity$1(fn_type) : zprint.zprint.noarg1_set.call(null,fn_type)))){\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(options,new cljs.core.Keyword(null,\"no-arg1?\",\"no-arg1?\",1560368430),true);\n} else {\nreturn options;\n}\n});\nzprint.zprint.fn_style__GT_caller = new cljs.core.PersistentArrayMap(null, 8, [new cljs.core.Keyword(null,\"arg1-pair-body\",\"arg1-pair-body\",541801100),new cljs.core.Keyword(null,\"pair\",\"pair\",-447516312),new cljs.core.Keyword(null,\"arg1-pair\",\"arg1-pair\",-38672953),new cljs.core.Keyword(null,\"pair\",\"pair\",-447516312),new cljs.core.Keyword(null,\"arg2-pair\",\"arg2-pair\",-1268132126),new cljs.core.Keyword(null,\"pair\",\"pair\",-447516312),new cljs.core.Keyword(null,\"extend\",\"extend\",1836484006),new cljs.core.Keyword(null,\"extend\",\"extend\",1836484006),new cljs.core.Keyword(null,\"binding\",\"binding\",539932593),new cljs.core.Keyword(null,\"binding\",\"binding\",539932593),new cljs.core.Keyword(null,\"arg1-extend\",\"arg1-extend\",-157225050),new cljs.core.Keyword(null,\"extend\",\"extend\",1836484006),new cljs.core.Keyword(null,\"arg2-extend\",\"arg2-extend\",1554629186),new cljs.core.Keyword(null,\"extend\",\"extend\",1836484006),new cljs.core.Keyword(null,\"pair-fn\",\"pair-fn\",-360146586),new cljs.core.Keyword(null,\"pair\",\"pair\",-447516312)], null);\n/**\n * Given an options map, get the respect-nl?, respect-bl? and indent-only?\n *   options from the caller's options, and if the caller doesn't define these,\n *   use the values from the backup section of the options map. Return\n *   [respect-nl? respect-bl? indent-only?]\n */\nzprint.zprint.get_respect_indent = (function zprint$zprint$get_respect_indent(options,caller,backup){\nvar caller_options = (caller.cljs$core$IFn$_invoke$arity$1 ? caller.cljs$core$IFn$_invoke$arity$1(options) : caller.call(null,options));\nvar respect_nl_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$3(caller_options,new cljs.core.Keyword(null,\"respect-nl?\",\"respect-nl?\",604814635),new cljs.core.Keyword(null,\"undef\",\"undef\",-529926228));\nvar respect_bl_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$3(caller_options,new cljs.core.Keyword(null,\"respect-bl?\",\"respect-bl?\",298921998),new cljs.core.Keyword(null,\"undef\",\"undef\",-529926228));\nvar indent_only_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$3(caller_options,new cljs.core.Keyword(null,\"indent-only?\",\"indent-only?\",375678842),new cljs.core.Keyword(null,\"undef\",\"undef\",-529926228));\nreturn new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [((cljs.core.not_EQ_.cljs$core$IFn$_invoke$arity$2(respect_nl_QMARK_,new cljs.core.Keyword(null,\"undef\",\"undef\",-529926228)))?respect_nl_QMARK_:new cljs.core.Keyword(null,\"respect-nl?\",\"respect-nl?\",604814635).cljs$core$IFn$_invoke$arity$1((backup.cljs$core$IFn$_invoke$arity$1 ? backup.cljs$core$IFn$_invoke$arity$1(options) : backup.call(null,options)))),((cljs.core.not_EQ_.cljs$core$IFn$_invoke$arity$2(respect_bl_QMARK_,new cljs.core.Keyword(null,\"undef\",\"undef\",-529926228)))?respect_bl_QMARK_:new cljs.core.Keyword(null,\"respect-bl?\",\"respect-bl?\",298921998).cljs$core$IFn$_invoke$arity$1((backup.cljs$core$IFn$_invoke$arity$1 ? backup.cljs$core$IFn$_invoke$arity$1(options) : backup.call(null,options)))),((cljs.core.not_EQ_.cljs$core$IFn$_invoke$arity$2(indent_only_QMARK_,new cljs.core.Keyword(null,\"undef\",\"undef\",-529926228)))?indent_only_QMARK_:new cljs.core.Keyword(null,\"indent-only?\",\"indent-only?\",375678842).cljs$core$IFn$_invoke$arity$1((backup.cljs$core$IFn$_invoke$arity$1 ? backup.cljs$core$IFn$_invoke$arity$1(options) : backup.call(null,options))))], null);\n});\n/**\n * Should we allow this function to print on a single line?\n */\nzprint.zprint.allow_one_line_QMARK_ = (function zprint$zprint$allow_one_line_QMARK_(p__45837,len,fn_style){\nvar map__45838 = p__45837;\nvar map__45838__$1 = cljs.core.__destructure_map(map__45838);\nvar options = map__45838__$1;\nvar fn_force_nl = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__45838__$1,new cljs.core.Keyword(null,\"fn-force-nl\",\"fn-force-nl\",1501458692));\nvar fn_gt2_force_nl = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__45838__$1,new cljs.core.Keyword(null,\"fn-gt2-force-nl\",\"fn-gt2-force-nl\",1348579537));\nvar fn_gt3_force_nl = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__45838__$1,new cljs.core.Keyword(null,\"fn-gt3-force-nl\",\"fn-gt3-force-nl\",-58306985));\nreturn cljs.core.not((function (){var or__4212__auto__ = (fn_force_nl.cljs$core$IFn$_invoke$arity$1 ? fn_force_nl.cljs$core$IFn$_invoke$arity$1(fn_style) : fn_force_nl.call(null,fn_style));\nif(cljs.core.truth_(or__4212__auto__)){\nreturn or__4212__auto__;\n} else {\nvar or__4212__auto____$1 = (function (){var and__4210__auto__ = (len > (3));\nif(and__4210__auto__){\nreturn (fn_gt2_force_nl.cljs$core$IFn$_invoke$arity$1 ? fn_gt2_force_nl.cljs$core$IFn$_invoke$arity$1(fn_style) : fn_gt2_force_nl.call(null,fn_style));\n} else {\nreturn and__4210__auto__;\n}\n})();\nif(cljs.core.truth_(or__4212__auto____$1)){\nreturn or__4212__auto____$1;\n} else {\nvar or__4212__auto____$2 = (function (){var and__4210__auto__ = (len > (4));\nif(and__4210__auto__){\nreturn (fn_gt3_force_nl.cljs$core$IFn$_invoke$arity$1 ? fn_gt3_force_nl.cljs$core$IFn$_invoke$arity$1(fn_style) : fn_gt3_force_nl.call(null,fn_style));\n} else {\nreturn and__4210__auto__;\n}\n})();\nif(cljs.core.truth_(or__4212__auto____$2)){\nreturn or__4212__auto____$2;\n} else {\nvar temp__5751__auto__ = (zprint.zprint.fn_style__GT_caller.cljs$core$IFn$_invoke$arity$1 ? zprint.zprint.fn_style__GT_caller.cljs$core$IFn$_invoke$arity$1(fn_style) : zprint.zprint.fn_style__GT_caller.call(null,fn_style));\nif(cljs.core.truth_(temp__5751__auto__)){\nvar future_caller = temp__5751__auto__;\nvar caller_map = (future_caller.cljs$core$IFn$_invoke$arity$1 ? future_caller.cljs$core$IFn$_invoke$arity$1(options) : future_caller.call(null,options));\nvar or__4212__auto____$3 = new cljs.core.Keyword(null,\"flow?\",\"flow?\",96929057).cljs$core$IFn$_invoke$arity$1(caller_map);\nif(cljs.core.truth_(or__4212__auto____$3)){\nreturn or__4212__auto____$3;\n} else {\nreturn new cljs.core.Keyword(null,\"force-nl?\",\"force-nl?\",-1299761462).cljs$core$IFn$_invoke$arity$1(caller_map);\n}\n} else {\nreturn null;\n}\n}\n}\n}\n})());\n});\n/**\n * If the (caller options) has a value for :return-altered-zipper, then\n *   examine the value.  It should be [<depth> <symbol> <fn>]. \n *   If the <depth> is nil, any depth will do. If the\n *   <symbol> is nil, any symbol will do.  If the <depth> and <symbol>\n *   match, then the <fn> is called as (fn caller options zloc), and must\n *   return a new zloc.\n */\nzprint.zprint.modify_zloc = (function zprint$zprint$modify_zloc(caller,options,zloc){\nvar vec__45846 = new cljs.core.Keyword(null,\"return-altered-zipper\",\"return-altered-zipper\",837872379).cljs$core$IFn$_invoke$arity$1((caller.cljs$core$IFn$_invoke$arity$1 ? caller.cljs$core$IFn$_invoke$arity$1(options) : caller.call(null,options)));\nvar depth = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45846,(0),null);\nvar trigger_symbol = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45846,(1),null);\nvar modify_fn = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45846,(2),null);\nvar return_altered_zipper_value = vec__45846;\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options))){\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),\"modify-zloc caller:\",caller,\"ztype\",new cljs.core.Keyword(null,\"ztype\",\"ztype\",-562179020).cljs$core$IFn$_invoke$arity$1(options),\"return-altered-zipper-value:\",return_altered_zipper_value], 0));\n} else {\n}\n\nif(((cljs.core.not_EQ_.cljs$core$IFn$_invoke$arity$2(new cljs.core.Keyword(null,\"ztype\",\"ztype\",-562179020).cljs$core$IFn$_invoke$arity$1(options),new cljs.core.Keyword(null,\"zipper\",\"zipper\",1500694438))) || ((return_altered_zipper_value == null)))){\nreturn zloc;\n} else {\nvar call_fn_QMARK_ = (function (){var and__4210__auto__ = (((depth == null)) || (cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(new cljs.core.Keyword(null,\"depth\",\"depth\",1768663640).cljs$core$IFn$_invoke$arity$1(options),depth)));\nif(and__4210__auto__){\nvar and__4210__auto____$1 = ((cljs.core.not(trigger_symbol)) || (cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(trigger_symbol,(function (){var G__45849 = (zprint.zfns.zfirst.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zfirst.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zfirst.call(null,zloc));\nreturn (zprint.zfns.zsexpr.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zsexpr.cljs$core$IFn$_invoke$arity$1(G__45849) : zprint.zfns.zsexpr.call(null,G__45849));\n})())));\nif(and__4210__auto____$1){\nreturn modify_fn;\n} else {\nreturn and__4210__auto____$1;\n}\n} else {\nreturn and__4210__auto__;\n}\n})();\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options))){\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),\"modify-zloc: zloc\",(zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zstring.call(null,zloc)),\"call-fn?\",call_fn_QMARK_], 0));\n} else {\n}\n\nif(cljs.core.truth_(call_fn_QMARK_)){\nvar return$ = (modify_fn.cljs$core$IFn$_invoke$arity$3 ? modify_fn.cljs$core$IFn$_invoke$arity$3(caller,options,zloc) : modify_fn.call(null,caller,options,zloc));\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options))){\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),\"modify-zloc return:\",(zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1(return$) : zprint.zfns.zstring.call(null,return$))], 0));\n} else {\n}\n\nreturn return$;\n} else {\nreturn zloc;\n}\n}\n});\n/**\n * Print a list, which might be a list or an anon fn.  \n *   Lots of work to make a list look good, as that is typically code. \n *   Presently all of the callers of this are :list or :vector-fn.\n */\nzprint.zprint.fzprint_list_STAR_ = (function zprint$zprint$fzprint_list_STAR_(caller,l_str,r_str,p__45853,ind,zloc){\nvar map__45854 = p__45853;\nvar map__45854__$1 = cljs.core.__destructure_map(map__45854);\nvar options = map__45854__$1;\nvar fn_map = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__45854__$1,new cljs.core.Keyword(null,\"fn-map\",\"fn-map\",565481146));\nvar user_fn_map = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__45854__$1,new cljs.core.Keyword(null,\"user-fn-map\",\"user-fn-map\",-908243227));\nvar one_line_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__45854__$1,new cljs.core.Keyword(null,\"one-line?\",\"one-line?\",2055953111));\nvar fn_style = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__45854__$1,new cljs.core.Keyword(null,\"fn-style\",\"fn-style\",1330516917));\nvar no_arg1_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__45854__$1,new cljs.core.Keyword(null,\"no-arg1?\",\"no-arg1?\",1560368430));\nvar fn_force_nl = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__45854__$1,new cljs.core.Keyword(null,\"fn-force-nl\",\"fn-force-nl\",1501458692));\nvar max_length = zprint.zprint.get_max_length(options);\nvar zloc__$1 = zprint.zprint.modify_zloc(caller,options,zloc);\nvar len = (zprint.zfns.zcount.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zcount.cljs$core$IFn$_invoke$arity$1(zloc__$1) : zprint.zfns.zcount.call(null,zloc__$1));\nvar zloc__$2 = (((len > max_length))?(function (){var G__45869 = max_length;\nvar G__45870 = zloc__$1;\nvar G__45871 = new cljs.core.Symbol(null,\"...\",\"...\",-1926939749,null);\nreturn (zprint.zfns.ztake_append.cljs$core$IFn$_invoke$arity$3 ? zprint.zfns.ztake_append.cljs$core$IFn$_invoke$arity$3(G__45869,G__45870,G__45871) : zprint.zfns.ztake_append.call(null,G__45869,G__45870,G__45871));\n})():zloc__$1);\nvar len__$1 = (zprint.zfns.zcount.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zcount.cljs$core$IFn$_invoke$arity$1(zloc__$2) : zprint.zfns.zcount.call(null,zloc__$2));\nvar l_str_len = cljs.core.count(l_str);\nvar indent = new cljs.core.Keyword(null,\"indent\",\"indent\",-148200125).cljs$core$IFn$_invoke$arity$1((options.cljs$core$IFn$_invoke$arity$1 ? options.cljs$core$IFn$_invoke$arity$1(caller) : options.call(null,caller)));\nvar vec__45856 = zprint.zprint.fzprint_up_to_first_zloc(caller,options,(ind + l_str_len),zloc__$2);\nvar pre_arg_1_style_vec = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45856,(0),null);\nvar arg_1_zloc = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45856,(1),null);\nvar arg_1_count = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45856,(2),null);\nvar zloc_seq = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45856,(3),null);\nvar first_data = vec__45856;\nvar arg_1_coll_QMARK_ = cljs.core.not((function (){var or__4212__auto__ = (zprint.zfns.zkeyword_QMARK_.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zkeyword_QMARK_.cljs$core$IFn$_invoke$arity$1(arg_1_zloc) : zprint.zfns.zkeyword_QMARK_.call(null,arg_1_zloc));\nif(cljs.core.truth_(or__4212__auto__)){\nreturn or__4212__auto__;\n} else {\nreturn (zprint.zfns.zsymbol_QMARK_.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zsymbol_QMARK_.cljs$core$IFn$_invoke$arity$1(arg_1_zloc) : zprint.zfns.zsymbol_QMARK_.call(null,arg_1_zloc));\n}\n})());\nvar arg_1_indent_alt_QMARK_ = (function (){var and__4210__auto__ = arg_1_coll_QMARK_;\nif(and__4210__auto__){\nreturn fn_style;\n} else {\nreturn and__4210__auto__;\n}\n})();\nvar fn_str = (((!(arg_1_coll_QMARK_)))?(zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1(arg_1_zloc) : zprint.zfns.zstring.call(null,arg_1_zloc)):null);\nvar fn_style__$1 = (function (){var or__4212__auto__ = fn_style;\nif(cljs.core.truth_(or__4212__auto__)){\nreturn or__4212__auto__;\n} else {\nvar or__4212__auto____$1 = (fn_map.cljs$core$IFn$_invoke$arity$1 ? fn_map.cljs$core$IFn$_invoke$arity$1(fn_str) : fn_map.call(null,fn_str));\nif(cljs.core.truth_(or__4212__auto____$1)){\nreturn or__4212__auto____$1;\n} else {\nreturn (user_fn_map.cljs$core$IFn$_invoke$arity$1 ? user_fn_map.cljs$core$IFn$_invoke$arity$1(fn_str) : user_fn_map.call(null,fn_str));\n}\n}\n})();\nvar fn_style__$2 = (cljs.core.truth_((function (){var and__4210__auto__ = cljs.core.not(fn_style__$1);\nif(and__4210__auto__){\nreturn fn_str;\n} else {\nreturn and__4210__auto__;\n}\n})())?(function (){var G__45874 = cljs.core.last(clojure.string.split.cljs$core$IFn$_invoke$arity$2(fn_str,/\\//));\nreturn (fn_map.cljs$core$IFn$_invoke$arity$1 ? fn_map.cljs$core$IFn$_invoke$arity$1(G__45874) : fn_map.call(null,G__45874));\n})():fn_style__$1);\nvar fn_style__$3 = ((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(fn_style__$2,new cljs.core.Keyword(null,\"none\",\"none\",1333468478)))?null:fn_style__$2);\nvar fn_style__$4 = (cljs.core.truth_((function (){var and__4210__auto__ = fn_str;\nif(cljs.core.truth_(and__4210__auto__)){\nreturn (fn_style__$3 == null);\n} else {\nreturn and__4210__auto__;\n}\n})())?new cljs.core.Keyword(null,\"default\",\"default\",-1987822328).cljs$core$IFn$_invoke$arity$1(fn_map):fn_style__$3);\nvar options__$1 = ((cljs.core.vector_QMARK_(fn_style__$4))?cljs.core.first(zprint.config.config_and_validate(\"fn-style:\",null,options,((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(cljs.core.count(fn_style__$4),(2)))?cljs.core.second(fn_style__$4):((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(new cljs.core.Keyword(null,\"zipper\",\"zipper\",1500694438),new cljs.core.Keyword(null,\"ztype\",\"ztype\",-562179020).cljs$core$IFn$_invoke$arity$1(options)))?cljs.core.second(fn_style__$4):cljs.core.nth.cljs$core$IFn$_invoke$arity$2(fn_style__$4,(2)))))):options);\nvar vec__45859 = ((cljs.core.vector_QMARK_(fn_style__$4))?zprint.zprint.fzprint_up_to_first_zloc(caller,options__$1,(ind + l_str_len),zloc__$2):first_data);\nvar pre_arg_1_style_vec__$1 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45859,(0),null);\nvar arg_1_zloc__$1 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45859,(1),null);\nvar arg_1_count__$1 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45859,(2),null);\nvar zloc_seq__$1 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45859,(3),null);\nvar first_data__$1 = vec__45859;\nvar fn_style__$5 = ((cljs.core.vector_QMARK_(fn_style__$4))?cljs.core.first(fn_style__$4):fn_style__$4);\nvar vec__45862 = zprint.zprint.fzprint_up_to_next_zloc(caller,options__$1,(ind + indent),first_data__$1);\nvar pre_arg_2_style_vec = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45862,(0),null);\nvar arg_2_zloc = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45862,(1),null);\nvar arg_2_count = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45862,(2),null);\nvar _ = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45862,(3),null);\nvar second_data = vec__45862;\nvar len__$2 = (zprint.zfns.zcount_zloc_seq_nc_nws.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zcount_zloc_seq_nc_nws.cljs$core$IFn$_invoke$arity$1(zloc_seq__$1) : zprint.zfns.zcount_zloc_seq_nc_nws.call(null,zloc_seq__$1));\nvar vec__45865 = (cljs.core.truth_((function (){var and__4210__auto__ = cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(fn_style__$5,new cljs.core.Keyword(null,\"replace-w-string\",\"replace-w-string\",1411008615));\nif(and__4210__auto__){\nvar and__4210__auto____$1 = new cljs.core.Keyword(null,\"replacement-string\",\"replacement-string\",-1920084419).cljs$core$IFn$_invoke$arity$1((options__$1.cljs$core$IFn$_invoke$arity$1 ? options__$1.cljs$core$IFn$_invoke$arity$1(caller) : options__$1.call(null,caller)));\nif(cljs.core.truth_(and__4210__auto____$1)){\nreturn cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(len__$2,(2));\n} else {\nreturn and__4210__auto____$1;\n}\n} else {\nreturn and__4210__auto__;\n}\n})())?new cljs.core.PersistentVector(null, 7, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(cljs.core.update_in.cljs$core$IFn$_invoke$arity$4(options__$1,new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [caller], null),cljs.core.dissoc,new cljs.core.Keyword(null,\"replacement-string\",\"replacement-string\",-1920084419)),new cljs.core.Keyword(null,\"rightcnt\",\"rightcnt\",-45750070),(new cljs.core.Keyword(null,\"rightcnt\",\"rightcnt\",-45750070).cljs$core$IFn$_invoke$arity$1(options__$1) - (1))),arg_2_zloc,new cljs.core.Keyword(null,\"replacement-string\",\"replacement-string\",-1920084419).cljs$core$IFn$_invoke$arity$1((options__$1.cljs$core$IFn$_invoke$arity$1 ? options__$1.cljs$core$IFn$_invoke$arity$1(caller) : options__$1.call(null,caller))),cljs.core.count(new cljs.core.Keyword(null,\"replacement-string\",\"replacement-string\",-1920084419).cljs$core$IFn$_invoke$arity$1((options__$1.cljs$core$IFn$_invoke$arity$1 ? options__$1.cljs$core$IFn$_invoke$arity$1(caller) : options__$1.call(null,caller)))),\"\",(1),zprint.zprint.remove_one(zloc_seq__$1,arg_1_count__$1)], null):new cljs.core.PersistentVector(null, 7, 5, cljs.core.PersistentVector.EMPTY_NODE, [options__$1,arg_1_zloc__$1,l_str,l_str_len,r_str,len__$2,zloc_seq__$1], null));\nvar options__$2 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45865,(0),null);\nvar arg_1_zloc__$2 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45865,(1),null);\nvar l_str__$1 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45865,(2),null);\nvar l_str_len__$1 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45865,(3),null);\nvar r_str__$1 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45865,(4),null);\nvar len__$3 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45865,(5),null);\nvar zloc_seq__$2 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45865,(6),null);\nvar indent__$1 = new cljs.core.Keyword(null,\"indent\",\"indent\",-148200125).cljs$core$IFn$_invoke$arity$1((options__$2.cljs$core$IFn$_invoke$arity$1 ? options__$2.cljs$core$IFn$_invoke$arity$1(caller) : options__$2.call(null,caller)));\nvar indent_arg = new cljs.core.Keyword(null,\"indent-arg\",\"indent-arg\",58691874).cljs$core$IFn$_invoke$arity$1((options__$2.cljs$core$IFn$_invoke$arity$1 ? options__$2.cljs$core$IFn$_invoke$arity$1(caller) : options__$2.call(null,caller)));\nvar indent_only_QMARK_ = new cljs.core.Keyword(null,\"indent-only?\",\"indent-only?\",375678842).cljs$core$IFn$_invoke$arity$1((options__$2.cljs$core$IFn$_invoke$arity$1 ? options__$2.cljs$core$IFn$_invoke$arity$1(caller) : options__$2.call(null,caller)));\nvar indent__$2 = (cljs.core.truth_((zprint.zprint.body_set.cljs$core$IFn$_invoke$arity$1 ? zprint.zprint.body_set.cljs$core$IFn$_invoke$arity$1(fn_style__$5) : zprint.zprint.body_set.call(null,fn_style__$5)))?indent__$1:(function (){var or__4212__auto__ = indent_arg;\nif(cljs.core.truth_(or__4212__auto__)){\nreturn or__4212__auto__;\n} else {\nreturn indent__$1;\n}\n})());\nvar indent__$3 = (indent__$2 + (l_str_len__$1 - (1)));\nvar one_line_ok_QMARK_ = zprint.zprint.allow_one_line_QMARK_(options__$2,len__$3,fn_style__$5);\nvar one_line_ok_QMARK___$1 = (cljs.core.truth_(indent_only_QMARK_)?null:one_line_ok_QMARK_);\nvar one_line_ok_QMARK___$2 = ((cljs.core.not_EQ_.cljs$core$IFn$_invoke$arity$2(pre_arg_1_style_vec__$1,new cljs.core.Keyword(null,\"noseq\",\"noseq\",405935768)))?null:one_line_ok_QMARK___$1);\nvar fn_style__$6 = (function (){var or__4212__auto__ = (zprint.zprint.body_map.cljs$core$IFn$_invoke$arity$1 ? zprint.zprint.body_map.cljs$core$IFn$_invoke$arity$1(fn_style__$5) : zprint.zprint.body_map.call(null,fn_style__$5));\nif(cljs.core.truth_(or__4212__auto__)){\nreturn or__4212__auto__;\n} else {\nreturn fn_style__$5;\n}\n})();\nvar fn_style__$7 = (cljs.core.truth_((function (){var fexpr__45880 = new cljs.core.PersistentHashSet(null, new cljs.core.PersistentArrayMap(null, 5, [new cljs.core.Keyword(null,\"replace-w-string\",\"replace-w-string\",1411008615),null,new cljs.core.Keyword(null,\"flow\",\"flow\",590489032),null,new cljs.core.Keyword(null,\"binding\",\"binding\",539932593),null,new cljs.core.Keyword(null,\"hang\",\"hang\",-1007256173),null,new cljs.core.Keyword(null,\"flow-body\",\"flow-body\",1355242804),null], null), null);\nreturn (fexpr__45880.cljs$core$IFn$_invoke$arity$1 ? fexpr__45880.cljs$core$IFn$_invoke$arity$1(fn_style__$6) : fexpr__45880.call(null,fn_style__$6));\n})())?fn_style__$6:(((len__$3 < (3)))?null:fn_style__$6));\nvar fn_style__$8 = (cljs.core.truth_(no_arg1_QMARK_)?(function (){var or__4212__auto__ = (zprint.zprint.noarg1_map.cljs$core$IFn$_invoke$arity$1 ? zprint.zprint.noarg1_map.cljs$core$IFn$_invoke$arity$1(fn_style__$7) : zprint.zprint.noarg1_map.call(null,fn_style__$7));\nif(cljs.core.truth_(or__4212__auto__)){\nreturn or__4212__auto__;\n} else {\nreturn fn_style__$7;\n}\n})():fn_style__$7);\nvar options__$3 = (cljs.core.truth_(no_arg1_QMARK_)?cljs.core.dissoc.cljs$core$IFn$_invoke$arity$2(options__$2,new cljs.core.Keyword(null,\"no-arg1?\",\"no-arg1?\",1560368430)):options__$2);\nvar indent_adj = (l_str_len__$1 - (1));\nvar default_indent = (cljs.core.truth_((zprint.zfns.zlist_QMARK_.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zlist_QMARK_.cljs$core$IFn$_invoke$arity$1(arg_1_zloc__$2) : zprint.zfns.zlist_QMARK_.call(null,arg_1_zloc__$2)))?indent__$3:l_str_len__$1);\nvar arg_1_indent = (((!(arg_1_coll_QMARK_)))?((ind + (l_str_len__$1 + (1))) + cljs.core.count(fn_str)):null);\nvar arg_1_indent__$1 = (function (){var or__4212__auto__ = arg_1_indent;\nif(cljs.core.truth_(or__4212__auto__)){\nreturn or__4212__auto__;\n} else {\nif(cljs.core.truth_(arg_1_indent_alt_QMARK_)){\nreturn (indent__$3 + ind);\n} else {\nreturn null;\n}\n}\n})();\nvar arg_1_indent__$2 = ((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(pre_arg_2_style_vec,new cljs.core.Keyword(null,\"noseq\",\"noseq\",405935768)))?arg_1_indent__$1:(cljs.core.truth_(arg_1_indent__$1)?(indent__$3 + ind):null));\nvar options__$4 = (((!(arg_1_coll_QMARK_)))?cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(options__$3,new cljs.core.Keyword(null,\"in-code?\",\"in-code?\",194866464),fn_str):options__$3);\nvar options__$5 = cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(options__$4,new cljs.core.Keyword(null,\"pdepth\",\"pdepth\",-1943862342),(cljs.core.long$((function (){var or__4212__auto__ = new cljs.core.Keyword(null,\"pdepth\",\"pdepth\",-1943862342).cljs$core$IFn$_invoke$arity$1(options__$4);\nif(cljs.core.truth_(or__4212__auto__)){\nreturn or__4212__auto__;\n} else {\nreturn (0);\n}\n})()) + (1)));\nvar ___$1 = (cljs.core.truth_(new cljs.core.Keyword(null,\"dbg-hang\",\"dbg-hang\",-1928862076).cljs$core$IFn$_invoke$arity$1(options__$5))?cljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([zprint.zprint.dots(new cljs.core.Keyword(null,\"pdepth\",\"pdepth\",-1943862342).cljs$core$IFn$_invoke$arity$1(options__$5)),\"fzs\",fn_str], 0)):null);\nvar new_ind = (indent__$3 + ind);\nvar one_line_ind = (l_str_len__$1 + ind);\nvar options__$6 = (cljs.core.truth_(fn_style__$8)?cljs.core.dissoc.cljs$core$IFn$_invoke$arity$2(options__$5,new cljs.core.Keyword(null,\"fn-style\",\"fn-style\",1330516917)):options__$5);\nvar loptions = zprint.zprint.not_rightmost(options__$6);\nvar roptions = options__$6;\nvar l_str_vec = new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [l_str__$1,zprint.zprint.zcolor_map(options__$6,l_str__$1),new cljs.core.Keyword(null,\"left\",\"left\",-399115937)], null)], null);\nvar r_str_vec = zprint.zprint.rstr_vec.cljs$core$IFn$_invoke$arity$4(options__$6,(ind + (function (){var x__4295__auto__ = (0);\nvar y__4296__auto__ = (l_str_len__$1 - (1));\nreturn ((x__4295__auto__ > y__4296__auto__) ? x__4295__auto__ : y__4296__auto__);\n})()),zloc__$2,r_str__$1);\nvar ___$2 = (cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options__$6))?cljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options__$6),cljs.core.pr_str.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\"fzprint-list*:\",(zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1(zloc__$2) : zprint.zfns.zstring.call(null,zloc__$2)),\"fn-str\",fn_str,\"fn-style:\",fn_style__$8,\"len:\",len__$3,\"ind:\",ind,\"indent:\",indent__$3,\"default-indent:\",default_indent,\"one-line-ok?\",one_line_ok_QMARK___$2,\"arg-1-coll?\",arg_1_coll_QMARK_,\"arg-1-indent:\",arg_1_indent__$2,\"arg-1-zloc:\",(zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1(arg_1_zloc__$2) : zprint.zfns.zstring.call(null,arg_1_zloc__$2)),\"pre-arg-1-style-vec:\",pre_arg_1_style_vec__$1,\"l-str:\",[\"'\",cljs.core.str.cljs$core$IFn$_invoke$arity$1(l_str__$1),\"'\"].join(''),\"l-str-len:\",l_str_len__$1,\"r-str-vec:\",r_str_vec,\"indent-adj:\",indent_adj,\"one-line?:\",one_line_QMARK_,\"indent-only?:\",indent_only_QMARK_,\"rightcnt:\",new cljs.core.Keyword(null,\"rightcnt\",\"rightcnt\",-45750070).cljs$core$IFn$_invoke$arity$1(options__$6),\"replacement-string:\",new cljs.core.Keyword(null,\"replacement-string\",\"replacement-string\",-1920084419).cljs$core$IFn$_invoke$arity$1((caller.cljs$core$IFn$_invoke$arity$1 ? caller.cljs$core$IFn$_invoke$arity$1(options__$6) : caller.call(null,options__$6))),\":ztype:\",new cljs.core.Keyword(null,\"ztype\",\"ztype\",-562179020).cljs$core$IFn$_invoke$arity$1(options__$6)], 0))], 0)):null);\nvar one_line = (((((len__$3 === (0))) && (cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(pre_arg_1_style_vec__$1,new cljs.core.Keyword(null,\"noseq\",\"noseq\",405935768)))))?new cljs.core.Keyword(null,\"empty\",\"empty\",767870958):(cljs.core.truth_(one_line_ok_QMARK___$2)?zprint.zprint.fzprint_one_line(options__$6,one_line_ind,zloc_seq__$2):null));\nif(cljs.core.truth_(one_line)){\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(one_line,new cljs.core.Keyword(null,\"empty\",\"empty\",767870958))){\nreturn zprint.zprint.concat_no_nil.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([l_str_vec,r_str_vec], 0));\n} else {\nreturn zprint.zprint.concat_no_nil.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([l_str_vec,one_line,r_str_vec], 0));\n}\n} else {\nif(cljs.core.truth_(one_line_QMARK_)){\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options__$6))){\nreturn cljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options__$6),\"fzprint-list*:\",fn_str,\" one-line did not work!!!\"], 0));\n} else {\nreturn null;\n}\n} else {\nif(cljs.core.truth_((cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options__$6))?cljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options__$6),\"fzprint-list*: fn-style:\",fn_style__$8], 0)):null))){\nreturn null;\n} else {\nif(((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(len__$3,(0))) && (cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(pre_arg_1_style_vec__$1,new cljs.core.Keyword(null,\"noseq\",\"noseq\",405935768))))){\nreturn zprint.zprint.concat_no_nil.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([l_str_vec,r_str_vec], 0));\n} else {\nif(cljs.core.truth_(indent_only_QMARK_)){\nreturn zprint.zprint.concat_no_nil.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([l_str_vec,zprint.zprint.fzprint_indent.cljs$core$IFn$_invoke$arity$8(caller,l_str__$1,r_str__$1,options__$6,ind,zloc__$2,fn_style__$8,arg_1_indent__$2),r_str_vec], 0));\n} else {\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(len__$3,(1))){\nreturn zprint.zprint.concat_no_nil.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([l_str_vec,zprint.zprint.fzprint_flow_seq.cljs$core$IFn$_invoke$arity$3(roptions,one_line_ind,zloc_seq__$2),r_str_vec], 0));\n} else {\nif(cljs.core.truth_((function (){var and__4210__auto__ = cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(fn_style__$8,new cljs.core.Keyword(null,\"binding\",\"binding\",539932593));\nif(and__4210__auto__){\nvar and__4210__auto____$1 = (len__$3 > (1));\nif(and__4210__auto____$1){\nreturn (zprint.zfns.zvector_QMARK_.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zvector_QMARK_.cljs$core$IFn$_invoke$arity$1(arg_2_zloc) : zprint.zfns.zvector_QMARK_.call(null,arg_2_zloc));\n} else {\nreturn and__4210__auto____$1;\n}\n} else {\nreturn and__4210__auto__;\n}\n})())){\nvar vec__45894 = zprint.zprint.fzprint_hang_unless_fail(loptions,(function (){var or__4212__auto__ = arg_1_indent__$2;\nif(cljs.core.truth_(or__4212__auto__)){\nreturn or__4212__auto__;\n} else {\nreturn (indent__$3 + ind);\n}\n})(),(indent__$3 + ind),zprint.zprint.fzprint_binding_vec,arg_2_zloc);\nvar hang_or_flow = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45894,(0),null);\nvar binding_style_vec = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45894,(1),null);\nvar binding_style_vec__$1 = ((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(hang_or_flow,new cljs.core.Keyword(null,\"hang\",\"hang\",-1007256173)))?zprint.zprint.concat_no_nil.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 4, 5, cljs.core.PersistentVector.EMPTY_NODE, [\" \",new cljs.core.Keyword(null,\"none\",\"none\",1333468478),new cljs.core.Keyword(null,\"whitespace\",\"whitespace\",-1340035483),(14)], null)], null),binding_style_vec], 0)):binding_style_vec);\nreturn zprint.zprint.concat_no_nil.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([l_str_vec,pre_arg_1_style_vec__$1,(function (){var G__45900 = loptions;\nvar G__45901 = (ind + (1));\nvar G__45902 = arg_1_zloc__$2;\nreturn (zprint.zprint.fzprint_STAR_.cljs$core$IFn$_invoke$arity$3 ? zprint.zprint.fzprint_STAR_.cljs$core$IFn$_invoke$arity$3(G__45900,G__45901,G__45902) : zprint.zprint.fzprint_STAR_.call(null,G__45900,G__45901,G__45902));\n})(),pre_arg_2_style_vec,binding_style_vec__$1,zprint.zprint.concat_no_nil.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([zprint.zprint.fzprint_flow_seq.cljs$core$IFn$_invoke$arity$5(options__$6,(indent__$3 + ind),zprint.zprint.get_zloc_seq_right(second_data),new cljs.core.Keyword(null,\"force-nl\",\"force-nl\",-755040826),new cljs.core.Keyword(null,\"newline-first\",\"newline-first\",-638470720)),r_str_vec], 0))], 0));\n} else {\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(fn_style__$8,new cljs.core.Keyword(null,\"pair-fn\",\"pair-fn\",-360146586))){\nvar zloc_seq_right_first = zprint.zprint.get_zloc_seq_right(first_data__$1);\nvar zloc_count = cljs.core.count(zloc_seq__$2);\nreturn zprint.zprint.concat_no_nil.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([l_str_vec,pre_arg_1_style_vec__$1,(function (){var G__45903 = loptions;\nvar G__45904 = (ind + (1));\nvar G__45905 = arg_1_zloc__$2;\nreturn (zprint.zprint.fzprint_STAR_.cljs$core$IFn$_invoke$arity$3 ? zprint.zprint.fzprint_STAR_.cljs$core$IFn$_invoke$arity$3(G__45903,G__45904,G__45905) : zprint.zprint.fzprint_STAR_.call(null,G__45903,G__45904,G__45905));\n})(),zprint.zprint.fzprint_hang(cljs.core.assoc_in(options__$6,new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,\"pair\",\"pair\",-447516312),new cljs.core.Keyword(null,\"respect-nl?\",\"respect-nl?\",604814635)], null),new cljs.core.Keyword(null,\"respect-nl?\",\"respect-nl?\",604814635).cljs$core$IFn$_invoke$arity$1((caller.cljs$core$IFn$_invoke$arity$1 ? caller.cljs$core$IFn$_invoke$arity$1(options__$6) : caller.call(null,options__$6)))),new cljs.core.Keyword(null,\"pair-fn\",\"pair-fn\",-360146586),arg_1_indent__$2,(indent__$3 + ind),zprint.zprint.fzprint_pairs,zloc_count,zloc_seq_right_first),r_str_vec], 0));\n} else {\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(fn_style__$8,new cljs.core.Keyword(null,\"extend\",\"extend\",1836484006))){\nvar zloc_seq_right_first = zprint.zprint.get_zloc_seq_right(first_data__$1);\nreturn zprint.zprint.concat_no_nil.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([l_str_vec,pre_arg_1_style_vec__$1,(function (){var G__45906 = loptions;\nvar G__45907 = (ind + (1));\nvar G__45908 = arg_1_zloc__$2;\nreturn (zprint.zprint.fzprint_STAR_.cljs$core$IFn$_invoke$arity$3 ? zprint.zprint.fzprint_STAR_.cljs$core$IFn$_invoke$arity$3(G__45906,G__45907,G__45908) : zprint.zprint.fzprint_STAR_.call(null,G__45906,G__45907,G__45908));\n})(),zprint.zprint.prepend_nl(options__$6,(indent__$3 + ind),zprint.zprint.fzprint_extend(options__$6,(indent__$3 + ind),zloc_seq_right_first)),r_str_vec], 0));\n} else {\nif(((((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(fn_style__$8,new cljs.core.Keyword(null,\"fn\",\"fn\",-1175266204))) && (cljs.core.not((zprint.zfns.zlist_QMARK_.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zlist_QMARK_.cljs$core$IFn$_invoke$arity$1(arg_2_zloc) : zprint.zfns.zlist_QMARK_.call(null,arg_2_zloc)))))) || (((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(fn_style__$8,new cljs.core.Keyword(null,\"arg2\",\"arg2\",1729550917))) || (((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(fn_style__$8,new cljs.core.Keyword(null,\"arg2-fn\",\"arg2-fn\",1172769072))) || (((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(fn_style__$8,new cljs.core.Keyword(null,\"arg2-pair\",\"arg2-pair\",-1268132126))) || (cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(fn_style__$8,new cljs.core.Keyword(null,\"arg2-extend\",\"arg2-extend\",1554629186))))))))))){\nvar vec__45909 = zprint.zprint.fzprint_up_to_next_zloc(caller,options__$6,(ind + indent__$3),second_data);\nvar pre_arg_3_style_vec = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45909,(0),null);\nvar arg_3_zloc = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45909,(1),null);\nvar arg_3_count = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45909,(2),null);\nvar ___$3 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45909,(3),null);\nvar third_data = vec__45909;\nvar zloc_seq_right_third = zprint.zprint.get_zloc_seq_right(third_data);\nvar second_element = zprint.zprint.fzprint_hang_one(caller,((cljs.core.not(arg_3_zloc))?options__$6:loptions),arg_1_indent__$2,(indent__$3 + ind),arg_2_zloc);\nvar vec__45912 = zprint.zprint.style_lines(loptions,arg_1_indent__$2,second_element);\nvar line_count = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45912,(0),null);\nvar max_width = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45912,(1),null);\nvar first_three = (cljs.core.truth_(second_element)?(function (){var first_two_wo_pre_arg_1 = zprint.zprint.concat_no_nil.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([(function (){var G__45915 = loptions;\nvar G__45916 = (indent__$3 + ind);\nvar G__45917 = arg_1_zloc__$2;\nreturn (zprint.zprint.fzprint_STAR_.cljs$core$IFn$_invoke$arity$3 ? zprint.zprint.fzprint_STAR_.cljs$core$IFn$_invoke$arity$3(G__45915,G__45916,G__45917) : zprint.zprint.fzprint_STAR_.call(null,G__45915,G__45916,G__45917));\n})(),pre_arg_2_style_vec,second_element,pre_arg_3_style_vec], 0));\nvar local_options = ((cljs.core.not(zloc_seq_right_third))?options__$6:loptions);\nvar first_two_one_line_QMARK_ = zprint.zprint.fzfit_one_line(local_options,zprint.zprint.style_lines(local_options,(ind + indent__$3),first_two_wo_pre_arg_1));\nvar first_two = zprint.zprint.concat_no_nil.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([pre_arg_1_style_vec__$1,first_two_wo_pre_arg_1], 0));\nif(first_two_one_line_QMARK_){\n} else {\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options__$6))){\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options__$6),cljs.core.pr_str.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\"fzprint-list*: :arg2-* first two didn't fit:\",first_two], 0))], 0));\n} else {\n}\n}\n\nreturn zprint.zprint.concat_no_nil.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([first_two,(cljs.core.truth_((function (){var or__4212__auto__ = cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(fn_style__$8,new cljs.core.Keyword(null,\"arg2\",\"arg2\",1729550917));\nif(or__4212__auto__){\nreturn or__4212__auto__;\n} else {\nvar or__4212__auto____$1 = cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(fn_style__$8,new cljs.core.Keyword(null,\"arg2-pair\",\"arg2-pair\",-1268132126));\nif(or__4212__auto____$1){\nreturn or__4212__auto____$1;\n} else {\nvar or__4212__auto____$2 = cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(fn_style__$8,new cljs.core.Keyword(null,\"arg2-fn\",\"arg2-fn\",1172769072));\nif(or__4212__auto____$2){\nreturn or__4212__auto____$2;\n} else {\nvar or__4212__auto____$3 = cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(fn_style__$8,new cljs.core.Keyword(null,\"arg2-extend\",\"arg2-extend\",1554629186));\nif(or__4212__auto____$3){\nreturn or__4212__auto____$3;\n} else {\nvar and__4210__auto__ = (zprint.zfns.zvector_QMARK_.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zvector_QMARK_.cljs$core$IFn$_invoke$arity$1(arg_3_zloc) : zprint.zfns.zvector_QMARK_.call(null,arg_3_zloc));\nif(cljs.core.truth_(and__4210__auto__)){\nreturn cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(line_count,(1));\n} else {\nreturn and__4210__auto__;\n}\n}\n}\n}\n}\n})())?zprint.zprint.fzprint_hang_one(caller,((cljs.core.not(zloc_seq_right_third))?options__$6:loptions),((((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(pre_arg_3_style_vec,new cljs.core.Keyword(null,\"noseq\",\"noseq\",405935768))) && (first_two_one_line_QMARK_)))?max_width:(indent__$3 + ind)),(indent__$3 + ind),arg_3_zloc):zprint.zprint.prepend_nl(options__$6,(indent__$3 + ind),(function (){var G__45918 = ((cljs.core.not(zloc_seq_right_third))?options__$6:loptions);\nvar G__45919 = (indent__$3 + ind);\nvar G__45920 = arg_3_zloc;\nreturn (zprint.zprint.fzprint_STAR_.cljs$core$IFn$_invoke$arity$3 ? zprint.zprint.fzprint_STAR_.cljs$core$IFn$_invoke$arity$3(G__45918,G__45919,G__45920) : zprint.zprint.fzprint_STAR_.call(null,G__45918,G__45919,G__45920));\n})()))], 0));\n})():null);\nif(cljs.core.truth_(first_three)){\nif(cljs.core.not(zloc_seq_right_third)){\nreturn zprint.zprint.concat_no_nil.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([l_str_vec,first_three,r_str_vec], 0));\n} else {\nreturn zprint.zprint.concat_no_nil.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([l_str_vec,first_three,((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(fn_style__$8,new cljs.core.Keyword(null,\"arg2-pair\",\"arg2-pair\",-1268132126)))?zprint.zprint.prepend_nl(options__$6,(indent__$3 + ind),zprint.zprint.fzprint_pairs(options__$6,(indent__$3 + ind),zloc_seq_right_third)):((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(fn_style__$8,new cljs.core.Keyword(null,\"arg2-extend\",\"arg2-extend\",1554629186)))?zprint.zprint.prepend_nl(options__$6,(indent__$3 + ind),zprint.zprint.fzprint_extend(options__$6,(indent__$3 + ind),zloc_seq_right_third)):zprint.zprint.fzprint_hang_remaining.cljs$core$IFn$_invoke$arity$6(caller,((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(fn_style__$8,new cljs.core.Keyword(null,\"arg2-fn\",\"arg2-fn\",1172769072)))?cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(options__$6,new cljs.core.Keyword(null,\"fn-style\",\"fn-style\",1330516917),new cljs.core.Keyword(null,\"fn\",\"fn\",-1175266204)):options__$6),(indent__$3 + ind),(indent__$3 + ind),zloc_seq_right_third,fn_style__$8)\n)),r_str_vec], 0));\n}\n} else {\nreturn null;\n}\n} else {\nif(((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(fn_style__$8,new cljs.core.Keyword(null,\"arg1-mixin\",\"arg1-mixin\",1553512120))) && ((len__$3 > (3))))){\nvar vec__45921 = zprint.zprint.fzprint_up_to_next_zloc(caller,options__$6,(ind + indent__$3),second_data);\nvar pre_arg_3_style_vec = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45921,(0),null);\nvar arg_3_zloc = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45921,(1),null);\nvar arg_3_count = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45921,(2),null);\nvar ___$3 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45921,(3),null);\nvar third_data = vec__45921;\nvar vec__45924 = zprint.zprint.fzprint_up_to_next_zloc(caller,options__$6,(ind + indent__$3),third_data);\nvar pre_arg_4_style_vec = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45924,(0),null);\nvar arg_4_zloc = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45924,(1),null);\nvar arg_4_count = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45924,(2),null);\nvar ___$4 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45924,(3),null);\nvar fourth_data = vec__45924;\nvar arg_vec_index = (function (){var or__4212__auto__ = zprint.zprint.zfind_seq((function (p1__45850_SHARP_){\nvar or__4212__auto__ = (zprint.zfns.zvector_QMARK_.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zvector_QMARK_.cljs$core$IFn$_invoke$arity$1(p1__45850_SHARP_) : zprint.zfns.zvector_QMARK_.call(null,p1__45850_SHARP_));\nif(cljs.core.truth_(or__4212__auto__)){\nreturn or__4212__auto__;\n} else {\nif(cljs.core.truth_((zprint.zfns.zlist_QMARK_.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zlist_QMARK_.cljs$core$IFn$_invoke$arity$1(p1__45850_SHARP_) : zprint.zfns.zlist_QMARK_.call(null,p1__45850_SHARP_)))){\nvar G__45927 = (zprint.zfns.zfirst.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zfirst.cljs$core$IFn$_invoke$arity$1(p1__45850_SHARP_) : zprint.zfns.zfirst.call(null,p1__45850_SHARP_));\nreturn (zprint.zfns.zvector_QMARK_.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zvector_QMARK_.cljs$core$IFn$_invoke$arity$1(G__45927) : zprint.zfns.zvector_QMARK_.call(null,G__45927));\n} else {\nreturn null;\n}\n}\n}),zloc_seq__$2);\nif(cljs.core.truth_(or__4212__auto__)){\nreturn or__4212__auto__;\n} else {\nreturn (0);\n}\n})();\nvar doc_string_QMARK_ = typeof (zprint.zfns.zsexpr.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zsexpr.cljs$core$IFn$_invoke$arity$1(arg_3_zloc) : zprint.zfns.zsexpr.call(null,arg_3_zloc)) === 'string';\nvar mixin_start = ((doc_string_QMARK_)?arg_4_count:arg_3_count);\nvar mixin_length = ((arg_vec_index - mixin_start) - (1));\nvar mixins_QMARK_ = (mixin_length > (0));\nvar doc_string = ((doc_string_QMARK_)?zprint.zprint.fzprint_hang_one(caller,loptions,(indent__$3 + ind),(indent__$3 + ind),arg_3_zloc):null);\nvar mixins = ((mixins_QMARK_)?(function (){var mixin_sentinal = zprint.zprint.fzprint_hang_one(caller,loptions,(indent__$3 + ind),(indent__$3 + ind),((doc_string_QMARK_)?arg_4_zloc:arg_3_zloc));\nvar vec__45928 = zprint.zprint.style_lines(loptions,(indent__$3 + ind),mixin_sentinal);\nvar line_count = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45928,(0),null);\nvar max_width = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45928,(1),null);\nreturn zprint.zprint.concat_no_nil.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([((doc_string_QMARK_)?pre_arg_4_style_vec:pre_arg_3_style_vec),mixin_sentinal,zprint.zprint.fzprint_hang_remaining.cljs$core$IFn$_invoke$arity$7(caller,loptions,(max_width + (1)),(((indent__$3 + indent__$3) + ind) - (1)),zprint.zprint.get_zloc_seq_right((cljs.core.truth_(doc_string)?fourth_data:third_data)),fn_style__$8,mixin_length)], 0));\n})():null);\nreturn zprint.zprint.concat_no_nil.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([l_str_vec,pre_arg_1_style_vec__$1,(function (){var G__45931 = loptions;\nvar G__45932 = (ind + (1));\nvar G__45933 = arg_1_zloc__$2;\nreturn (zprint.zprint.fzprint_STAR_.cljs$core$IFn$_invoke$arity$3 ? zprint.zprint.fzprint_STAR_.cljs$core$IFn$_invoke$arity$3(G__45931,G__45932,G__45933) : zprint.zprint.fzprint_STAR_.call(null,G__45931,G__45932,G__45933));\n})(),pre_arg_2_style_vec,zprint.zprint.fzprint_hang_one(caller,((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(len__$3,(2)))?options__$6:loptions),arg_1_indent__$2,(indent__$3 + ind),arg_2_zloc),((((doc_string_QMARK_) && (mixins_QMARK_)))?zprint.zprint.concat_no_nil.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([pre_arg_3_style_vec,doc_string,zprint.zprint.remove_one_newline(mixins)], 0)):((doc_string_QMARK_)?zprint.zprint.concat_no_nil.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([pre_arg_3_style_vec,doc_string], 0)):((mixins_QMARK_)?zprint.zprint.remove_one_newline(mixins):new cljs.core.Keyword(null,\"noseq\",\"noseq\",405935768)\n))),zprint.zprint.fzprint_hang_remaining.cljs$core$IFn$_invoke$arity$6(caller,zprint.zprint.noarg1(options__$6,fn_style__$8),(indent__$3 + ind),(indent__$3 + ind),cljs.core.nthnext(zloc_seq__$2,((mixins_QMARK_)?arg_vec_index:((doc_string_QMARK_)?arg_4_count:arg_3_count))),fn_style__$8),r_str_vec], 0));\n} else {\nif(((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(fn_style__$8,new cljs.core.Keyword(null,\"arg1-pair\",\"arg1-pair\",-38672953))) || (((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(fn_style__$8,new cljs.core.Keyword(null,\"arg1\",\"arg1\",951899358))) || (((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(fn_style__$8,new cljs.core.Keyword(null,\"arg1-force-nl\",\"arg1-force-nl\",-945624718))) || (cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(fn_style__$8,new cljs.core.Keyword(null,\"arg1->\",\"arg1->\",1319654329))))))))){\nreturn zprint.zprint.concat_no_nil.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([l_str_vec,pre_arg_1_style_vec__$1,(function (){var G__45934 = loptions;\nvar G__45935 = (ind + (1));\nvar G__45936 = arg_1_zloc__$2;\nreturn (zprint.zprint.fzprint_STAR_.cljs$core$IFn$_invoke$arity$3 ? zprint.zprint.fzprint_STAR_.cljs$core$IFn$_invoke$arity$3(G__45934,G__45935,G__45936) : zprint.zprint.fzprint_STAR_.call(null,G__45934,G__45935,G__45936));\n})(),pre_arg_2_style_vec,zprint.zprint.fzprint_hang_one(caller,((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(len__$3,(2)))?options__$6:loptions),arg_1_indent__$2,(indent__$3 + ind),arg_2_zloc),((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(fn_style__$8,new cljs.core.Keyword(null,\"arg1-pair\",\"arg1-pair\",-38672953)))?zprint.zprint.prepend_nl(options__$6,(indent__$3 + ind),zprint.zprint.fzprint_pairs(options__$6,(indent__$3 + ind),zprint.zprint.get_zloc_seq_right(second_data))):zprint.zprint.fzprint_hang_remaining.cljs$core$IFn$_invoke$arity$6(caller,zprint.zprint.noarg1(options__$6,fn_style__$8),(indent__$3 + ind),(indent__$3 + ind),zprint.zprint.get_zloc_seq_right(second_data),fn_style__$8)),r_str_vec], 0));\n} else {\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(fn_style__$8,new cljs.core.Keyword(null,\"arg1-extend\",\"arg1-extend\",-157225050))){\nvar zloc_seq_right_second = zprint.zprint.get_zloc_seq_right(second_data);\nif(cljs.core.truth_((zprint.zfns.zvector_QMARK_.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zvector_QMARK_.cljs$core$IFn$_invoke$arity$1(arg_2_zloc) : zprint.zfns.zvector_QMARK_.call(null,arg_2_zloc)))){\nreturn zprint.zprint.concat_no_nil.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([l_str_vec,pre_arg_1_style_vec__$1,(function (){var G__45937 = loptions;\nvar G__45938 = (indent__$3 + ind);\nvar G__45939 = arg_1_zloc__$2;\nreturn (zprint.zprint.fzprint_STAR_.cljs$core$IFn$_invoke$arity$3 ? zprint.zprint.fzprint_STAR_.cljs$core$IFn$_invoke$arity$3(G__45937,G__45938,G__45939) : zprint.zprint.fzprint_STAR_.call(null,G__45937,G__45938,G__45939));\n})(),pre_arg_2_style_vec,zprint.zprint.prepend_nl(options__$6,(indent__$3 + ind),(function (){var G__45940 = loptions;\nvar G__45941 = (indent__$3 + ind);\nvar G__45942 = arg_2_zloc;\nreturn (zprint.zprint.fzprint_STAR_.cljs$core$IFn$_invoke$arity$3 ? zprint.zprint.fzprint_STAR_.cljs$core$IFn$_invoke$arity$3(G__45940,G__45941,G__45942) : zprint.zprint.fzprint_STAR_.call(null,G__45940,G__45941,G__45942));\n})()),zprint.zprint.prepend_nl(options__$6,(indent__$3 + ind),zprint.zprint.fzprint_extend(options__$6,(indent__$3 + ind),zloc_seq_right_second)),r_str_vec], 0));\n} else {\nreturn zprint.zprint.concat_no_nil.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([l_str_vec,pre_arg_1_style_vec__$1,(function (){var G__45943 = loptions;\nvar G__45944 = (ind + (1));\nvar G__45945 = arg_1_zloc__$2;\nreturn (zprint.zprint.fzprint_STAR_.cljs$core$IFn$_invoke$arity$3 ? zprint.zprint.fzprint_STAR_.cljs$core$IFn$_invoke$arity$3(G__45943,G__45944,G__45945) : zprint.zprint.fzprint_STAR_.call(null,G__45943,G__45944,G__45945));\n})(),pre_arg_2_style_vec,zprint.zprint.fzprint_hang_one(caller,((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(len__$3,(2)))?options__$6:loptions),arg_1_indent__$2,(indent__$3 + ind),arg_2_zloc),zprint.zprint.prepend_nl(options__$6,(indent__$3 + ind),zprint.zprint.fzprint_extend(options__$6,(indent__$3 + ind),zloc_seq_right_second)),r_str_vec], 0));\n\n}\n} else {\nreturn zprint.zprint.concat_no_nil.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([l_str_vec,pre_arg_1_style_vec__$1,(((!((len__$3 === (0)))))?(function (){var G__45946 = loptions;\nvar G__45947 = (l_str_len__$1 + ind);\nvar G__45948 = arg_1_zloc__$2;\nreturn (zprint.zprint.fzprint_STAR_.cljs$core$IFn$_invoke$arity$3 ? zprint.zprint.fzprint_STAR_.cljs$core$IFn$_invoke$arity$3(G__45946,G__45947,G__45948) : zprint.zprint.fzprint_STAR_.call(null,G__45946,G__45947,G__45948));\n})():new cljs.core.Keyword(null,\"noseq\",\"noseq\",405935768)),(((!((len__$3 === (0)))))?(function (){var zloc_seq_right_first = zprint.zprint.get_zloc_seq_right(first_data__$1);\nif(zloc_seq_right_first){\nif(cljs.core.truth_((function (){var and__4210__auto__ = arg_1_indent__$2;\nif(cljs.core.truth_(and__4210__auto__)){\nreturn cljs.core.not_EQ_.cljs$core$IFn$_invoke$arity$2(fn_style__$8,new cljs.core.Keyword(null,\"flow\",\"flow\",590489032));\n} else {\nreturn and__4210__auto__;\n}\n})())){\nvar result = zprint.zprint.fzprint_hang_remaining.cljs$core$IFn$_invoke$arity$6(caller,zprint.zprint.noarg1(options__$6,fn_style__$8),arg_1_indent__$2,((indent__$3 + ind) + indent_adj),zloc_seq_right_first,fn_style__$8);\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options__$6))){\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options__$6),cljs.core.pr_str.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\"fzprint-list*: r-str-vec:\",r_str_vec,\"result:\",result], 0))], 0));\n} else {\n}\n\nreturn result;\n} else {\nvar local_indent = ((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(fn_style__$8,new cljs.core.Keyword(null,\"flow\",\"flow\",590489032)))?(indent__$3 + ind):((default_indent + ind) + indent_adj));\nreturn zprint.zprint.concat_no_nil.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([zprint.zprint.fzprint_flow_seq.cljs$core$IFn$_invoke$arity$5(zprint.zprint.noarg1(options__$6,fn_style__$8),local_indent,zloc_seq_right_first,new cljs.core.Keyword(null,\"force-nl\",\"force-nl\",-755040826),new cljs.core.Keyword(null,\"newline-first\",\"newline-first\",-638470720))], 0));\n}\n} else {\nreturn new cljs.core.Keyword(null,\"noseq\",\"noseq\",405935768);\n}\n})():new cljs.core.Keyword(null,\"noseq\",\"noseq\",405935768)),r_str_vec], 0));\n\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n});\n/**\n * Pretty print and focus style a :list element.\n */\nzprint.zprint.fzprint_list = (function zprint$zprint$fzprint_list(options,ind,zloc){\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options))){\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),cljs.core.pr_str.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\"fzprint-list\"], 0))], 0));\n} else {\n}\n\nreturn zprint.zprint.fzprint_list_STAR_(new cljs.core.Keyword(null,\"list\",\"list\",765357683),\"(\",\")\",zprint.zprint.rightmost(options),ind,zloc);\n});\n/**\n * Pretty print and focus style a fn element.\n */\nzprint.zprint.fzprint_anon_fn = (function zprint$zprint$fzprint_anon_fn(options,ind,zloc){\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options))){\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),cljs.core.pr_str.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\"fzprint-anon-fn\"], 0))], 0));\n} else {\n}\n\nreturn zprint.zprint.fzprint_list_STAR_(new cljs.core.Keyword(null,\"list\",\"list\",765357683),\"#(\",\")\",zprint.zprint.rightmost(options),ind,zloc);\n});\n/**\n * Return true if there are any collections in the collection.\n */\nzprint.zprint.any_zcoll_QMARK_ = (function zprint$zprint$any_zcoll_QMARK_(options,ind,zloc){\nvar coll_QMARK__seq = (zprint.zfns.zmap.cljs$core$IFn$_invoke$arity$2 ? zprint.zfns.zmap.cljs$core$IFn$_invoke$arity$2(zprint.zfns.zcoll_QMARK_,zloc) : zprint.zfns.zmap.call(null,zprint.zfns.zcoll_QMARK_,zloc));\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3((function (p1__45949_SHARP_,p2__45950_SHARP_){\nvar or__4212__auto__ = p1__45949_SHARP_;\nif(cljs.core.truth_(or__4212__auto__)){\nreturn or__4212__auto__;\n} else {\nreturn p2__45950_SHARP_;\n}\n}),null,coll_QMARK__seq);\n});\n/**\n * Given the output from fzprint-seq, which is a style-vec in\n *   the making without spacing, but with extra [] around the elements,\n *   wrap the elements to the right margin.\n */\nzprint.zprint.wrap_zmap = (function zprint$zprint$wrap_zmap(caller,p__45951,ind,coll_print){\nvar map__45952 = p__45951;\nvar map__45952__$1 = cljs.core.__destructure_map(map__45952);\nvar options = map__45952__$1;\nvar map__45953 = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__45952__$1,caller);\nvar map__45953__$1 = cljs.core.__destructure_map(map__45953);\nvar wrap_after_multi_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__45953__$1,new cljs.core.Keyword(null,\"wrap-after-multi?\",\"wrap-after-multi?\",1010808052));\nvar respect_nl_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__45953__$1,new cljs.core.Keyword(null,\"respect-nl?\",\"respect-nl?\",604814635));\nvar width = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__45952__$1,new cljs.core.Keyword(null,\"width\",\"width\",-384071477));\nvar rightcnt = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__45952__$1,new cljs.core.Keyword(null,\"rightcnt\",\"rightcnt\",-45750070));\nvar last_index = (cljs.core.count(coll_print) - (1));\nvar rightcnt__$1 = zprint.zprint.fix_rightcnt(rightcnt);\nvar cur_seq = coll_print;\nvar cur_ind = ind;\nvar index = (0);\nvar previous_newline_QMARK_ = false;\nvar out = cljs.core.PersistentVector.EMPTY;\nwhile(true){\nif(cljs.core.not(cur_seq)){\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options))){\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),cljs.core.pr_str.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\"wrap-zmap: out:\",out], 0))], 0));\n} else {\n}\n\nreturn out;\n} else {\nvar next_seq = cljs.core.first(cur_seq);\nif(cljs.core.truth_(next_seq)){\nvar multi_QMARK_ = (cljs.core.count(cljs.core.first(cur_seq)) > (1));\nvar this_seq = cljs.core.first(cur_seq);\nvar _ = zprint.zprint.log_lines(options,\"wrap-zmap:\",ind,this_seq);\nvar ___$1 = (cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options))?cljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),cljs.core.pr_str.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\"wrap-zmap: ind:\",ind,\"this-seq:\",this_seq], 0))], 0)):null);\nvar vec__45957 = zprint.zprint.style_lines(options,ind,this_seq);\nvar linecnt = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45957,(0),null);\nvar max_width = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45957,(1),null);\nvar lines = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45957,(2),null);\nvar last_width = cljs.core.last(lines);\nvar len = (last_width - ind);\nvar len__$1 = (function (){var x__4295__auto__ = (0);\nvar y__4296__auto__ = len;\nreturn ((x__4295__auto__ > y__4296__auto__) ? x__4295__auto__ : y__4296__auto__);\n})();\nvar newline_QMARK_ = cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(cljs.core.nth.cljs$core$IFn$_invoke$arity$2(cljs.core.first(this_seq),(2)),new cljs.core.Keyword(null,\"newline\",\"newline\",1790071323));\nvar comment_QMARK_ = (cljs.core.truth_(respect_nl_QMARK_)?null:cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(cljs.core.nth.cljs$core$IFn$_invoke$arity$2(cljs.core.first(this_seq),(2)),new cljs.core.Keyword(null,\"comment\",\"comment\",532206069)));\nvar comment_inline_QMARK_ = (cljs.core.truth_(respect_nl_QMARK_)?null:cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(cljs.core.nth.cljs$core$IFn$_invoke$arity$2(cljs.core.first(this_seq),(2)),new cljs.core.Keyword(null,\"comment-inline\",\"comment-inline\",712944405)));\nvar width__$1 = ((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(index,last_index))?(width - rightcnt__$1):width);\nvar fit_QMARK_ = (function (){var and__4210__auto__ = (!(newline_QMARK_));\nif(and__4210__auto__){\nvar and__4210__auto____$1 = (((index === (0))) || (cljs.core.not(comment_QMARK_)));\nif(and__4210__auto____$1){\nvar or__4212__auto__ = (index === (0));\nif(or__4212__auto__){\nreturn or__4212__auto__;\n} else {\nvar and__4210__auto____$2 = ((multi_QMARK_)?cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(linecnt,(1)):true);\nif(and__4210__auto____$2){\nreturn ((cur_ind + len__$1) <= width__$1);\n} else {\nreturn and__4210__auto____$2;\n}\n}\n} else {\nreturn and__4210__auto____$1;\n}\n} else {\nreturn and__4210__auto__;\n}\n})();\nvar new_ind = (cljs.core.truth_((function (){var or__4212__auto__ = comment_QMARK_;\nif(cljs.core.truth_(or__4212__auto__)){\nreturn or__4212__auto__;\n} else {\nreturn comment_inline_QMARK_;\n}\n})())?(width__$1 + (1)):((((multi_QMARK_) && ((((linecnt > (1))) && (cljs.core.not(wrap_after_multi_QMARK_))))))?width__$1:((fit_QMARK_)?((cur_ind + len__$1) + (1)):((newline_QMARK_)?ind:((ind + len__$1) + (1))\n))));\nvar G__46548 = cljs.core.next(cur_seq);\nvar G__46549 = new_ind;\nvar G__46550 = (index + (1));\nvar G__46551 = newline_QMARK_;\nvar G__46552 = cljs.core.concat.cljs$core$IFn$_invoke$arity$2(out,((fit_QMARK_)?(((!((index === (0)))))?zprint.zprint.concat_no_nil.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 4, 5, cljs.core.PersistentVector.EMPTY_NODE, [\" \",new cljs.core.Keyword(null,\"none\",\"none\",1333468478),new cljs.core.Keyword(null,\"whitespace\",\"whitespace\",-1340035483),(15)], null)], null),this_seq], 0)):this_seq):((newline_QMARK_)?new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 4, 5, cljs.core.PersistentVector.EMPTY_NODE, [[\"\\n\",cljs.core.str.cljs$core$IFn$_invoke$arity$1(zprint.zprint.blanks((function (){var this_seq_next = cljs.core.first(cljs.core.next(cur_seq));\nvar newline_QMARK___$1 = (cljs.core.truth_(this_seq_next)?cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(cljs.core.nth.cljs$core$IFn$_invoke$arity$2(cljs.core.first(this_seq_next),(2)),new cljs.core.Keyword(null,\"newline\",\"newline\",1790071323)):null);\nif(cljs.core.truth_(newline_QMARK___$1)){\nreturn (0);\n} else {\nreturn (new_ind - (1));\n}\n})()))].join(''),new cljs.core.Keyword(null,\"none\",\"none\",1333468478),new cljs.core.Keyword(null,\"indent\",\"indent\",-148200125),(21)], null)], null):((previous_newline_QMARK_)?zprint.zprint.concat_no_nil.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 4, 5, cljs.core.PersistentVector.EMPTY_NODE, [\" \",new cljs.core.Keyword(null,\"none\",\"none\",1333468478),new cljs.core.Keyword(null,\"whitespace\",\"whitespace\",-1340035483),(16)], null)], null),this_seq], 0)):zprint.zprint.prepend_nl(options,ind,this_seq)))));\ncur_seq = G__46548;\ncur_ind = G__46549;\nindex = G__46550;\nprevious_newline_QMARK_ = G__46551;\nout = G__46552;\ncontinue;\n} else {\nreturn null;\n}\n}\nbreak;\n}\n});\n/**\n * Remove any [_ _ :newline] from the seq.\n */\nzprint.zprint.remove_nl = (function zprint$zprint$remove_nl(coll){\nreturn cljs.core.remove.cljs$core$IFn$_invoke$arity$2((function (p1__45960_SHARP_){\nreturn cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(cljs.core.nth.cljs$core$IFn$_invoke$arity$2(cljs.core.first(p1__45960_SHARP_),(2)),new cljs.core.Keyword(null,\"newline\",\"newline\",1790071323));\n}),coll);\n});\n/**\n * Validate an options map that was returned from some internal configuration\n *   expression or configuration.  Either returns the options map or throws\n *   an error.\n */\nzprint.zprint.internal_validate = (function zprint$zprint$internal_validate(options,error_str){\nvar errors = zprint.config.validate_options.cljs$core$IFn$_invoke$arity$1(options);\nvar errors__$1 = (cljs.core.truth_(errors)?[\"Options resulting from \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(error_str),\" had these errors: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(errors)].join(''):null);\nif((!(cljs.core.empty_QMARK_(errors__$1)))){\nthrow (new Error(errors__$1));\n} else {\nreturn options;\n}\n});\nzprint.zprint.lazy_sexpr_seq = (function zprint$zprint$lazy_sexpr_seq(nws_seq){\nif(cljs.core.seq(nws_seq)){\nreturn cljs.core.concat.cljs$core$IFn$_invoke$arity$2((new cljs.core.LazySeq(null,(function (){\nreturn new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [(function (){var G__45961 = cljs.core.first(nws_seq);\nreturn (zprint.zfns.zsexpr.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zsexpr.cljs$core$IFn$_invoke$arity$1(G__45961) : zprint.zfns.zsexpr.call(null,G__45961));\n})()], null);\n}),null,null)),(new cljs.core.LazySeq(null,(function (){\nvar G__45962 = cljs.core.rest(nws_seq);\nreturn (zprint.zprint.lazy_sexpr_seq.cljs$core$IFn$_invoke$arity$1 ? zprint.zprint.lazy_sexpr_seq.cljs$core$IFn$_invoke$arity$1(G__45962) : zprint.zprint.lazy_sexpr_seq.call(null,G__45962));\n}),null,null)));\n} else {\nreturn cljs.core.PersistentVector.EMPTY;\n}\n});\n/**\n * If there are any comments at the top level of the zloc-seq, return true,\n *   else nil.\n */\nzprint.zprint.comment_in_zloc_seq_QMARK_ = (function zprint$zprint$comment_in_zloc_seq_QMARK_(zloc_seq){\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3((function (p1__45964_SHARP_,p2__45963_SHARP_){\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2((zprint.zfns.ztag.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.ztag.cljs$core$IFn$_invoke$arity$1(p2__45963_SHARP_) : zprint.zfns.ztag.call(null,p2__45963_SHARP_)),new cljs.core.Keyword(null,\"comment\",\"comment\",532206069))){\nreturn cljs.core.reduced(true);\n} else {\nreturn null;\n}\n}),false,zloc_seq);\n});\n/**\n * Print basic stuff like a vector or a set or an array.  Several options \n *   for how to print them.\n */\nzprint.zprint.fzprint_vec_STAR_ = (function zprint$zprint$fzprint_vec_STAR_(caller,l_str,r_str,p__45965,ind,zloc){\nvar map__45966 = p__45965;\nvar map__45966__$1 = cljs.core.__destructure_map(map__45966);\nvar options = map__45966__$1;\nvar map__45967 = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__45966__$1,caller);\nvar map__45967__$1 = cljs.core.__destructure_map(map__45967);\nvar sort_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__45967__$1,new cljs.core.Keyword(null,\"sort?\",\"sort?\",-567661924));\nvar sort_in_code_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__45967__$1,new cljs.core.Keyword(null,\"sort-in-code?\",\"sort-in-code?\",111878497));\nvar wrap_coll_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__45967__$1,new cljs.core.Keyword(null,\"wrap-coll?\",\"wrap-coll?\",908181571));\nvar indent = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__45967__$1,new cljs.core.Keyword(null,\"indent\",\"indent\",-148200125));\nvar option_fn = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__45967__$1,new cljs.core.Keyword(null,\"option-fn\",\"option-fn\",-959705456));\nvar wrap_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__45967__$1,new cljs.core.Keyword(null,\"wrap?\",\"wrap?\",-1677427054));\nvar binding_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__45967__$1,new cljs.core.Keyword(null,\"binding?\",\"binding?\",-1071925644));\nvar option_fn_first = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__45967__$1,new cljs.core.Keyword(null,\"option-fn-first\",\"option-fn-first\",-1679196201));\nvar fn_format = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__45967__$1,new cljs.core.Keyword(null,\"fn-format\",\"fn-format\",-1408187784));\nvar rightcnt = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__45966__$1,new cljs.core.Keyword(null,\"rightcnt\",\"rightcnt\",-45750070));\nvar in_code_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__45966__$1,new cljs.core.Keyword(null,\"in-code?\",\"in-code?\",194866464));\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options))){\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),\"fzprint-vec* ind:\",ind,\"indent:\",indent,\"caller:\",caller], 0));\n} else {\n}\n\nif(cljs.core.truth_((function (){var and__4210__auto__ = binding_QMARK_;\nif(cljs.core.truth_(and__4210__auto__)){\nreturn cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(new cljs.core.Keyword(null,\"depth\",\"depth\",1768663640).cljs$core$IFn$_invoke$arity$1(options),(1));\n} else {\nreturn and__4210__auto__;\n}\n})())){\nreturn zprint.zprint.fzprint_binding_vec(options,ind,zloc);\n} else {\nvar vec__45968 = zprint.zprint.get_respect_indent(options,caller,new cljs.core.Keyword(null,\"vector\",\"vector\",1902966158));\nvar respect_nl_QMARK_ = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45968,(0),null);\nvar respect_bl_QMARK_ = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45968,(1),null);\nvar indent_only_QMARK_ = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45968,(2),null);\nvar l_str_len = cljs.core.count(l_str);\nvar l_str_vec = new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [l_str,zprint.zprint.zcolor_map(options,l_str),new cljs.core.Keyword(null,\"left\",\"left\",-399115937)], null)], null);\nvar r_str_vec = zprint.zprint.rstr_vec.cljs$core$IFn$_invoke$arity$4(options,(ind + (function (){var x__4295__auto__ = (0);\nvar y__4296__auto__ = (l_str_len - (1));\nreturn ((x__4295__auto__ > y__4296__auto__) ? x__4295__auto__ : y__4296__auto__);\n})()),zloc,r_str);\nvar len = (zprint.zfns.zcount.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zcount.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zcount.call(null,zloc));\nvar new_options = (cljs.core.truth_(option_fn_first)?(function (){var first_sexpr = (function (){var G__45973 = (zprint.zfns.zfirst_no_comment.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zfirst_no_comment.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zfirst_no_comment.call(null,zloc));\nreturn (zprint.zfns.zsexpr.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zsexpr.cljs$core$IFn$_invoke$arity$1(G__45973) : zprint.zfns.zsexpr.call(null,G__45973));\n})();\nreturn zprint.zprint.internal_validate((option_fn_first.cljs$core$IFn$_invoke$arity$2 ? option_fn_first.cljs$core$IFn$_invoke$arity$2(options,first_sexpr) : option_fn_first.call(null,options,first_sexpr)),[\":vector :option-fn-first called with \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(first_sexpr)].join(''));\n})():null);\nvar _ = (cljs.core.truth_(option_fn_first)?(cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options))?cljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),cljs.core.pr_str.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\"fzprint-vec* option-fn-first new options\",new_options], 0))], 0)):null):null);\nvar options__$1 = zprint.config.merge_deep.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([options,new_options], 0));\nvar new_options__$1 = (cljs.core.truth_(option_fn)?(function (){var nws_seq = cljs.core.remove.cljs$core$IFn$_invoke$arity$2(zprint.zfns.zwhitespaceorcomment_QMARK_,(zprint.zfns.zseqnws.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zseqnws.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zseqnws.call(null,zloc)));\nvar nws_count = cljs.core.count(nws_seq);\nvar sexpr_seq = zprint.zprint.lazy_sexpr_seq(nws_seq);\nreturn zprint.zprint.internal_validate((option_fn.cljs$core$IFn$_invoke$arity$3 ? option_fn.cljs$core$IFn$_invoke$arity$3(options__$1,nws_count,sexpr_seq) : option_fn.call(null,options__$1,nws_count,sexpr_seq)),[\":vector :option-fn called with sexpr count \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(nws_count)].join(''));\n})():null);\nvar ___$1 = (cljs.core.truth_(option_fn)?(cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options__$1))?cljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options__$1),cljs.core.pr_str.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\"fzprint-vec* option-fn new options\",new_options__$1], 0))], 0)):null):null);\nvar map__45971 = zprint.config.merge_deep.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([options__$1,new_options__$1], 0));\nvar map__45971__$1 = cljs.core.__destructure_map(map__45971);\nvar options__$2 = map__45971__$1;\nvar map__45972 = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__45971__$1,caller);\nvar map__45972__$1 = cljs.core.__destructure_map(map__45972);\nvar indent_only_QMARK___$1 = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__45972__$1,new cljs.core.Keyword(null,\"indent-only?\",\"indent-only?\",375678842));\nvar sort_QMARK___$1 = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__45972__$1,new cljs.core.Keyword(null,\"sort?\",\"sort?\",-567661924));\nvar sort_in_code_QMARK___$1 = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__45972__$1,new cljs.core.Keyword(null,\"sort-in-code?\",\"sort-in-code?\",111878497));\nvar wrap_coll_QMARK___$1 = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__45972__$1,new cljs.core.Keyword(null,\"wrap-coll?\",\"wrap-coll?\",908181571));\nvar indent__$1 = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__45972__$1,new cljs.core.Keyword(null,\"indent\",\"indent\",-148200125));\nvar respect_nl_QMARK___$1 = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__45972__$1,new cljs.core.Keyword(null,\"respect-nl?\",\"respect-nl?\",604814635));\nvar respect_bl_QMARK___$1 = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__45972__$1,new cljs.core.Keyword(null,\"respect-bl?\",\"respect-bl?\",298921998));\nvar wrap_QMARK___$1 = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__45972__$1,new cljs.core.Keyword(null,\"wrap?\",\"wrap?\",-1677427054));\nvar binding_QMARK___$1 = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__45972__$1,new cljs.core.Keyword(null,\"binding?\",\"binding?\",-1071925644));\nvar fn_format__$1 = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__45972__$1,new cljs.core.Keyword(null,\"fn-format\",\"fn-format\",-1408187784));\nif(cljs.core.truth_(fn_format__$1)){\nreturn zprint.zprint.fzprint_list_STAR_(new cljs.core.Keyword(null,\"vector-fn\",\"vector-fn\",1515528250),\"[\",\"]\",cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(options__$2,new cljs.core.Keyword(null,\"fn-style\",\"fn-style\",1330516917),fn_format__$1),ind,zloc);\n} else {\nvar indent__$2 = (function (){var or__4212__auto__ = indent__$1;\nif(cljs.core.truth_(or__4212__auto__)){\nreturn or__4212__auto__;\n} else {\nreturn cljs.core.count(l_str);\n}\n})();\nvar new_ind = (cljs.core.truth_(indent_only_QMARK___$1)?ind:(indent__$2 + ind));\nvar ___$2 = (cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options__$2))?cljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options__$2),cljs.core.pr_str.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\"fzprint-vec*:\",(zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zstring.call(null,zloc)),\"new-ind:\",new_ind], 0))], 0)):null);\nvar zloc_seq = (cljs.core.truth_((function (){var or__4212__auto__ = respect_nl_QMARK___$1;\nif(cljs.core.truth_(or__4212__auto__)){\nreturn or__4212__auto__;\n} else {\nreturn indent_only_QMARK___$1;\n}\n})())?(zprint.zfns.zmap_w_nl.cljs$core$IFn$_invoke$arity$2 ? zprint.zfns.zmap_w_nl.cljs$core$IFn$_invoke$arity$2(cljs.core.identity,zloc) : zprint.zfns.zmap_w_nl.call(null,cljs.core.identity,zloc)):(cljs.core.truth_(respect_bl_QMARK___$1)?(zprint.zfns.zmap_w_bl.cljs$core$IFn$_invoke$arity$2 ? zprint.zfns.zmap_w_bl.cljs$core$IFn$_invoke$arity$2(cljs.core.identity,zloc) : zprint.zfns.zmap_w_bl.call(null,cljs.core.identity,zloc)):(zprint.zfns.zmap.cljs$core$IFn$_invoke$arity$2 ? zprint.zfns.zmap.cljs$core$IFn$_invoke$arity$2(cljs.core.identity,zloc) : zprint.zfns.zmap.call(null,cljs.core.identity,zloc))\n));\nvar zloc_seq__$1 = (cljs.core.truth_((function (){var and__4210__auto__ = sort_QMARK___$1;\nif(cljs.core.truth_(and__4210__auto__)){\nvar and__4210__auto____$1 = (cljs.core.truth_(in_code_QMARK_)?sort_in_code_QMARK___$1:true);\nif(cljs.core.truth_(and__4210__auto____$1)){\nreturn ((cljs.core.not(zprint.zprint.comment_in_zloc_seq_QMARK_(zloc_seq))) && (((cljs.core.not(respect_nl_QMARK___$1)) && (((cljs.core.not(respect_bl_QMARK___$1)) && (cljs.core.not(indent_only_QMARK___$1)))))));\n} else {\nreturn and__4210__auto____$1;\n}\n} else {\nreturn and__4210__auto__;\n}\n})())?zprint.zprint.order_out(caller,options__$2,cljs.core.identity,zloc_seq):zloc_seq);\nvar coll_print = (((len === (0)))?new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 4, 5, cljs.core.PersistentVector.EMPTY_NODE, [\"\",new cljs.core.Keyword(null,\"none\",\"none\",1333468478),new cljs.core.Keyword(null,\"whitespace\",\"whitespace\",-1340035483),(17)], null)], null)], null):zprint.zprint.fzprint_seq(options__$2,new_ind,zloc_seq__$1));\nvar ___$3 = (cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options__$2))?cljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options__$2),cljs.core.pr_str.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\"fzprint-vec*: coll-print:\",coll_print], 0))], 0)):null);\nvar coll_print__$1 = ((cljs.core.not(zprint.zprint.contains_nil_QMARK_(coll_print)))?coll_print:null);\nvar one_line = (cljs.core.truth_(coll_print__$1)?cljs.core.apply.cljs$core$IFn$_invoke$arity$2(zprint.zprint.concat_no_nil,cljs.core.interpose.cljs$core$IFn$_invoke$arity$2(new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 4, 5, cljs.core.PersistentVector.EMPTY_NODE, [\" \",new cljs.core.Keyword(null,\"none\",\"none\",1333468478),new cljs.core.Keyword(null,\"whitespace\",\"whitespace\",-1340035483),(18)], null)], null),(cljs.core.truth_((function (){var or__4212__auto__ = respect_nl_QMARK___$1;\nif(cljs.core.truth_(or__4212__auto__)){\nreturn or__4212__auto__;\n} else {\nvar or__4212__auto____$1 = new cljs.core.Keyword(null,\"respect-bl?\",\"respect-bl?\",298921998);\nif(cljs.core.truth_(or__4212__auto____$1)){\nreturn or__4212__auto____$1;\n} else {\nreturn indent_only_QMARK___$1;\n}\n}\n})())?coll_print__$1:zprint.zprint.remove_nl(coll_print__$1)))):null);\nvar ___$4 = zprint.zprint.log_lines(options__$2,\"fzprint-vec*:\",new_ind,one_line);\nvar ___$5 = (cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options__$2))?cljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options__$2),cljs.core.pr_str.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\"fzprint-vec*: new-ind:\",new_ind,\"one-line:\",one_line], 0))], 0)):null);\nvar one_line_lines = zprint.zprint.style_lines(options__$2,new_ind,one_line);\nif((len === (0))){\nreturn zprint.zprint.concat_no_nil.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([l_str_vec,r_str_vec], 0));\n} else {\nif(cljs.core.truth_(one_line_lines)){\nif(zprint.zprint.fzfit_one_line(options__$2,one_line_lines)){\nreturn zprint.zprint.concat_no_nil.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([l_str_vec,one_line,r_str_vec], 0));\n} else {\nif(cljs.core.truth_(indent_only_QMARK___$1)){\nreturn zprint.zprint.concat_no_nil.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([l_str_vec,zprint.zprint.indent_zmap.cljs$core$IFn$_invoke$arity$6(caller,options__$2,ind,(ind + l_str_len),coll_print__$1,indent__$2),r_str_vec], 0));\n} else {\nif(cljs.core.truth_((function (){var or__4212__auto__ = (function (){var and__4210__auto__ = cljs.core.not(wrap_coll_QMARK___$1);\nif(and__4210__auto__){\nreturn zprint.zprint.any_zcoll_QMARK_(options__$2,new_ind,zloc);\n} else {\nreturn and__4210__auto__;\n}\n})();\nif(cljs.core.truth_(or__4212__auto__)){\nreturn or__4212__auto__;\n} else {\nreturn cljs.core.not(wrap_QMARK___$1);\n}\n})())){\nreturn zprint.zprint.concat_no_nil.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([l_str_vec,cljs.core.apply.cljs$core$IFn$_invoke$arity$2(zprint.zprint.concat_no_nil,(zprint.zprint.precede_w_nl.cljs$core$IFn$_invoke$arity$4 ? zprint.zprint.precede_w_nl.cljs$core$IFn$_invoke$arity$4(options__$2,new_ind,coll_print__$1,new cljs.core.Keyword(null,\"no-nl-first\",\"no-nl-first\",-1507054608)) : zprint.zprint.precede_w_nl.call(null,options__$2,new_ind,coll_print__$1,new cljs.core.Keyword(null,\"no-nl-first\",\"no-nl-first\",-1507054608)))),r_str_vec], 0));\n} else {\nreturn zprint.zprint.concat_no_nil.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([l_str_vec,(function (){\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options__$2))){\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options__$2),cljs.core.pr_str.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\"fzprint-vec*: wrap coll-print:\",coll_print__$1], 0))], 0));\n} else {\n}\n\nreturn zprint.zprint.wrap_zmap(caller,options__$2,new_ind,coll_print__$1);\n})()\n,r_str_vec], 0));\n}\n}\n}\n} else {\nreturn null;\n}\n}\n}\n}\n});\nzprint.zprint.fzprint_vec = (function zprint$zprint$fzprint_vec(options,ind,zloc){\nreturn zprint.zprint.fzprint_vec_STAR_(new cljs.core.Keyword(null,\"vector\",\"vector\",1902966158),\"[\",\"]\",zprint.zprint.rightmost(options),ind,zloc);\n});\nzprint.zprint.fzprint_array = (function zprint$zprint$fzprint_array(options,ind,zloc){\nreturn zprint.zprint.fzprint_vec_STAR_(new cljs.core.Keyword(null,\"array\",\"array\",-2080713842),\"[\",\"]\",zprint.zprint.rightmost(options),ind,zloc);\n});\n/**\n * Pretty print and focus style a :set element.\n */\nzprint.zprint.fzprint_set = (function zprint$zprint$fzprint_set(options,ind,zloc){\nreturn zprint.zprint.fzprint_vec_STAR_(new cljs.core.Keyword(null,\"set\",\"set\",304602554),\"#{\",\"}\",zprint.zprint.rightmost(options),ind,zloc);\n});\n/**\n * Do the same as interpose, but different seps depending on pred?.\n *   If sep-nil is nil, then when pred? is false we don't interpose\n *   anything!\n */\nzprint.zprint.interpose_either = (function zprint$zprint$interpose_either(sep_true,sep_nil,pred_QMARK_,coll){\nvar coll__$1 = coll;\nvar out = cljs.core.transient$(cljs.core.PersistentVector.EMPTY);\nvar interpose_QMARK_ = null;\nwhile(true){\nif(cljs.core.empty_QMARK_(coll__$1)){\nreturn cljs.core.persistent_BANG_(out);\n} else {\nvar G__46560 = cljs.core.next(coll__$1);\nvar G__46561 = (cljs.core.truth_(interpose_QMARK_)?zprint.zprint.conj_it_BANG_.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([out,sep_true,cljs.core.first(coll__$1)], 0)):(((((cljs.core.count(out) === (0))) || ((sep_nil == null))))?cljs.core.conj_BANG_.cljs$core$IFn$_invoke$arity$2(out,cljs.core.first(coll__$1)):zprint.zprint.conj_it_BANG_.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([out,sep_nil,cljs.core.first(coll__$1)], 0))));\nvar G__46562 = (function (){var G__45975 = cljs.core.first(coll__$1);\nreturn (pred_QMARK_.cljs$core$IFn$_invoke$arity$1 ? pred_QMARK_.cljs$core$IFn$_invoke$arity$1(G__45975) : pred_QMARK_.call(null,G__45975));\n})();\ncoll__$1 = G__46560;\nout = G__46561;\ninterpose_QMARK_ = G__46562;\ncontinue;\n}\nbreak;\n}\n});\n/**\n * Move through a sequence of style vecs and ensure that at least\n *   one newline (actually an indent) appears before each element.  If\n *   a newline in the style-vecs is where we wanted one, well and good.\n *   Comments are now not recognized as different, increasing our\n *   appreciation of diversity.  If not-first? is truthy, then don't\n *   put a newline before the first element.\n */\nzprint.zprint.precede_w_nl = (function zprint$zprint$precede_w_nl(options,ind,coll,not_first_QMARK_){\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options))){\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),cljs.core.pr_str.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\"precede-w-nl: (count coll)\",cljs.core.count(coll),\"not-first?\",not_first_QMARK_], 0))], 0));\n} else {\n}\n\nvar coll__$1 = coll;\nvar ind_seq = ((cljs.core.coll_QMARK_(ind))?ind:(new cljs.core.PersistentVector(null,1,(5),cljs.core.PersistentVector.EMPTY_NODE,[ind],null)));\nvar out = cljs.core.transient$(cljs.core.PersistentVector.EMPTY);\nvar added_nl_QMARK_ = not_first_QMARK_;\nwhile(true){\nif(cljs.core.empty_QMARK_(coll__$1)){\nvar result = cljs.core.persistent_BANG_(out);\nvar _ = (cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options))?cljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),cljs.core.pr_str.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\"precede-w-nl: exit:\",result], 0))], 0)):null);\nvar previous_element_index = (cljs.core.count(result) - (2));\nvar previous_type = (((!((previous_element_index < (0)))))?cljs.core.nth.cljs$core$IFn$_invoke$arity$2(cljs.core.first(cljs.core.nth.cljs$core$IFn$_invoke$arity$2(result,previous_element_index)),(2)):null);\nreturn result;\n} else {\nvar vec__45988 = cljs.core.first(coll__$1);\nvar vec__45991 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45988,(0),null);\nvar s = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45991,(0),null);\nvar color = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45991,(1),null);\nvar what = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45991,(2),null);\nvar element = vec__45988;\nvar indent = cljs.core.first(ind_seq);\nvar newline_QMARK_ = cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(what,new cljs.core.Keyword(null,\"newline\",\"newline\",1790071323));\nvar last_what = cljs.core.nth.cljs$core$IFn$_invoke$arity$2(cljs.core.last(element),(2));\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options))){\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),cljs.core.pr_str.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\"precede-w-nl: element:\",element,\"added-nl?:\",added_nl_QMARK_], 0))], 0));\n} else {\n}\n\nvar G__46563 = cljs.core.next(coll__$1);\nvar G__46564 = (function (){var temp__5751__auto__ = cljs.core.next(ind_seq);\nif(temp__5751__auto__){\nvar next_ind = temp__5751__auto__;\nreturn next_ind;\n} else {\nreturn ind_seq;\n}\n})();\nvar G__46565 = ((newline_QMARK_)?(function (){var next_coll = cljs.core.next(coll__$1);\nif(cljs.core.empty_QMARK_(next_coll)){\nreturn cljs.core.conj_BANG_.cljs$core$IFn$_invoke$arity$2(out,element);\n} else {\nvar vec__45994 = cljs.core.first(next_coll);\nvar vec__45997 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45994,(0),null);\nvar _ = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45997,(0),null);\nvar ___$1 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45997,(1),null);\nvar next_what = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45997,(2),null);\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(next_what,new cljs.core.Keyword(null,\"newline\",\"newline\",1790071323))){\nreturn cljs.core.conj_BANG_.cljs$core$IFn$_invoke$arity$2(out,new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [\"\\n\",color,what], null)], null));\n} else {\nreturn cljs.core.conj_BANG_.cljs$core$IFn$_invoke$arity$2(out,element);\n}\n}\n})():(cljs.core.truth_(added_nl_QMARK_)?cljs.core.conj_BANG_.cljs$core$IFn$_invoke$arity$2(out,element):zprint.zprint.conj_it_BANG_.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([out,new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 4, 5, cljs.core.PersistentVector.EMPTY_NODE, [[\"\\n\",cljs.core.str.cljs$core$IFn$_invoke$arity$1(zprint.zprint.blanks(indent))].join(''),new cljs.core.Keyword(null,\"none\",\"none\",1333468478),new cljs.core.Keyword(null,\"indent\",\"indent\",-148200125),(28)], null)], null),element], 0))));\nvar G__46566 = newline_QMARK_;\ncoll__$1 = G__46563;\nind_seq = G__46564;\nout = G__46565;\nadded_nl_QMARK_ = G__46566;\ncontinue;\n}\nbreak;\n}\n});\n/**\n * Analyze a style-vec which contains only newlines, the count of newlines\n *   in the style vec.  We assume that each :newline style-vec contains one\n *   newline (i.e., it was generated by fzprint-newlines).\n */\nzprint.zprint.count_newline_types = (function zprint$zprint$count_newline_types(newline_style_vec){\nvar count_of_types = cljs.core.count(cljs.core.distinct.cljs$core$IFn$_invoke$arity$1(cljs.core.map.cljs$core$IFn$_invoke$arity$2((function (p1__46000_SHARP_){\nreturn cljs.core.nth.cljs$core$IFn$_invoke$arity$2(p1__46000_SHARP_,(2));\n}),newline_style_vec)));\nif(((cljs.core.not_EQ_.cljs$core$IFn$_invoke$arity$2(count_of_types,(1))) || (cljs.core.not_EQ_.cljs$core$IFn$_invoke$arity$2(cljs.core.nth.cljs$core$IFn$_invoke$arity$2(cljs.core.first(newline_style_vec),(2)),new cljs.core.Keyword(null,\"newline\",\"newline\",1790071323))))){\nthrow (new Error([\"count-newline-types: more than one type or wrong type! count:\",cljs.core.str.cljs$core$IFn$_invoke$arity$1(count_of_types),\" style-vec:\",cljs.core.str.cljs$core$IFn$_invoke$arity$1(newline_style_vec)].join('')));\n} else {\n}\n\nreturn cljs.core.count(newline_style_vec);\n});\n/**\n * Count the number of blanks at the right end of a string.\n */\nzprint.zprint.count_right_blanks = (function zprint$zprint$count_right_blanks(s){\nvar i = cljs.core.count(s);\nwhile(true){\nif((i < (0))){\nreturn cljs.core.count(s);\n} else {\nif(clojure.string.ends_with_QMARK_(cljs.core.subs.cljs$core$IFn$_invoke$arity$3(s,(0),i),\" \")){\nvar G__46567 = (i - (1));\ni = G__46567;\ncontinue;\n} else {\nreturn (cljs.core.count(s) - i);\n}\n}\nbreak;\n}\n});\n/**\n * Trim only blanks off the right end of a string.\n */\nzprint.zprint.trimr_blanks = (function zprint$zprint$trimr_blanks(s){\nvar i = cljs.core.count(s);\nwhile(true){\nif((i < (0))){\nreturn \"\";\n} else {\nif(clojure.string.ends_with_QMARK_(cljs.core.subs.cljs$core$IFn$_invoke$arity$3(s,(0),i),\" \")){\nvar G__46568 = (i - (1));\ni = G__46568;\ncontinue;\n} else {\nreturn cljs.core.subs.cljs$core$IFn$_invoke$arity$3(s,(0),i);\n}\n}\nbreak;\n}\n});\n/**\n * Given a count n, and style vec that ends with a newline and an associated\n *   indent of some number of spaces, return a sequence of n of those style vecs\n *   but remove spaces from all but the last of them.\n */\nzprint.zprint.repeat_style_vec_nl = (function zprint$zprint$repeat_style_vec_nl(n,style_vec){\nvar no_space_n = (function (){var x__4295__auto__ = (n - (1));\nvar y__4296__auto__ = (0);\nreturn ((x__4295__auto__ > y__4296__auto__) ? x__4295__auto__ : y__4296__auto__);\n})();\nif((no_space_n === (0))){\nreturn style_vec;\n} else {\nvar vec__46001 = cljs.core.last(style_vec);\nvar s = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__46001,(0),null);\nvar color = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__46001,(1),null);\nvar what = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__46001,(2),null);\nvar no_space_element = new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [zprint.zprint.trimr_blanks(s),color,what], null);\nvar no_space_style_vec = cljs.core.into.cljs$core$IFn$_invoke$arity$2(cljs.core.PersistentVector.EMPTY,cljs.core.concat.cljs$core$IFn$_invoke$arity$2(cljs.core.butlast(style_vec),no_space_element));\nreturn cljs.core.into.cljs$core$IFn$_invoke$arity$2(cljs.core.PersistentVector.EMPTY,cljs.core.concat.cljs$core$IFn$_invoke$arity$2(cljs.core.repeat.cljs$core$IFn$_invoke$arity$2(no_space_n,no_space_style_vec),style_vec));\n}\n});\n/**\n * Given an element, trim the blanks out of the string.\n */\nzprint.zprint.trimr_blanks_element = (function zprint$zprint$trimr_blanks_element(p__46004){\nvar vec__46005 = p__46004;\nvar s = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__46005,(0),null);\nvar color = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__46005,(1),null);\nvar what = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__46005,(2),null);\nreturn new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [zprint.zprint.trimr_blanks(s),color,what], null);\n});\n/**\n * Given a style-vec, trim the blanks out of each element.\n */\nzprint.zprint.trimr_blanks_style_vec = (function zprint$zprint$trimr_blanks_style_vec(style_vec){\nreturn cljs.core.mapv.cljs$core$IFn$_invoke$arity$2(zprint.zprint.trimr_blanks_element,style_vec);\n});\n/**\n * Given a count n, and single element from a style-vec which\n *   contains a newline and an indent of some number of spaces, return\n *   a sequence of n of those style vecs but remove spaces from all\n *   but the last of them.\n */\nzprint.zprint.repeat_element_nl = (function zprint$zprint$repeat_element_nl(n,element){\nvar no_space_n = (function (){var x__4295__auto__ = (n - (1));\nvar y__4296__auto__ = (0);\nreturn ((x__4295__auto__ > y__4296__auto__) ? x__4295__auto__ : y__4296__auto__);\n})();\nif((no_space_n === (0))){\nreturn new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [element], null);\n} else {\nvar vec__46008 = element;\nvar s = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__46008,(0),null);\nvar color = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__46008,(1),null);\nvar what = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__46008,(2),null);\nvar no_space_element = new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [zprint.zprint.trimr_blanks(s),color,what], null);\nvar result = cljs.core.into.cljs$core$IFn$_invoke$arity$2(cljs.core.PersistentVector.EMPTY,cljs.core.concat.cljs$core$IFn$_invoke$arity$2(cljs.core.repeat.cljs$core$IFn$_invoke$arity$2(no_space_n,no_space_element),new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [element], null)));\nreturn result;\n}\n});\n/**\n * Given a coll of [hangflow style-vec] pairs, return the \n *   [hangflow style-vec] pair where the style-vec is not a \n *   :comment, :comment-inline, :newline or :indent.\n */\nzprint.zprint.next_non_comment_nl = (function zprint$zprint$next_non_comment_nl(coll){\nvar coll__$1 = coll;\nwhile(true){\nif(cljs.core.empty_QMARK_(coll__$1)){\nreturn null;\n} else {\nvar vec__46011 = cljs.core.first(coll__$1);\nvar _ = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__46011,(0),null);\nvar style_vec = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__46011,(1),null);\nvar vec__46014 = cljs.core.first(style_vec);\nvar ___$1 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__46014,(0),null);\nvar ___$2 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__46014,(1),null);\nvar what = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__46014,(2),null);\nif(((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(what,new cljs.core.Keyword(null,\"comment\",\"comment\",532206069))) || (((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(what,new cljs.core.Keyword(null,\"comment-inline\",\"comment-inline\",712944405))) || (((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(what,new cljs.core.Keyword(null,\"indent\",\"indent\",-148200125))) || (cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(what,new cljs.core.Keyword(null,\"newline\",\"newline\",1790071323))))))))){\nvar G__46569 = cljs.core.next(coll__$1);\ncoll__$1 = G__46569;\ncontinue;\n} else {\nreturn cljs.core.first(coll__$1);\n}\n}\nbreak;\n}\n});\n/**\n * Do very specialized interpose, but different seps depending on pred-fn\n *   return and nl-separator?. This assumes that sep-* does one line, and\n *   sep-*-nl does two lines.\n */\nzprint.zprint.interpose_either_nl_hf = (function zprint$zprint$interpose_either_nl_hf(sep_comma,sep_comma_nl,sep,sep_nl,p__46017,comma_QMARK_,coll){\nvar map__46018 = p__46017;\nvar map__46018__$1 = cljs.core.__destructure_map(map__46018);\nvar suboptions = map__46018__$1;\nvar nl_separator_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__46018__$1,new cljs.core.Keyword(null,\"nl-separator?\",\"nl-separator?\",-758068767));\nvar nl_separator_flow_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__46018__$1,new cljs.core.Keyword(null,\"nl-separator-flow?\",\"nl-separator-flow?\",495760215));\nvar coll__$1 = coll;\nvar out = cljs.core.transient$(cljs.core.PersistentVector.EMPTY);\nvar previous_needs_comma_QMARK_ = null;\nvar add_nl_QMARK_ = null;\nvar first_QMARK_ = true;\nvar newline_count = (0);\nwhile(true){\nif(cljs.core.empty_QMARK_(coll__$1)){\nreturn cljs.core.apply.cljs$core$IFn$_invoke$arity$2(zprint.zprint.concat_no_nil,cljs.core.persistent_BANG_((((newline_count === (0)))?out:zprint.zprint.conj_it_BANG_.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([out,zprint.zprint.repeat_element_nl(newline_count,cljs.core.first(sep))], 0)))));\n} else {\nvar vec__46028 = cljs.core.first(coll__$1);\nvar hangflow = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__46028,(0),null);\nvar style_vec = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__46028,(1),null);\nvar vec__46031 = cljs.core.first(style_vec);\nvar _ = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__46031,(0),null);\nvar ___$1 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__46031,(1),null);\nvar what = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__46031,(2),null);\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(what,new cljs.core.Keyword(null,\"newline\",\"newline\",1790071323))){\nvar G__46570 = cljs.core.next(coll__$1);\nvar G__46571 = out;\nvar G__46572 = previous_needs_comma_QMARK_;\nvar G__46573 = add_nl_QMARK_;\nvar G__46574 = first_QMARK_;\nvar G__46575 = (newline_count + zprint.zprint.count_newline_types(style_vec));\ncoll__$1 = G__46570;\nout = G__46571;\nprevious_needs_comma_QMARK_ = G__46572;\nadd_nl_QMARK_ = G__46573;\nfirst_QMARK_ = G__46574;\nnewline_count = G__46575;\ncontinue;\n} else {\nvar vec__46034 = (cljs.core.truth_(previous_needs_comma_QMARK_)?(cljs.core.truth_(add_nl_QMARK_)?new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [sep_comma_nl,(2)], null):new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [sep_comma,(1)], null)):(cljs.core.truth_(add_nl_QMARK_)?new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [sep_nl,(2)], null):new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [sep,(1)], null)));\nvar interpose_style_vec = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__46034,(0),null);\nvar interpose_count = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__46034,(1),null);\nvar interpose_count__$1 = (cljs.core.truth_(first_QMARK_)?(1):interpose_count);\nvar addtl_nl_needed = (function (){var x__4295__auto__ = (newline_count - interpose_count__$1);\nvar y__4296__auto__ = (0);\nreturn ((x__4295__auto__ > y__4296__auto__) ? x__4295__auto__ : y__4296__auto__);\n})();\nvar G__46576 = cljs.core.next(coll__$1);\nvar G__46577 = (cljs.core.truth_(first_QMARK_)?(((addtl_nl_needed === (0)))?cljs.core.conj_BANG_.cljs$core$IFn$_invoke$arity$2(out,style_vec):zprint.zprint.conj_it_BANG_.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([out,zprint.zprint.repeat_element_nl(addtl_nl_needed,cljs.core.first(sep)),style_vec], 0))):(((addtl_nl_needed === (0)))?zprint.zprint.conj_it_BANG_.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([out,interpose_style_vec,style_vec], 0)):zprint.zprint.conj_it_BANG_.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([out,zprint.zprint.trimr_blanks_style_vec(interpose_style_vec),zprint.zprint.repeat_element_nl(addtl_nl_needed,cljs.core.first(sep)),style_vec], 0))));\nvar G__46578 = (function (){var and__4210__auto__ = comma_QMARK_;\nif(cljs.core.truth_(and__4210__auto__)){\nvar and__4210__auto____$1 = cljs.core.not_EQ_.cljs$core$IFn$_invoke$arity$2(what,new cljs.core.Keyword(null,\"comment\",\"comment\",532206069));\nif(and__4210__auto____$1){\nvar and__4210__auto____$2 = cljs.core.not_EQ_.cljs$core$IFn$_invoke$arity$2(what,new cljs.core.Keyword(null,\"comment-inline\",\"comment-inline\",712944405));\nif(and__4210__auto____$2){\nreturn zprint.zprint.next_non_comment_nl(cljs.core.next(coll__$1));\n} else {\nreturn and__4210__auto____$2;\n}\n} else {\nreturn and__4210__auto____$1;\n}\n} else {\nreturn and__4210__auto__;\n}\n})();\nvar G__46579 = (function (){var and__4210__auto__ = nl_separator_QMARK_;\nif(cljs.core.truth_(and__4210__auto__)){\nreturn cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(hangflow,new cljs.core.Keyword(null,\"flow\",\"flow\",590489032));\n} else {\nreturn and__4210__auto__;\n}\n})();\nvar G__46580 = null;\nvar G__46581 = (0);\ncoll__$1 = G__46576;\nout = G__46577;\nprevious_needs_comma_QMARK_ = G__46578;\nadd_nl_QMARK_ = G__46579;\nfirst_QMARK_ = G__46580;\nnewline_count = G__46581;\ncontinue;\n\n}\n}\nbreak;\n}\n});\n/**\n * Put a single or double line between pairs returned from\n *   fzprint-map-two-up.  The second argument is the map resulting\n *   from (:map options) or (:pair options) or whatever.  It should\n *   have :nl-separator? and :nl-separator-flow? in it.\n */\nzprint.zprint.interpose_nl_hf = (function zprint$zprint$interpose_nl_hf(suboptions,ind,coll){\nreturn zprint.zprint.interpose_either_nl_hf(null,null,new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 4, 5, cljs.core.PersistentVector.EMPTY_NODE, [[\"\\n\",cljs.core.str.cljs$core$IFn$_invoke$arity$1(zprint.zprint.blanks(ind))].join(''),new cljs.core.Keyword(null,\"none\",\"none\",1333468478),new cljs.core.Keyword(null,\"indent\",\"indent\",-148200125),(29)], null)], null),new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 4, 5, cljs.core.PersistentVector.EMPTY_NODE, [\"\\n\",new cljs.core.Keyword(null,\"none\",\"none\",1333468478),new cljs.core.Keyword(null,\"indent\",\"indent\",-148200125),(30)], null),new cljs.core.PersistentVector(null, 4, 5, cljs.core.PersistentVector.EMPTY_NODE, [[\"\\n\",cljs.core.str.cljs$core$IFn$_invoke$arity$1(zprint.zprint.blanks(ind))].join(''),new cljs.core.Keyword(null,\"none\",\"none\",1333468478),new cljs.core.Keyword(null,\"indent\",\"indent\",-148200125),(31)], null)], null),suboptions,null,coll);\n});\nzprint.zprint.fzprint_map_STAR_ = (function zprint$zprint$fzprint_map_STAR_(caller,l_str,r_str,p__46037,ind,zloc,ns){\nvar map__46038 = p__46037;\nvar map__46038__$1 = cljs.core.__destructure_map(map__46038);\nvar options = map__46038__$1;\nvar map__46039 = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__46038__$1,caller);\nvar map__46039__$1 = cljs.core.__destructure_map(map__46039);\nvar map_options = map__46039__$1;\nvar comma_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__46039__$1,new cljs.core.Keyword(null,\"comma?\",\"comma?\",1532168963));\nvar key_ignore = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__46039__$1,new cljs.core.Keyword(null,\"key-ignore\",\"key-ignore\",75506668));\nvar key_ignore_silent = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__46039__$1,new cljs.core.Keyword(null,\"key-ignore-silent\",\"key-ignore-silent\",-1720115060));\nvar nl_separator_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__46039__$1,new cljs.core.Keyword(null,\"nl-separator?\",\"nl-separator?\",-758068767));\nvar force_nl_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__46039__$1,new cljs.core.Keyword(null,\"force-nl?\",\"force-nl?\",-1299761462));\nvar lift_ns_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__46039__$1,new cljs.core.Keyword(null,\"lift-ns?\",\"lift-ns?\",2021372853));\nvar lift_ns_in_code_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__46039__$1,new cljs.core.Keyword(null,\"lift-ns-in-code?\",\"lift-ns-in-code?\",1444279377));\nvar indent = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__46039__$1,new cljs.core.Keyword(null,\"indent\",\"indent\",-148200125));\nvar one_line_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__46038__$1,new cljs.core.Keyword(null,\"one-line?\",\"one-line?\",2055953111));\nvar ztype = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__46038__$1,new cljs.core.Keyword(null,\"ztype\",\"ztype\",-562179020));\nvar map_depth = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__46038__$1,new cljs.core.Keyword(null,\"map-depth\",\"map-depth\",-191378641));\nvar in_code_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__46038__$1,new cljs.core.Keyword(null,\"in-code?\",\"in-code?\",194866464));\nvar vec__46040 = zprint.zprint.get_respect_indent(options,caller,new cljs.core.Keyword(null,\"map\",\"map\",1371690461));\nvar respect_nl_QMARK_ = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__46040,(0),null);\nvar respect_bl_QMARK_ = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__46040,(1),null);\nvar indent_only_QMARK_ = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__46040,(2),null);\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options))){\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),cljs.core.pr_str.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\"fzprint-map* caller:\",caller], 0))], 0));\n} else {\n}\n\nif(cljs.core.truth_(indent_only_QMARK_)){\nvar options__$1 = cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(options,new cljs.core.Keyword(null,\"map-depth\",\"map-depth\",-191378641),(map_depth + (1)));\nvar l_str_vec = new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [l_str,zprint.zprint.zcolor_map(options__$1,l_str),new cljs.core.Keyword(null,\"left\",\"left\",-399115937)], null)], null);\nvar r_str_vec = zprint.zprint.rstr_vec.cljs$core$IFn$_invoke$arity$4(options__$1,ind,zloc,r_str);\nif(((zprint.zfns.zcount.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zcount.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zcount.call(null,zloc)) === (0))){\nreturn zprint.zprint.concat_no_nil.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([l_str_vec,r_str_vec], 0));\n} else {\nreturn zprint.zprint.concat_no_nil.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([l_str_vec,zprint.zprint.fzprint_indent.cljs$core$IFn$_invoke$arity$8(caller,l_str,r_str,options__$1,ind,zloc,null,null),r_str_vec], 0));\n}\n} else {\nvar options__$1 = cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(options,new cljs.core.Keyword(null,\"map-depth\",\"map-depth\",-191378641),(map_depth + (1)));\nvar zloc__$1 = (cljs.core.truth_((function (){var and__4210__auto__ = cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(ztype,new cljs.core.Keyword(null,\"sexpr\",\"sexpr\",-783344087));\nif(and__4210__auto__){\nvar or__4212__auto__ = key_ignore;\nif(cljs.core.truth_(or__4212__auto__)){\nreturn or__4212__auto__;\n} else {\nreturn key_ignore_silent;\n}\n} else {\nreturn and__4210__auto__;\n}\n})())?zprint.zprint.map_ignore(caller,options__$1,zloc):zloc);\nvar vec__46043 = zprint.zprint.partition_all_2_nc(zprint.zprint.no_max_length(options__$1),(cljs.core.truth_(respect_nl_QMARK_)?(zprint.zfns.zseqnws_w_nl.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zseqnws_w_nl.cljs$core$IFn$_invoke$arity$1(zloc__$1) : zprint.zfns.zseqnws_w_nl.call(null,zloc__$1)):(cljs.core.truth_(respect_bl_QMARK_)?(zprint.zfns.zseqnws_w_bl.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zseqnws_w_bl.cljs$core$IFn$_invoke$arity$1(zloc__$1) : zprint.zfns.zseqnws_w_bl.call(null,zloc__$1)):(zprint.zfns.zseqnws.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zseqnws.cljs$core$IFn$_invoke$arity$1(zloc__$1) : zprint.zfns.zseqnws.call(null,zloc__$1))\n)));\nvar no_sort_QMARK_ = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__46043,(0),null);\nvar pair_seq = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__46043,(1),null);\nvar no_sort_QMARK___$1 = (function (){var or__4212__auto__ = no_sort_QMARK_;\nif(cljs.core.truth_(or__4212__auto__)){\nreturn or__4212__auto__;\n} else {\nvar or__4212__auto____$1 = respect_nl_QMARK_;\nif(cljs.core.truth_(or__4212__auto____$1)){\nreturn or__4212__auto____$1;\n} else {\nreturn respect_bl_QMARK_;\n}\n}\n})();\nvar vec__46046 = (function (){var G__46049 = cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(map_options,new cljs.core.Keyword(null,\"in-code?\",\"in-code?\",194866464),in_code_QMARK_);\nvar G__46050 = pair_seq;\nvar G__46051 = ns;\nreturn (zprint.zfns.zlift_ns.cljs$core$IFn$_invoke$arity$3 ? zprint.zfns.zlift_ns.cljs$core$IFn$_invoke$arity$3(G__46049,G__46050,G__46051) : zprint.zfns.zlift_ns.call(null,G__46049,G__46050,G__46051));\n})();\nvar ns__$1 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__46046,(0),null);\nvar lift_pair_seq = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__46046,(1),null);\nvar _ = (cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options__$1))?cljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options__$1),cljs.core.pr_str.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\"fzprint-map* zlift-ns ns:\",ns__$1], 0))], 0)):null);\nvar l_str__$1 = (cljs.core.truth_(ns__$1)?[\"#\",cljs.core.str.cljs$core$IFn$_invoke$arity$1(ns__$1),cljs.core.str.cljs$core$IFn$_invoke$arity$1(l_str)].join(''):l_str);\nvar pair_seq__$1 = (function (){var or__4212__auto__ = lift_pair_seq;\nif(cljs.core.truth_(or__4212__auto__)){\nreturn or__4212__auto__;\n} else {\nreturn pair_seq;\n}\n})();\nvar pair_seq__$2 = (cljs.core.truth_(no_sort_QMARK___$1)?pair_seq__$1:zprint.zprint.order_out(caller,options__$1,cljs.core.first,pair_seq__$1));\nvar max_length = zprint.zprint.get_max_length(options__$1);\nvar pair_count = cljs.core.count(pair_seq__$2);\nvar pair_seq__$3 = (((pair_count > max_length))?cljs.core.concat.cljs$core$IFn$_invoke$arity$2(cljs.core.take.cljs$core$IFn$_invoke$arity$2(max_length,pair_seq__$2),(new cljs.core.List(null,(new cljs.core.List(null,(zprint.zfns.zdotdotdot.cljs$core$IFn$_invoke$arity$0 ? zprint.zfns.zdotdotdot.cljs$core$IFn$_invoke$arity$0() : zprint.zfns.zdotdotdot.call(null)),null,(1),null)),null,(1),null))):pair_seq__$2);\nvar indent__$1 = cljs.core.count(l_str__$1);\nvar l_str_vec = new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [l_str__$1,zprint.zprint.zcolor_map(options__$1,l_str__$1),new cljs.core.Keyword(null,\"left\",\"left\",-399115937)], null)], null);\nvar r_str_vec = zprint.zprint.rstr_vec.cljs$core$IFn$_invoke$arity$4(options__$1,ind,zloc__$1,r_str);\nif(cljs.core.empty_QMARK_(pair_seq__$3)){\nreturn zprint.zprint.concat_no_nil.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([l_str_vec,r_str_vec], 0));\n} else {\nvar ___$1 = (cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options__$1))?cljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options__$1),cljs.core.pr_str.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\"fzprint-map*:\",(zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1(zloc__$1) : zprint.zfns.zstring.call(null,zloc__$1)),\"ind:\",ind,\"comma?\",comma_QMARK_,\"rightcnt:\",new cljs.core.Keyword(null,\"rightcnt\",\"rightcnt\",-45750070).cljs$core$IFn$_invoke$arity$1(options__$1)], 0))], 0)):null);\nvar pair_print_one_line = zprint.zprint.fzprint_map_two_up(caller,(cljs.core.truth_(one_line_QMARK_)?options__$1:cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(options__$1,new cljs.core.Keyword(null,\"one-line?\",\"one-line?\",2055953111),true)),(indent__$1 + ind),comma_QMARK_,pair_seq__$3);\nvar pair_print_one_line__$1 = zprint.zprint.remove_hangflow(pair_print_one_line);\nvar pair_print_one_line__$2 = ((zprint.zprint.fzfit_one_line(options__$1,zprint.zprint.style_lines(options__$1,(indent__$1 + ind),pair_print_one_line__$1)))?pair_print_one_line__$1:null);\nvar one_line = (cljs.core.truth_(pair_print_one_line__$2)?cljs.core.apply.cljs$core$IFn$_invoke$arity$2(zprint.zprint.concat_no_nil,zprint.zprint.interpose_either(new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 4, 5, cljs.core.PersistentVector.EMPTY_NODE, [\",\",zprint.zprint.zcolor_map(options__$1,new cljs.core.Keyword(null,\"comma\",\"comma\",1699024745)),new cljs.core.Keyword(null,\"whitespace\",\"whitespace\",-1340035483),(19)], null),new cljs.core.PersistentVector(null, 4, 5, cljs.core.PersistentVector.EMPTY_NODE, [\" \",new cljs.core.Keyword(null,\"none\",\"none\",1333468478),new cljs.core.Keyword(null,\"whitespace\",\"whitespace\",-1340035483),(23)], null)], null),new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 4, 5, cljs.core.PersistentVector.EMPTY_NODE, [\" \",new cljs.core.Keyword(null,\"none\",\"none\",1333468478),new cljs.core.Keyword(null,\"whitespace\",\"whitespace\",-1340035483),(20)], null)], null),cljs.core.constantly(comma_QMARK_),pair_print_one_line__$2)):null);\nvar one_line_lines = zprint.zprint.style_lines(options__$1,(indent__$1 + ind),one_line);\nvar one_line__$1 = ((zprint.zprint.fzfit_one_line(options__$1,one_line_lines))?one_line:null);\nif(cljs.core.truth_(one_line__$1)){\nreturn zprint.zprint.concat_no_nil.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([l_str_vec,one_line__$1,r_str_vec], 0));\n} else {\nif(cljs.core.not(one_line_QMARK_)){\nvar pair_print = zprint.zprint.fzprint_map_two_up(caller,options__$1,(indent__$1 + ind),comma_QMARK_,pair_seq__$3);\nreturn zprint.zprint.concat_no_nil.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([l_str_vec,zprint.zprint.interpose_either_nl_hf(new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 4, 5, cljs.core.PersistentVector.EMPTY_NODE, [\",\",zprint.zprint.zcolor_map(options__$1,new cljs.core.Keyword(null,\"comma\",\"comma\",1699024745)),new cljs.core.Keyword(null,\"whitespace\",\"whitespace\",-1340035483),(21)], null),new cljs.core.PersistentVector(null, 4, 5, cljs.core.PersistentVector.EMPTY_NODE, [[\"\\n\",cljs.core.str.cljs$core$IFn$_invoke$arity$1(zprint.zprint.blanks((ind + (1))))].join(''),new cljs.core.Keyword(null,\"none\",\"none\",1333468478),new cljs.core.Keyword(null,\"indent\",\"indent\",-148200125),(32)], null)], null),new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 4, 5, cljs.core.PersistentVector.EMPTY_NODE, [\",\",zprint.zprint.zcolor_map(options__$1,new cljs.core.Keyword(null,\"comma\",\"comma\",1699024745)),new cljs.core.Keyword(null,\"whitespace\",\"whitespace\",-1340035483),(22)], null),new cljs.core.PersistentVector(null, 4, 5, cljs.core.PersistentVector.EMPTY_NODE, [\"\\n\",new cljs.core.Keyword(null,\"none\",\"none\",1333468478),new cljs.core.Keyword(null,\"indent\",\"indent\",-148200125),(33)], null),new cljs.core.PersistentVector(null, 4, 5, cljs.core.PersistentVector.EMPTY_NODE, [[\"\\n\",cljs.core.str.cljs$core$IFn$_invoke$arity$1(zprint.zprint.blanks((ind + (1))))].join(''),new cljs.core.Keyword(null,\"none\",\"none\",1333468478),new cljs.core.Keyword(null,\"indent\",\"indent\",-148200125),(34)], null)], null),new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 4, 5, cljs.core.PersistentVector.EMPTY_NODE, [[\"\\n\",cljs.core.str.cljs$core$IFn$_invoke$arity$1(zprint.zprint.blanks((ind + (1))))].join(''),new cljs.core.Keyword(null,\"none\",\"none\",1333468478),new cljs.core.Keyword(null,\"indent\",\"indent\",-148200125),(35)], null)], null),new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 4, 5, cljs.core.PersistentVector.EMPTY_NODE, [\"\\n\",new cljs.core.Keyword(null,\"none\",\"none\",1333468478),new cljs.core.Keyword(null,\"indent\",\"indent\",-148200125),(36)], null),new cljs.core.PersistentVector(null, 4, 5, cljs.core.PersistentVector.EMPTY_NODE, [[\"\\n\",cljs.core.str.cljs$core$IFn$_invoke$arity$1(zprint.zprint.blanks((ind + (1))))].join(''),new cljs.core.Keyword(null,\"none\",\"none\",1333468478),new cljs.core.Keyword(null,\"indent\",\"indent\",-148200125),(37)], null)], null),new cljs.core.Keyword(null,\"map\",\"map\",1371690461).cljs$core$IFn$_invoke$arity$1(options__$1),comma_QMARK_,pair_print),r_str_vec], 0));\n} else {\nreturn null;\n}\n}\n}\n}\n});\n/**\n * Format a real map.\n */\nzprint.zprint.fzprint_map = (function zprint$zprint$fzprint_map(options,ind,zloc){\nvar vec__46052 = (cljs.core.truth_((zprint.zfns.znamespacedmap_QMARK_.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.znamespacedmap_QMARK_.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.znamespacedmap_QMARK_.call(null,zloc)))?(function (){var zloc_seq = (zprint.zfns.zmap.cljs$core$IFn$_invoke$arity$2 ? zprint.zfns.zmap.cljs$core$IFn$_invoke$arity$2(cljs.core.identity,zloc) : zprint.zfns.zmap.call(null,cljs.core.identity,zloc));\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options))){\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),cljs.core.pr_str.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\"fzprint-map: zloc-seq\",cljs.core.map.cljs$core$IFn$_invoke$arity$2(zprint.zfns.zstring,zloc_seq)], 0))], 0));\n} else {\n}\n\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [(function (){var G__46055 = cljs.core.first(zloc_seq);\nreturn (zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1(G__46055) : zprint.zfns.zstring.call(null,G__46055));\n})(),cljs.core.second(zloc_seq)], null);\n})():null);\nvar ns = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__46052,(0),null);\nvar lifted_map = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__46052,(1),null);\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options))){\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),cljs.core.pr_str.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\"fzprint-map: ns:\",ns,\"indent:\",new cljs.core.Keyword(null,\"indent\",\"indent\",-148200125).cljs$core$IFn$_invoke$arity$1(new cljs.core.Keyword(null,\"map\",\"map\",1371690461).cljs$core$IFn$_invoke$arity$1(options)),\"map-options:\",new cljs.core.Keyword(null,\"map\",\"map\",1371690461).cljs$core$IFn$_invoke$arity$1(options)], 0))], 0));\n} else {\n}\n\nif(cljs.core.truth_(ns)){\nreturn zprint.zprint.fzprint_map_STAR_(new cljs.core.Keyword(null,\"map\",\"map\",1371690461),\"{\",\"}\",zprint.zprint.rightmost(options),ind,lifted_map,ns);\n} else {\nreturn zprint.zprint.fzprint_map_STAR_(new cljs.core.Keyword(null,\"map\",\"map\",1371690461),\"{\",\"}\",zprint.zprint.rightmost(options),ind,zloc,null);\n}\n});\n/**\n * Return true if the string starts with #object[\n */\nzprint.zprint.object_str_QMARK_ = (function zprint$zprint$object_str_QMARK_(s){\nreturn cljs.core.re_find(/^#object\\[/,s);\n});\n/**\n * Print something that looks like #object[...] in a way\n *   that will acknowledge the structure inside of the [...]\n */\nzprint.zprint.fzprint_object = (function zprint$zprint$fzprint_object(var_args){\nvar G__46057 = arguments.length;\nswitch (G__46057) {\ncase 4:\nreturn zprint.zprint.fzprint_object.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ncase 3:\nreturn zprint.zprint.fzprint_object.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\n(zprint.zprint.fzprint_object.cljs$core$IFn$_invoke$arity$4 = (function (options,ind,zloc,zloc_value){\nreturn zprint.zprint.fzprint_vec_STAR_(new cljs.core.Keyword(null,\"object\",\"object\",1474613949),\"#object[\",\"]\",options,ind,(zprint.zfns.zobj_to_vec.cljs$core$IFn$_invoke$arity$2 ? zprint.zfns.zobj_to_vec.cljs$core$IFn$_invoke$arity$2(zloc,zloc_value) : zprint.zfns.zobj_to_vec.call(null,zloc,zloc_value)));\n}));\n\n(zprint.zprint.fzprint_object.cljs$core$IFn$_invoke$arity$3 = (function (options,ind,zloc){\nreturn zprint.zprint.fzprint_vec_STAR_(new cljs.core.Keyword(null,\"object\",\"object\",1474613949),\"#object[\",\"]\",options,ind,(zprint.zfns.zobj_to_vec.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zobj_to_vec.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zobj_to_vec.call(null,zloc)));\n}));\n\n(zprint.zprint.fzprint_object.cljs$lang$maxFixedArity = 4);\n\n/**\n * Find the hash-code identity for an object.\n */\nzprint.zprint.hash_identity_str = (function zprint$zprint$hash_identity_str(obj){\nreturn cljs.core.str.cljs$core$IFn$_invoke$arity$1(cljs.core.hash(obj));\n});\nzprint.zprint.fzprint_atom = (function zprint$zprint$fzprint_atom(p__46058,ind,zloc){\nvar map__46059 = p__46058;\nvar map__46059__$1 = cljs.core.__destructure_map(map__46059);\nvar options = map__46059__$1;\nvar map__46060 = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__46059__$1,new cljs.core.Keyword(null,\"atom\",\"atom\",-397043653));\nvar map__46060__$1 = cljs.core.__destructure_map(map__46060);\nvar object_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__46060__$1,new cljs.core.Keyword(null,\"object?\",\"object?\",-1313059217));\nif(cljs.core.truth_((function (){var and__4210__auto__ = object_QMARK_;\nif(cljs.core.truth_(and__4210__auto__)){\nreturn zprint.zprint.object_str_QMARK_((zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zstring.call(null,zloc)));\n} else {\nreturn and__4210__auto__;\n}\n})())){\nreturn zprint.zprint.fzprint_object.cljs$core$IFn$_invoke$arity$4(options,ind,zloc,(zprint.zfns.zderef.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zderef.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zderef.call(null,zloc)));\n} else {\nvar l_str = \"#<\";\nvar r_str = \">\";\nvar indent = ((l_str).length);\nvar l_str_vec = new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [l_str,zprint.zprint.zcolor_map(options,l_str),new cljs.core.Keyword(null,\"left\",\"left\",-399115937)], null)], null);\nvar r_str_vec = zprint.zprint.rstr_vec.cljs$core$IFn$_invoke$arity$4(options,ind,zloc,r_str);\nvar arg_1 = [\"Atom@\",zprint.zprint.hash_identity_str(zloc)].join('');\nvar arg_1_indent = (((ind + indent) + (1)) + ((arg_1).length));\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options))){\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),cljs.core.pr_str.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\"fzprint-atom: arg-1:\",arg_1,\"zstring arg-1:\",(zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zstring.call(null,zloc))], 0))], 0));\n} else {\n}\n\nreturn zprint.zprint.concat_no_nil.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([l_str_vec,new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [arg_1,zprint.zprint.zcolor_map(options,new cljs.core.Keyword(null,\"none\",\"none\",1333468478)),new cljs.core.Keyword(null,\"element\",\"element\",1974019749)], null)], null),zprint.zprint.fzprint_hang_one(new cljs.core.Keyword(null,\"unknown\",\"unknown\",-935977881),zprint.zprint.rightmost(options),arg_1_indent,(indent + ind),(zprint.zfns.zderef.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zderef.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zderef.call(null,zloc))),r_str_vec], 0));\n}\n});\n/**\n * Print out a future or a promise or a delay.  These can only be \n *   sexpressions, since they don't exist in a textual representation \n *   of code (or data for that matter).  That means that we can use \n *   regular sexpression operations on zloc.\n */\nzprint.zprint.fzprint_future_promise_delay_agent = (function zprint$zprint$fzprint_future_promise_delay_agent(options,ind,zloc){\nvar zloc_type = (cljs.core.truth_((zprint.zfns.zfuture_QMARK_.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zfuture_QMARK_.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zfuture_QMARK_.call(null,zloc)))?new cljs.core.Keyword(null,\"future\",\"future\",1877842724):(cljs.core.truth_((zprint.zfns.zpromise_QMARK_.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zpromise_QMARK_.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zpromise_QMARK_.call(null,zloc)))?new cljs.core.Keyword(null,\"promise\",\"promise\",1767129287):(cljs.core.truth_((zprint.zfns.zdelay_QMARK_.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zdelay_QMARK_.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zdelay_QMARK_.call(null,zloc)))?new cljs.core.Keyword(null,\"delay\",\"delay\",-574225219):(cljs.core.truth_((zprint.zfns.zagent_QMARK_.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zagent_QMARK_.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zagent_QMARK_.call(null,zloc)))?new cljs.core.Keyword(null,\"agent\",\"agent\",-766455027):(function(){throw (new Error(\"Not a future, promise, or delay:\",(zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zstring.call(null,zloc))))})()\n))));\nif(cljs.core.truth_((function (){var and__4210__auto__ = new cljs.core.Keyword(null,\"object?\",\"object?\",-1313059217).cljs$core$IFn$_invoke$arity$1((options.cljs$core$IFn$_invoke$arity$1 ? options.cljs$core$IFn$_invoke$arity$1(zloc_type) : options.call(null,zloc_type)));\nif(cljs.core.truth_(and__4210__auto__)){\nreturn zprint.zprint.object_str_QMARK_((zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zstring.call(null,zloc)));\n} else {\nreturn and__4210__auto__;\n}\n})())){\nif(((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(zloc_type,new cljs.core.Keyword(null,\"agent\",\"agent\",-766455027))) || (cljs.core.realized_QMARK_(zloc)))){\nreturn zprint.zprint.fzprint_object.cljs$core$IFn$_invoke$arity$4(options,ind,zloc,(zprint.zfns.zderef.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zderef.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zderef.call(null,zloc)));\n} else {\nreturn zprint.zprint.fzprint_object.cljs$core$IFn$_invoke$arity$3(options,ind,zloc);\n}\n} else {\nvar l_str = \"#<\";\nvar r_str = \">\";\nvar indent = ((l_str).length);\nvar l_str_vec = new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [l_str,zprint.zprint.zcolor_map(options,l_str),new cljs.core.Keyword(null,\"left\",\"left\",-399115937)], null)], null);\nvar r_str_vec = zprint.zprint.rstr_vec.cljs$core$IFn$_invoke$arity$4(options,ind,zloc,r_str);\nvar type_str = (function (){var G__46061 = zloc_type;\nvar G__46061__$1 = (((G__46061 instanceof cljs.core.Keyword))?G__46061.fqn:null);\nswitch (G__46061__$1) {\ncase \"future\":\nreturn \"Future@\";\n\nbreak;\ncase \"promise\":\nreturn \"Promise@\";\n\nbreak;\ncase \"delay\":\nreturn \"Delay@\";\n\nbreak;\ncase \"agent\":\nreturn \"Agent@\";\n\nbreak;\ndefault:\nthrow (new Error([\"No matching clause: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(G__46061__$1)].join('')));\n\n}\n})();\nvar arg_1 = [cljs.core.str.cljs$core$IFn$_invoke$arity$1(type_str),zprint.zprint.hash_identity_str(zloc)].join('');\nvar arg_1_indent = (((ind + indent) + (1)) + ((arg_1).length));\nvar zloc_realized_QMARK_ = ((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(zloc_type,new cljs.core.Keyword(null,\"agent\",\"agent\",-766455027)))?true:cljs.core.realized_QMARK_(zloc));\nvar value = ((zloc_realized_QMARK_)?(zprint.zfns.zderef.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zderef.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zderef.call(null,zloc)):(function (){var G__46062 = zloc_type;\nvar G__46062__$1 = (((G__46062 instanceof cljs.core.Keyword))?G__46062.fqn:null);\nswitch (G__46062__$1) {\ncase \"future\":\nreturn \"pending\";\n\nbreak;\ncase \"promise\":\nreturn \"not-delivered\";\n\nbreak;\ncase \"delay\":\nreturn \"pending\";\n\nbreak;\ndefault:\nthrow (new Error([\"No matching clause: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(G__46062__$1)].join('')));\n\n}\n})());\nvar options__$1 = ((zloc_realized_QMARK_)?options:cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(options,new cljs.core.Keyword(null,\"string-str?\",\"string-str?\",2059147352),true));\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options__$1))){\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options__$1),cljs.core.pr_str.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\"fzprint-fpda: arg-1:\",arg_1,\"zstring arg-1:\",(zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zstring.call(null,zloc))], 0))], 0));\n} else {\n}\n\nreturn zprint.zprint.concat_no_nil.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([l_str_vec,new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [arg_1,zprint.zprint.zcolor_map(options__$1,new cljs.core.Keyword(null,\"none\",\"none\",1333468478)),new cljs.core.Keyword(null,\"element\",\"element\",1974019749)], null)], null),zprint.zprint.fzprint_hang_one(new cljs.core.Keyword(null,\"unknown\",\"unknown\",-935977881),zprint.zprint.rightmost(options__$1),arg_1_indent,(indent + ind),value),r_str_vec], 0));\n}\n});\n/**\n * Print a function object, what you get when you put a function in\n *   a collection, for instance.  This doesn't do macros, you will notice.\n *   It also can't be invoked when zloc is a zipper.\n */\nzprint.zprint.fzprint_fn_obj = (function zprint$zprint$fzprint_fn_obj(p__46063,ind,zloc){\nvar map__46064 = p__46063;\nvar map__46064__$1 = cljs.core.__destructure_map(map__46064);\nvar options = map__46064__$1;\nvar map__46065 = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__46064__$1,new cljs.core.Keyword(null,\"fn-obj\",\"fn-obj\",465065936));\nvar map__46065__$1 = cljs.core.__destructure_map(map__46065);\nvar object_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__46065__$1,new cljs.core.Keyword(null,\"object?\",\"object?\",-1313059217));\nif(cljs.core.truth_((function (){var and__4210__auto__ = object_QMARK_;\nif(cljs.core.truth_(and__4210__auto__)){\nreturn zprint.zprint.object_str_QMARK_((zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zstring.call(null,zloc)));\n} else {\nreturn and__4210__auto__;\n}\n})())){\nreturn zprint.zprint.fzprint_object.cljs$core$IFn$_invoke$arity$3(options,ind,zloc);\n} else {\nvar l_str = \"#<\";\nvar r_str = \">\";\nvar indent = ((l_str).length);\nvar l_str_vec = new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [l_str,zprint.zprint.zcolor_map(options,new cljs.core.Keyword(null,\"fn\",\"fn\",-1175266204)),new cljs.core.Keyword(null,\"left\",\"left\",-399115937)], null)], null);\nvar r_str_vec = zprint.zprint.rstr_vec.cljs$core$IFn$_invoke$arity$5(options,ind,zloc,r_str,new cljs.core.Keyword(null,\"fn\",\"fn\",-1175266204));\nvar arg_1_left = \"Fn@\";\nvar arg_1_right = zprint.zprint.hash_identity_str(zloc);\nvar arg_1_indent = ((((ind + indent) + (1)) + ((arg_1_left).length)) + ((arg_1_right).length));\nvar class_str = cljs.core.pr_str.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([cljs.core.type(zloc)], 0));\nvar name_js = cljs.core.str.cljs$core$IFn$_invoke$arity$1(zloc.name);\nvar color = (cljs.core.truth_((function (){var or__4212__auto__ = cljs.core.re_find(/^clojure/,name_js);\nif(cljs.core.truth_(or__4212__auto__)){\nreturn or__4212__auto__;\n} else {\nreturn cljs.core.re_find(/^cljs/,name_js);\n}\n})())?zprint.zprint.zcolor_map(options,new cljs.core.Keyword(null,\"fn\",\"fn\",-1175266204)):new cljs.core.Keyword(null,\"none\",\"none\",1333468478));\nvar name_split = clojure.string.split.cljs$core$IFn$_invoke$arity$2(name_js,/\\$/);\nvar arg_2 = [cljs.core.str.cljs$core$IFn$_invoke$arity$1(cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core.str,cljs.core.interpose.cljs$core$IFn$_invoke$arity$2(\".\",cljs.core.butlast(name_split)))),\"/\",cljs.core.str.cljs$core$IFn$_invoke$arity$1(cljs.core.last(name_split))].join('');\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options))){\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),cljs.core.pr_str.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\"fzprint-fn-obj: arg-1:\",arg_1_left,arg_1_right,\"zstring arg-1:\",(zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zstring.call(null,zloc))], 0))], 0));\n} else {\n}\n\nreturn zprint.zprint.concat_no_nil.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([l_str_vec,new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [arg_1_left,zprint.zprint.zcolor_map(options,new cljs.core.Keyword(null,\"fn\",\"fn\",-1175266204)),new cljs.core.Keyword(null,\"element\",\"element\",1974019749)], null)], null),new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [arg_1_right,zprint.zprint.zcolor_map(options,new cljs.core.Keyword(null,\"none\",\"none\",1333468478)),new cljs.core.Keyword(null,\"element\",\"element\",1974019749)], null)], null),zprint.zprint.fzprint_hang_one(new cljs.core.Keyword(null,\"unknown\",\"unknown\",-935977881),zprint.zprint.rightmost(cljs.core.assoc.cljs$core$IFn$_invoke$arity$variadic(options,new cljs.core.Keyword(null,\"string-str?\",\"string-str?\",2059147352),true,cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"string-color\",\"string-color\",-1853875244),color], 0))),arg_1_indent,(indent + ind),arg_2),r_str_vec], 0));\n}\n});\nzprint.zprint.fzprint_ns = (function zprint$zprint$fzprint_ns(options,ind,zloc){\nvar l_str = \"#<\";\nvar r_str = \">\";\nvar indent = ((l_str).length);\nvar l_str_vec = new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [l_str,zprint.zprint.zcolor_map(options,l_str),new cljs.core.Keyword(null,\"left\",\"left\",-399115937)], null)], null);\nvar r_str_vec = zprint.zprint.rstr_vec.cljs$core$IFn$_invoke$arity$4(options,ind,zloc,r_str);\nvar arg_1 = \"Namespace\";\nvar arg_1_indent = (((ind + indent) + (1)) + ((arg_1).length));\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options))){\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),cljs.core.pr_str.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\"fzprint-ns: arg-1:\",arg_1,\"zstring arg-1:\",(zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zstring.call(null,zloc))], 0))], 0));\n} else {\n}\n\nreturn zprint.zprint.concat_no_nil.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([l_str_vec,new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [arg_1,zprint.zprint.zcolor_map(options,new cljs.core.Keyword(null,\"none\",\"none\",1333468478)),new cljs.core.Keyword(null,\"element\",\"element\",1974019749)], null)], null),zprint.zprint.fzprint_hang_one(new cljs.core.Keyword(null,\"unknown\",\"unknown\",-935977881),zprint.zprint.rightmost(options),arg_1_indent,(indent + ind),cljs.core.ns_name(zloc)),r_str_vec], 0));\n});\n/**\n * Given an options map, decrement the :depth value and return the result.\n */\nzprint.zprint.dec_depth = (function zprint$zprint$dec_depth(options){\nif(cljs.core.truth_(options)){\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(options,new cljs.core.Keyword(null,\"depth\",\"depth\",1768663640),((function (){var or__4212__auto__ = new cljs.core.Keyword(null,\"depth\",\"depth\",1768663640).cljs$core$IFn$_invoke$arity$1(options);\nif(cljs.core.truth_(or__4212__auto__)){\nreturn or__4212__auto__;\n} else {\nreturn (1);\n}\n})() - (1)));\n} else {\nreturn null;\n}\n});\nzprint.zprint.fzprint_record = (function zprint$zprint$fzprint_record(p__46066,ind,zloc){\nvar map__46067 = p__46066;\nvar map__46067__$1 = cljs.core.__destructure_map(map__46067);\nvar options = map__46067__$1;\nvar map__46068 = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__46067__$1,new cljs.core.Keyword(null,\"record\",\"record\",-779106859));\nvar map__46068__$1 = cljs.core.__destructure_map(map__46068);\nvar record_type_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__46068__$1,new cljs.core.Keyword(null,\"record-type?\",\"record-type?\",-1195765660));\nvar to_string_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__46068__$1,new cljs.core.Keyword(null,\"to-string?\",\"to-string?\",1452120886));\nif(cljs.core.truth_(to_string_QMARK_)){\nvar G__46069 = options;\nvar G__46070 = ind;\nvar G__46071 = zloc.toString();\nreturn (zprint.zprint.fzprint_STAR_.cljs$core$IFn$_invoke$arity$3 ? zprint.zprint.fzprint_STAR_.cljs$core$IFn$_invoke$arity$3(G__46069,G__46070,G__46071) : zprint.zprint.fzprint_STAR_.call(null,G__46069,G__46070,G__46071));\n} else {\nif(cljs.core.not(record_type_QMARK_)){\nvar G__46072 = options;\nvar G__46073 = ind;\nvar G__46074 = cljs.core.into.cljs$core$IFn$_invoke$arity$2(cljs.core.PersistentArrayMap.EMPTY,zloc);\nreturn (zprint.zprint.fzprint_STAR_.cljs$core$IFn$_invoke$arity$3 ? zprint.zprint.fzprint_STAR_.cljs$core$IFn$_invoke$arity$3(G__46072,G__46073,G__46074) : zprint.zprint.fzprint_STAR_.call(null,G__46072,G__46073,G__46074));\n} else {\nvar l_str = \"#\";\nvar r_str = \"\";\nvar indent = ((l_str).length);\nvar l_str_vec = new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [l_str,zprint.zprint.zcolor_map(options,l_str),new cljs.core.Keyword(null,\"left\",\"left\",-399115937)], null)], null);\nvar r_str_vec = zprint.zprint.rstr_vec.cljs$core$IFn$_invoke$arity$4(options,ind,zloc,r_str);\nvar arg_1 = clojure.string.replace(cljs.core.pr_str.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([cljs.core.type(zloc)], 0)),\"/\",\".\");\nvar arg_1__$1 = (function (){var tokens = clojure.string.split.cljs$core$IFn$_invoke$arity$2(arg_1,/\\./);\nreturn cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core.str,cljs.core.into.cljs$core$IFn$_invoke$arity$2(cljs.core.PersistentVector.EMPTY,cljs.core.interpose.cljs$core$IFn$_invoke$arity$2(\".\",tokens)));\n})();\nvar arg_1_indent = (((ind + indent) + (1)) + cljs.core.count(arg_1__$1));\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options))){\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),cljs.core.pr_str.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\"fzprint-record: arg-1:\",arg_1__$1,\"zstring zloc:\",(zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zstring.call(null,zloc))], 0))], 0));\n} else {\n}\n\nreturn zprint.zprint.concat_no_nil.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([l_str_vec,new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [arg_1__$1,zprint.zprint.zcolor_map(options,new cljs.core.Keyword(null,\"none\",\"none\",1333468478)),new cljs.core.Keyword(null,\"element\",\"element\",1974019749)], null)], null),zprint.zprint.fzprint_hang_one(new cljs.core.Keyword(null,\"record\",\"record\",-779106859),zprint.zprint.dec_depth(options),arg_1_indent,(indent + ind),cljs.core.into.cljs$core$IFn$_invoke$arity$2(cljs.core.PersistentArrayMap.EMPTY,zloc)),r_str_vec], 0));\n}\n}\n});\n/**\n * Print the two items in a meta node.  Different because it doesn't print\n *   a single collection, so it doesn't do any indent or rightmost.  It also\n *   uses a different approach to calling fzprint-flow-seq with the\n *   results zmap, so that it prints all of the seq, not just the rightmost.\n */\nzprint.zprint.fzprint_meta = (function zprint$zprint$fzprint_meta(options,ind,zloc){\nvar l_str = \"^\";\nvar r_str = \"\";\nvar l_str_vec = new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [l_str,zprint.zprint.zcolor_map(options,l_str),new cljs.core.Keyword(null,\"left\",\"left\",-399115937)], null)], null);\nvar r_str_vec = zprint.zprint.rstr_vec.cljs$core$IFn$_invoke$arity$4(options,ind,zloc,r_str);\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options))){\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),cljs.core.pr_str.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\"fzprint-meta: zloc:\",(zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zstring.call(null,zloc))], 0))], 0));\n} else {\n}\n\nreturn zprint.zprint.concat_no_nil.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([l_str_vec,(cljs.core.truth_(new cljs.core.Keyword(null,\"indent-only?\",\"indent-only?\",375678842).cljs$core$IFn$_invoke$arity$1(new cljs.core.Keyword(null,\"list\",\"list\",765357683).cljs$core$IFn$_invoke$arity$1(options)))?zprint.zprint.fzprint_indent.cljs$core$IFn$_invoke$arity$9(new cljs.core.Keyword(null,\"vector\",\"vector\",1902966158),l_str,\"\",options,ind,zloc,null,null,new cljs.core.Keyword(null,\"first-indent-only?\",\"first-indent-only?\",319167353)):zprint.zprint.fzprint_flow_seq.cljs$core$IFn$_invoke$arity$3(options,cljs.core.apply.cljs$core$IFn$_invoke$arity$3(cljs.core.vector,(((l_str).length) + ind),cljs.core.repeat.cljs$core$IFn$_invoke$arity$2(((zprint.zfns.zcount.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zcount.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zcount.call(null,zloc)) - (1)),ind)),zprint.zprint.fzprint_get_zloc_seq(new cljs.core.Keyword(null,\"list\",\"list\",765357683),options,zloc))),r_str_vec], 0));\n});\n/**\n * Print a reader-macro, often a reader-conditional. Adapted for differences\n *   in parsing #?@ between rewrite-clj and rewrite-cljs.  Also adapted for\n *   the rewrite-clj not parsing namespaced maps in the version presently\n *   used.\n */\nzprint.zprint.fzprint_reader_macro = (function zprint$zprint$fzprint_reader_macro(options,ind,zloc){\nvar zstr = (function (){var G__46078 = (zprint.zfns.zfirst.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zfirst.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zfirst.call(null,zloc));\nreturn (zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1(G__46078) : zprint.zfns.zstring.call(null,G__46078));\n})();\nvar alt_at_QMARK_ = ((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(cljs.core.count(zstr),(2))) && (cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(cljs.core.subs.cljs$core$IFn$_invoke$arity$3(zstr,(1),(2)),\"@\")));\nvar reader_cond_QMARK_ = cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(cljs.core.subs.cljs$core$IFn$_invoke$arity$3(zstr,(0),(1)),\"?\");\nvar namespaced_QMARK_ = cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(cljs.core.subs.cljs$core$IFn$_invoke$arity$3(zstr,(0),(1)),\":\");\nvar at_QMARK_ = ((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2((function (){var G__46079 = (zprint.zfns.zsecond.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zsecond.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zsecond.call(null,zloc));\nreturn (zprint.zfns.ztag.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.ztag.cljs$core$IFn$_invoke$arity$1(G__46079) : zprint.zfns.ztag.call(null,G__46079));\n})(),new cljs.core.Keyword(null,\"deref\",\"deref\",-145586795))) || (alt_at_QMARK_));\nvar vec__46075 = zprint.zprint.get_respect_indent(options,new cljs.core.Keyword(null,\"reader-cond\",\"reader-cond\",-2133265058),new cljs.core.Keyword(null,\"map\",\"map\",1371690461));\nvar respect_nl_QMARK_ = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__46075,(0),null);\nvar respect_bl_QMARK_ = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__46075,(1),null);\nvar indent_only_QMARK_ = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__46075,(2),null);\nvar l_str = ((((reader_cond_QMARK_) && (at_QMARK_)))?\"#?@\":(cljs.core.truth_((function (){var and__4210__auto__ = reader_cond_QMARK_;\nif(and__4210__auto__){\nvar G__46080 = (zprint.zfns.zsecond.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zsecond.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zsecond.call(null,zloc));\nreturn (zprint.zfns.zcoll_QMARK_.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zcoll_QMARK_.cljs$core$IFn$_invoke$arity$1(G__46080) : zprint.zfns.zcoll_QMARK_.call(null,G__46080));\n} else {\nreturn and__4210__auto__;\n}\n})())?\"#?\":((reader_cond_QMARK_)?(function(){throw (new Error([\"Unknown reader macro: '\",cljs.core.str.cljs$core$IFn$_invoke$arity$1((zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zstring.call(null,zloc))),\"' zfirst zloc: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1((function (){var G__46082 = (zprint.zfns.zfirst.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zfirst.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zfirst.call(null,zloc));\nreturn (zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1(G__46082) : zprint.zfns.zstring.call(null,G__46082));\n})())].join('')))})():((namespaced_QMARK_)?[\"#\",cljs.core.str.cljs$core$IFn$_invoke$arity$1(zstr)].join(''):\"#\"\n))));\nvar r_str = \"\";\nvar _ = (cljs.core.truth_(new cljs.core.Keyword(null,\"dbg-bug?\",\"dbg-bug?\",-315779526).cljs$core$IFn$_invoke$arity$1(options))?null:null);\nvar indent = ((l_str).length);\nvar l_str_vec = new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [l_str,zprint.zprint.zcolor_map(options,l_str),new cljs.core.Keyword(null,\"left\",\"left\",-399115937)], null)], null);\nvar r_str_vec = zprint.zprint.rstr_vec.cljs$core$IFn$_invoke$arity$4(options,ind,zloc,r_str);\nvar floc = ((((at_QMARK_) && ((!(alt_at_QMARK_)))))?(function (){var G__46083 = (zprint.zfns.zsecond.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zsecond.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zsecond.call(null,zloc));\nreturn (zprint.zfns.zfirst.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zfirst.cljs$core$IFn$_invoke$arity$1(G__46083) : zprint.zfns.zfirst.call(null,G__46083));\n})():(zprint.zfns.zsecond.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zsecond.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zsecond.call(null,zloc)));\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options))){\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),cljs.core.pr_str.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\"fzprint-reader-macro: zloc:\",(zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zstring.call(null,zloc)),\"floc:\",(zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1(floc) : zprint.zfns.zstring.call(null,floc)),\"l-str:\",l_str], 0))], 0));\n} else {\n}\n\nif(cljs.core.truth_(indent_only_QMARK_)){\nvar l_str_io = ((reader_cond_QMARK_)?[l_str,\"(\"].join(''):l_str);\nvar r_str_io = ((reader_cond_QMARK_)?\")\":\"\");\nvar l_str_vec_io = new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [l_str_io,zprint.zprint.zcolor_map(options,l_str_io),new cljs.core.Keyword(null,\"left\",\"left\",-399115937)], null)], null);\nvar r_str_vec_io = zprint.zprint.rstr_vec.cljs$core$IFn$_invoke$arity$4(options,ind,zloc,r_str_io);\nreturn zprint.zprint.concat_no_nil.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([l_str_vec_io,((reader_cond_QMARK_)?zprint.zprint.fzprint_indent.cljs$core$IFn$_invoke$arity$8(new cljs.core.Keyword(null,\"map\",\"map\",1371690461),l_str_io,r_str_io,zprint.zprint.rightmost(options),ind,floc,null,null):zprint.zprint.fzprint_indent.cljs$core$IFn$_invoke$arity$8(new cljs.core.Keyword(null,\"map\",\"map\",1371690461),l_str_io,r_str_io,zprint.zprint.rightmost(options),ind,((namespaced_QMARK_)?(zprint.zfns.znextnws_w_nl.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.znextnws_w_nl.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.znextnws_w_nl.call(null,zloc)):zloc),null,null)),r_str_vec_io], 0));\n} else {\nreturn zprint.zprint.concat_no_nil.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([l_str_vec,new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [\"\",new cljs.core.Keyword(null,\"none\",\"none\",1333468478),new cljs.core.Keyword(null,\"element\",\"element\",1974019749)], null)], null),((reader_cond_QMARK_)?zprint.zprint.fzprint_map_STAR_(new cljs.core.Keyword(null,\"reader-cond\",\"reader-cond\",-2133265058),\"(\",\")\",zprint.zprint.rightmost(options),(indent + ind),floc,null):zprint.zprint.fzprint_flow_seq.cljs$core$IFn$_invoke$arity$3(options,(indent + ind),(function (){var zloc_seq = (cljs.core.truth_(respect_nl_QMARK_)?(zprint.zfns.zmap_w_nl.cljs$core$IFn$_invoke$arity$2 ? zprint.zfns.zmap_w_nl.cljs$core$IFn$_invoke$arity$2(cljs.core.identity,zloc) : zprint.zfns.zmap_w_nl.call(null,cljs.core.identity,zloc)):(cljs.core.truth_(respect_bl_QMARK_)?(zprint.zfns.zmap_w_bl.cljs$core$IFn$_invoke$arity$2 ? zprint.zfns.zmap_w_bl.cljs$core$IFn$_invoke$arity$2(cljs.core.identity,zloc) : zprint.zfns.zmap_w_bl.call(null,cljs.core.identity,zloc)):(zprint.zfns.zmap.cljs$core$IFn$_invoke$arity$2 ? zprint.zfns.zmap.cljs$core$IFn$_invoke$arity$2(cljs.core.identity,zloc) : zprint.zfns.zmap.call(null,cljs.core.identity,zloc))\n));\nif(namespaced_QMARK_){\nreturn cljs.core.next(zloc_seq);\n} else {\nreturn zloc_seq;\n}\n})())),r_str_vec], 0));\n}\n});\n/**\n * Given an element which contains newlines, split it up into individual\n *   newline elements.\n */\nzprint.zprint.fzprint_newline = (function zprint$zprint$fzprint_newline(options,ind,zloc){\nvar zstr = (zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zstring.call(null,zloc));\nvar vec__46084 = zprint.finish.newline_vec(zstr);\nvar newline_count = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__46084,(0),null);\nvar _ = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__46084,(1),null);\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options))){\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),cljs.core.pr_str.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\"fzprint-newline: zloc:\",(zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zstring.call(null,zloc)),\"newline-count:\",newline_count,\"ind:\",ind], 0))], 0));\n} else {\n}\n\nreturn cljs.core.into.cljs$core$IFn$_invoke$arity$2(cljs.core.PersistentVector.EMPTY,cljs.core.repeat.cljs$core$IFn$_invoke$arity$2(newline_count,new cljs.core.PersistentVector(null, 4, 5, cljs.core.PersistentVector.EMPTY_NODE, [[\"\\n\",cljs.core.str.cljs$core$IFn$_invoke$arity$1(zprint.zprint.blanks(ind))].join(''),new cljs.core.Keyword(null,\"none\",\"none\",1333468478),new cljs.core.Keyword(null,\"newline\",\"newline\",1790071323),(2)], null)));\n});\nzprint.zprint.prefix_tags = new cljs.core.PersistentArrayMap(null, 7, [new cljs.core.Keyword(null,\"quote\",\"quote\",-262615245),\"'\",new cljs.core.Keyword(null,\"syntax-quote\",\"syntax-quote\",-1233164847),\"`\",new cljs.core.Keyword(null,\"unquote\",\"unquote\",1649741032),\"~\",new cljs.core.Keyword(null,\"unquote-splicing\",\"unquote-splicing\",1295267556),\"~@\",new cljs.core.Keyword(null,\"deref\",\"deref\",-145586795),\"@\",new cljs.core.Keyword(null,\"var\",\"var\",-769682797),\"#'\",new cljs.core.Keyword(null,\"uneval\",\"uneval\",1932037707),\"#_\"], null);\n/**\n * Change options as necessary based on prefix tag.\n */\nzprint.zprint.prefix_options = (function zprint$zprint$prefix_options(options,prefix_tag){\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(prefix_tag,new cljs.core.Keyword(null,\"uneval\",\"uneval\",1932037707))){\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(options,new cljs.core.Keyword(null,\"color-map\",\"color-map\",-207789684),new cljs.core.Keyword(null,\"color-map\",\"color-map\",-207789684).cljs$core$IFn$_invoke$arity$1(new cljs.core.Keyword(null,\"uneval\",\"uneval\",1932037707).cljs$core$IFn$_invoke$arity$1(options)));\n} else {\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(prefix_tag,new cljs.core.Keyword(null,\"syntax-quote\",\"syntax-quote\",-1233164847))){\nreturn cljs.core.assoc_in(cljs.core.assoc_in(options,new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,\"color-map\",\"color-map\",-207789684),new cljs.core.Keyword(null,\"paren\",\"paren\",-294107600)], null),new cljs.core.Keyword(null,\"syntax-quote-paren\",\"syntax-quote-paren\",646342677).cljs$core$IFn$_invoke$arity$1(new cljs.core.Keyword(null,\"color-map\",\"color-map\",-207789684).cljs$core$IFn$_invoke$arity$1(options))),new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,\"color-map\",\"color-map\",-207789684),new cljs.core.Keyword(null,\"hash-paren\",\"hash-paren\",-1158425562)], null),new cljs.core.Keyword(null,\"syntax-quote-paren\",\"syntax-quote-paren\",646342677).cljs$core$IFn$_invoke$arity$1(new cljs.core.Keyword(null,\"color-map\",\"color-map\",-207789684).cljs$core$IFn$_invoke$arity$1(options)));\n} else {\nreturn options;\n\n}\n}\n});\n/**\n * Sometime we need to give a caller to a routine, and there isn't\n *   a specific caller in the configuration.  So, we will use the configuration\n *   from some other caller and make up a new one just for this situation.\n *   The key-seq is the series of keys to both look up and create.  The\n *   caller is the new caller, and the existing-caller is the one from which\n *   we we will extract the information. This returns a new options map with\n *   the new-caller in it.\n */\nzprint.zprint.make_caller = (function zprint$zprint$make_caller(options,new_caller,existing_caller,key_seq){\nreturn cljs.core.update_in.cljs$core$IFn$_invoke$arity$3(options,cljs.core.concat.cljs$core$IFn$_invoke$arity$2(new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new_caller], null),key_seq),(function (p1__46087_SHARP_){\n\nreturn cljs.core.get_in.cljs$core$IFn$_invoke$arity$2(options,cljs.core.concat.cljs$core$IFn$_invoke$arity$2(new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [existing_caller], null),key_seq));\n}));\n});\n/**\n * The pretty print part of fzprint.\n */\nzprint.zprint.fzprint_STAR_ = (function zprint$zprint$fzprint_STAR_(p__46088,indent,zloc){\nvar map__46089 = p__46088;\nvar map__46089__$1 = cljs.core.__destructure_map(map__46089);\nvar options = map__46089__$1;\nvar max_depth = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__46089__$1,new cljs.core.Keyword(null,\"max-depth\",\"max-depth\",127060793));\nvar fn_map = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__46089__$1,new cljs.core.Keyword(null,\"fn-map\",\"fn-map\",565481146));\nvar shift_seq = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__46089__$1,new cljs.core.Keyword(null,\"shift-seq\",\"shift-seq\",267527195));\nvar max_hang_count = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__46089__$1,new cljs.core.Keyword(null,\"max-hang-count\",\"max-hang-count\",637294812));\nvar in_code_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__46089__$1,new cljs.core.Keyword(null,\"in-code?\",\"in-code?\",194866464));\nvar max_hang_depth = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__46089__$1,new cljs.core.Keyword(null,\"max-hang-depth\",\"max-hang-depth\",-915232220));\nvar next_inner = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__46089__$1,new cljs.core.Keyword(null,\"next-inner\",\"next-inner\",608504966));\nvar in_hang_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__46089__$1,new cljs.core.Keyword(null,\"in-hang?\",\"in-hang?\",-1065695639));\nvar rightcnt = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__46089__$1,new cljs.core.Keyword(null,\"rightcnt\",\"rightcnt\",-45750070));\nvar width = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__46089__$1,new cljs.core.Keyword(null,\"width\",\"width\",-384071477));\nvar hex_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__46089__$1,new cljs.core.Keyword(null,\"hex?\",\"hex?\",890937870));\nvar dbg_print_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__46089__$1,new cljs.core.Keyword(null,\"dbg-print?\",\"dbg-print?\",-660113872));\nvar dbg_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__46089__$1,new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771));\nvar string_color = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__46089__$1,new cljs.core.Keyword(null,\"string-color\",\"string-color\",-1853875244));\nvar trim_comments_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__46089__$1,new cljs.core.Keyword(null,\"trim-comments?\",\"trim-comments?\",-1532658667));\nvar max_hang_span = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__46089__$1,new cljs.core.Keyword(null,\"max-hang-span\",\"max-hang-span\",256100693));\nvar one_line_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__46089__$1,new cljs.core.Keyword(null,\"one-line?\",\"one-line?\",2055953111));\nvar depth = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__46089__$1,new cljs.core.Keyword(null,\"depth\",\"depth\",1768663640));\nvar string_str_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__46089__$1,new cljs.core.Keyword(null,\"string-str?\",\"string-str?\",2059147352));\nvar avail = (width - indent);\nvar options__$1 = cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(options,new cljs.core.Keyword(null,\"depth\",\"depth\",1768663640),(depth + (1)));\nvar options__$2 = (cljs.core.truth_(next_inner)?cljs.core.dissoc.cljs$core$IFn$_invoke$arity$2(cljs.core.first(zprint.config.config_and_validate(\"next-inner:\",null,options__$1,next_inner)),new cljs.core.Keyword(null,\"next-inner\",\"next-inner\",608504966)):options__$1);\nvar options__$3 = (cljs.core.truth_((function (){var or__4212__auto__ = dbg_QMARK_;\nif(cljs.core.truth_(or__4212__auto__)){\nreturn or__4212__auto__;\n} else {\nreturn dbg_print_QMARK_;\n}\n})())?cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(options__$2,new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778),[cljs.core.str.cljs$core$IFn$_invoke$arity$1(cljs.core.get.cljs$core$IFn$_invoke$arity$3(options__$2,new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778),\"\")),(cljs.core.truth_(one_line_QMARK_)?\"o\":(cljs.core.truth_(in_hang_QMARK_)?\"h\":\".\"\n))].join('')):options__$2);\nvar _ = (cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options__$3))?cljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options__$3),\"fzprint* **** rightcnt:\",rightcnt,\"depth:\",depth,\"in-hang?:\",in_hang_QMARK_,cljs.core.pr_str.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([(zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zstring.call(null,zloc))], 0))], 0)):null);\nvar dbg_data = cljs.core.deref(zprint.zprint.fzprint_dbg);\nvar dbg_focus_QMARK_ = (function (){var and__4210__auto__ = dbg_QMARK_;\nif(cljs.core.truth_(and__4210__auto__)){\nreturn cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(dbg_data,cljs.core.second((zprint.zfns.zfind_path.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zfind_path.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zfind_path.call(null,zloc))));\n} else {\nreturn and__4210__auto__;\n}\n})();\nvar options__$4 = (cljs.core.truth_(dbg_focus_QMARK_)?cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(options__$3,new cljs.core.Keyword(null,\"dbg\",\"dbg\",202767554),new cljs.core.Keyword(null,\"on\",\"on\",173873944)):options__$3);\nvar ___$1 = (cljs.core.truth_(dbg_focus_QMARK_)?cljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\"fzprint dbg-data:\",dbg_data], 0)):null);\nif(cljs.core.truth_((function (){var and__4210__auto__ = (zprint.zfns.zcoll_QMARK_.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zcoll_QMARK_.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zcoll_QMARK_.call(null,zloc));\nif(cljs.core.truth_(and__4210__auto__)){\nreturn (((depth >= max_depth)) || ((zprint.zprint.get_max_length(options__$4) === (0))));\n} else {\nreturn and__4210__auto__;\n}\n})())){\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(zloc,(zprint.zfns.zdotdotdot.cljs$core$IFn$_invoke$arity$0 ? zprint.zfns.zdotdotdot.cljs$core$IFn$_invoke$arity$0() : zprint.zfns.zdotdotdot.call(null)))){\nreturn new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [\"...\",zprint.zprint.zcolor_map(options__$4,new cljs.core.Keyword(null,\"none\",\"none\",1333468478)),new cljs.core.Keyword(null,\"element\",\"element\",1974019749)], null)], null);\n} else {\nreturn new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,\"max-depth-string\",\"max-depth-string\",-474325435).cljs$core$IFn$_invoke$arity$1(options__$4),zprint.zprint.zcolor_map(options__$4,new cljs.core.Keyword(null,\"keyword\",\"keyword\",811389747)),new cljs.core.Keyword(null,\"element\",\"element\",1974019749)], null)], null);\n}\n} else {\nif(cljs.core.truth_((function (){var and__4210__auto__ = in_hang_QMARK_;\nif(cljs.core.truth_(and__4210__auto__)){\nreturn ((cljs.core.not(one_line_QMARK_)) && (((cljs.core.not(in_code_QMARK_)) && (((((depth - in_hang_QMARK_) > max_hang_span)) || (((cljs.core.not(one_line_QMARK_)) && (((((zprint.zfns.zcount.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zcount.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zcount.call(null,zloc)) > max_hang_count)) && ((depth > max_hang_depth)))))))))));\n} else {\nreturn and__4210__auto__;\n}\n})())){\nreturn null;\n} else {\nif(cljs.core.truth_((zprint.zfns.zrecord_QMARK_.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zrecord_QMARK_.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zrecord_QMARK_.call(null,zloc)))){\nreturn zprint.zprint.fzprint_record(options__$4,indent,zloc);\n} else {\nif(cljs.core.truth_((zprint.zfns.zlist_QMARK_.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zlist_QMARK_.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zlist_QMARK_.call(null,zloc)))){\nreturn zprint.zprint.fzprint_list(options__$4,indent,zloc);\n} else {\nif(cljs.core.truth_((zprint.zfns.zvector_QMARK_.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zvector_QMARK_.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zvector_QMARK_.call(null,zloc)))){\nreturn zprint.zprint.fzprint_vec(options__$4,indent,zloc);\n} else {\nif(cljs.core.truth_((function (){var or__4212__auto__ = (zprint.zfns.zmap_QMARK_.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zmap_QMARK_.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zmap_QMARK_.call(null,zloc));\nif(cljs.core.truth_(or__4212__auto__)){\nreturn or__4212__auto__;\n} else {\nreturn (zprint.zfns.znamespacedmap_QMARK_.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.znamespacedmap_QMARK_.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.znamespacedmap_QMARK_.call(null,zloc));\n}\n})())){\nreturn zprint.zprint.fzprint_map(options__$4,indent,zloc);\n} else {\nif(cljs.core.truth_((zprint.zfns.zset_QMARK_.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zset_QMARK_.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zset_QMARK_.call(null,zloc)))){\nreturn zprint.zprint.fzprint_set(options__$4,indent,zloc);\n} else {\nif(cljs.core.truth_((zprint.zfns.zanonfn_QMARK_.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zanonfn_QMARK_.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zanonfn_QMARK_.call(null,zloc)))){\nreturn zprint.zprint.fzprint_anon_fn(options__$4,indent,zloc);\n} else {\nif(cljs.core.truth_((zprint.zfns.zfn_obj_QMARK_.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zfn_obj_QMARK_.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zfn_obj_QMARK_.call(null,zloc)))){\nreturn zprint.zprint.fzprint_fn_obj(options__$4,indent,zloc);\n} else {\nif(cljs.core.truth_((zprint.zfns.zarray_QMARK_.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zarray_QMARK_.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zarray_QMARK_.call(null,zloc)))){\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"object?\",\"object?\",-1313059217).cljs$core$IFn$_invoke$arity$1(new cljs.core.Keyword(null,\"array\",\"array\",-2080713842).cljs$core$IFn$_invoke$arity$1(options__$4)))){\nreturn zprint.zprint.fzprint_object.cljs$core$IFn$_invoke$arity$3(options__$4,indent,zloc);\n} else {\nreturn zprint.zprint.fzprint_array(options__$4,indent,(zprint.zfns.zexpandarray.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zexpandarray.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zexpandarray.call(null,zloc)));\n}\n} else {\nif(cljs.core.truth_((zprint.zfns.zatom_QMARK_.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zatom_QMARK_.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zatom_QMARK_.call(null,zloc)))){\nreturn zprint.zprint.fzprint_atom(options__$4,indent,zloc);\n} else {\nif(cljs.core.truth_((zprint.zfns.zmeta_QMARK_.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zmeta_QMARK_.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zmeta_QMARK_.call(null,zloc)))){\nreturn zprint.zprint.fzprint_meta(options__$4,indent,zloc);\n} else {\nif(cljs.core.truth_((function (){var G__46090 = (zprint.zfns.ztag.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.ztag.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.ztag.call(null,zloc));\nreturn (zprint.zprint.prefix_tags.cljs$core$IFn$_invoke$arity$1 ? zprint.zprint.prefix_tags.cljs$core$IFn$_invoke$arity$1(G__46090) : zprint.zprint.prefix_tags.call(null,G__46090));\n})())){\nreturn zprint.zprint.fzprint_vec_STAR_(new cljs.core.Keyword(null,\"prefix-tags\",\"prefix-tags\",-348485792),(function (){var G__46091 = (zprint.zfns.ztag.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.ztag.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.ztag.call(null,zloc));\nreturn (zprint.zprint.prefix_tags.cljs$core$IFn$_invoke$arity$1 ? zprint.zprint.prefix_tags.cljs$core$IFn$_invoke$arity$1(G__46091) : zprint.zprint.prefix_tags.call(null,G__46091));\n})(),\"\",zprint.zprint.make_caller(zprint.zprint.make_caller(zprint.zprint.make_caller(zprint.zprint.prefix_options(options__$4,(zprint.zfns.ztag.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.ztag.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.ztag.call(null,zloc))),new cljs.core.Keyword(null,\"prefix-tags\",\"prefix-tags\",-348485792),new cljs.core.Keyword(null,\"list\",\"list\",765357683),new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,\"indent-only?\",\"indent-only?\",375678842)], null)),new cljs.core.Keyword(null,\"prefix-tags\",\"prefix-tags\",-348485792),new cljs.core.Keyword(null,\"list\",\"list\",765357683),new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,\"respect-nl?\",\"respect-nl?\",604814635)], null)),new cljs.core.Keyword(null,\"prefix-tags\",\"prefix-tags\",-348485792),new cljs.core.Keyword(null,\"list\",\"list\",765357683),new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,\"respect-bl?\",\"respect-bl?\",298921998)], null)),indent,zloc);\n} else {\nif(cljs.core.truth_((zprint.zfns.zns_QMARK_.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zns_QMARK_.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zns_QMARK_.call(null,zloc)))){\nreturn zprint.zprint.fzprint_ns(options__$4,indent,zloc);\n} else {\nif(cljs.core.truth_((function (){var or__4212__auto__ = (zprint.zfns.zpromise_QMARK_.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zpromise_QMARK_.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zpromise_QMARK_.call(null,zloc));\nif(cljs.core.truth_(or__4212__auto__)){\nreturn or__4212__auto__;\n} else {\nvar or__4212__auto____$1 = (zprint.zfns.zfuture_QMARK_.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zfuture_QMARK_.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zfuture_QMARK_.call(null,zloc));\nif(cljs.core.truth_(or__4212__auto____$1)){\nreturn or__4212__auto____$1;\n} else {\nvar or__4212__auto____$2 = (zprint.zfns.zdelay_QMARK_.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zdelay_QMARK_.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zdelay_QMARK_.call(null,zloc));\nif(cljs.core.truth_(or__4212__auto____$2)){\nreturn or__4212__auto____$2;\n} else {\nreturn (zprint.zfns.zagent_QMARK_.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zagent_QMARK_.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zagent_QMARK_.call(null,zloc));\n}\n}\n}\n})())){\nreturn zprint.zprint.fzprint_future_promise_delay_agent(options__$4,indent,zloc);\n} else {\nif(cljs.core.truth_((zprint.zfns.zreader_macro_QMARK_.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zreader_macro_QMARK_.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zreader_macro_QMARK_.call(null,zloc)))){\nreturn zprint.zprint.fzprint_reader_macro(options__$4,indent,zloc);\n} else {\nif(((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2((zprint.zfns.ztag.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.ztag.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.ztag.call(null,zloc)),new cljs.core.Keyword(null,\"newline\",\"newline\",1790071323))) && ((depth > (0))))){\nreturn zprint.zprint.fzprint_newline(options__$4,indent,zloc);\n} else {\nvar zstr = (zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zstring.call(null,zloc));\nvar overflow_in_hang_QMARK_ = (function (){var and__4210__auto__ = in_hang_QMARK_;\nif(cljs.core.truth_(and__4210__auto__)){\nreturn (((cljs.core.count(zstr) + indent) + (function (){var or__4212__auto__ = rightcnt;\nif(cljs.core.truth_(or__4212__auto__)){\nreturn or__4212__auto__;\n} else {\nreturn (0);\n}\n})()) > width);\n} else {\nreturn and__4210__auto__;\n}\n})();\nif(cljs.core.truth_((function (){var and__4210__auto__ = (zprint.zfns.zcomment_QMARK_.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zcomment_QMARK_.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zcomment_QMARK_.call(null,zloc));\nif(cljs.core.truth_(and__4210__auto__)){\nreturn cljs.core.not(cljs.core.some(new cljs.core.PersistentHashSet(null, new cljs.core.PersistentArrayMap(null, 1, [\";\",null], null), null),zstr));\n} else {\nreturn and__4210__auto__;\n}\n})())){\nreturn zprint.zprint.fzprint_newline(options__$4,indent,zloc);\n} else {\nif(cljs.core.truth_((zprint.zfns.zcomment_QMARK_.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zcomment_QMARK_.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zcomment_QMARK_.call(null,zloc)))){\nvar zcomment = (((((depth === (0))) && (cljs.core.not(trim_comments_QMARK_))))?zstr:clojure.string.trimr(zstr));\nvar inline_comment_vec = (cljs.core.truth_(new cljs.core.Keyword(null,\"inline?\",\"inline?\",-1674483791).cljs$core$IFn$_invoke$arity$1(new cljs.core.Keyword(null,\"comment\",\"comment\",532206069).cljs$core$IFn$_invoke$arity$1(options__$4)))?(zprint.zprint.inlinecomment_QMARK_.cljs$core$IFn$_invoke$arity$1 ? zprint.zprint.inlinecomment_QMARK_.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zprint.inlinecomment_QMARK_.call(null,zloc)):null);\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options__$4))){\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options__$4),\"fzprint* trim-comments?:\",trim_comments_QMARK_,\"inline-comment-vec:\",inline_comment_vec], 0));\n} else {\n}\n\nif(cljs.core.truth_((function (){var and__4210__auto__ = new cljs.core.Keyword(null,\"count?\",\"count?\",-122202128).cljs$core$IFn$_invoke$arity$1(new cljs.core.Keyword(null,\"comment\",\"comment\",532206069).cljs$core$IFn$_invoke$arity$1(options__$4));\nif(cljs.core.truth_(and__4210__auto__)){\nreturn overflow_in_hang_QMARK_;\n} else {\nreturn and__4210__auto__;\n}\n})())){\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options__$4))){\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options__$4),\"fzprint*: overflow comment ========\"], 0));\n} else {\n}\n\nreturn null;\n} else {\nif(cljs.core.truth_(inline_comment_vec)){\nreturn new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 5, 5, cljs.core.PersistentVector.EMPTY_NODE, [zcomment,zprint.zprint.zcolor_map(options__$4,new cljs.core.Keyword(null,\"comment\",\"comment\",532206069)),new cljs.core.Keyword(null,\"comment-inline\",\"comment-inline\",712944405),cljs.core.first(inline_comment_vec),cljs.core.second(inline_comment_vec)], null)], null);\n} else {\nreturn new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [zcomment,zprint.zprint.zcolor_map(options__$4,new cljs.core.Keyword(null,\"comment\",\"comment\",532206069)),new cljs.core.Keyword(null,\"comment\",\"comment\",532206069)], null)], null);\n}\n}\n} else {\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2((zprint.zfns.ztag.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.ztag.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.ztag.call(null,zloc)),new cljs.core.Keyword(null,\"comma\",\"comma\",1699024745))){\nreturn new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [zstr,zprint.zprint.zcolor_map(options__$4,new cljs.core.Keyword(null,\"comma\",\"comma\",1699024745)),new cljs.core.Keyword(null,\"comma\",\"comma\",1699024745)], null)], null);\n} else {\nif(((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2((zprint.zfns.ztag.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.ztag.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.ztag.call(null,zloc)),new cljs.core.Keyword(null,\"whitespace\",\"whitespace\",-1340035483))) && (clojure.string.includes_QMARK_(zstr,\",\")))){\nreturn new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [\",\",zprint.zprint.zcolor_map(options__$4,new cljs.core.Keyword(null,\"comma\",\"comma\",1699024745)),new cljs.core.Keyword(null,\"comma\",\"comma\",1699024745)], null)], null);\n} else {\nif(cljs.core.truth_((zprint.zfns.zwhitespaceorcomment_QMARK_.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zwhitespaceorcomment_QMARK_.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zwhitespaceorcomment_QMARK_.call(null,zloc)))){\nreturn new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 4, 5, cljs.core.PersistentVector.EMPTY_NODE, [zstr,new cljs.core.Keyword(null,\"none\",\"none\",1333468478),new cljs.core.Keyword(null,\"whitespace\",\"whitespace\",-1340035483),(24)], null)], null);\n} else {\nif(cljs.core.truth_(overflow_in_hang_QMARK_)){\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options__$4))){\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options__$4),\"fzprint*: overflow <<<<<<<<<<\"], 0));\n} else {\n}\n\nreturn null;\n} else {\nif(cljs.core.truth_((zprint.zfns.zkeyword_QMARK_.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zkeyword_QMARK_.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zkeyword_QMARK_.call(null,zloc)))){\nreturn new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [zstr,zprint.zprint.zcolor_map(options__$4,new cljs.core.Keyword(null,\"keyword\",\"keyword\",811389747)),new cljs.core.Keyword(null,\"element\",\"element\",1974019749)], null)], null);\n} else {\nvar zloc_sexpr = (zprint.zfns.zsexpr.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zsexpr.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zsexpr.call(null,zloc));\nif(typeof zloc_sexpr === 'string'){\nreturn new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [(cljs.core.truth_(string_str_QMARK_)?cljs.core.str.cljs$core$IFn$_invoke$arity$1((zprint.zfns.zsexpr.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zsexpr.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zsexpr.call(null,zloc))):(zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zstring.call(null,zloc))),(cljs.core.truth_(string_color)?string_color:zprint.zprint.zcolor_map(options__$4,new cljs.core.Keyword(null,\"string\",\"string\",-1989541586))),new cljs.core.Keyword(null,\"element\",\"element\",1974019749)], null)], null);\n} else {\nif(cljs.core.truth_(zprint.zprint.showfn_QMARK_(fn_map,(zprint.zfns.zsexpr.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zsexpr.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zsexpr.call(null,zloc))))){\nreturn new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [zstr,zprint.zprint.zcolor_map(options__$4,new cljs.core.Keyword(null,\"fn\",\"fn\",-1175266204)),new cljs.core.Keyword(null,\"element\",\"element\",1974019749)], null)], null);\n} else {\nif(cljs.core.truth_(zprint.zprint.show_user_fn_QMARK_(options__$4,(zprint.zfns.zsexpr.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zsexpr.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zsexpr.call(null,zloc))))){\nreturn new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [zstr,zprint.zprint.zcolor_map(options__$4,new cljs.core.Keyword(null,\"user-fn\",\"user-fn\",223976490)),new cljs.core.Keyword(null,\"element\",\"element\",1974019749)], null)], null);\n} else {\nif(typeof (zprint.zfns.zsexpr.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zsexpr.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zsexpr.call(null,zloc)) === 'number'){\nreturn new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [(cljs.core.truth_(hex_QMARK_)?(zprint.zfns.znumstr.cljs$core$IFn$_invoke$arity$3 ? zprint.zfns.znumstr.cljs$core$IFn$_invoke$arity$3(zloc,hex_QMARK_,shift_seq) : zprint.zfns.znumstr.call(null,zloc,hex_QMARK_,shift_seq)):zstr),zprint.zprint.zcolor_map(options__$4,new cljs.core.Keyword(null,\"number\",\"number\",1570378438)),new cljs.core.Keyword(null,\"element\",\"element\",1974019749)], null)], null);\n} else {\nif(((zprint.zfns.zsexpr.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zsexpr.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zsexpr.call(null,zloc)) instanceof cljs.core.Symbol)){\nreturn new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [zstr,zprint.zprint.zcolor_map(options__$4,new cljs.core.Keyword(null,\"symbol\",\"symbol\",-1038572696)),new cljs.core.Keyword(null,\"element\",\"element\",1974019749)], null)], null);\n} else {\nif(((zprint.zfns.zsexpr.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zsexpr.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zsexpr.call(null,zloc)) == null)){\nreturn new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [zstr,zprint.zprint.zcolor_map(options__$4,new cljs.core.Keyword(null,\"nil\",\"nil\",99600501)),new cljs.core.Keyword(null,\"element\",\"element\",1974019749)], null)], null);\n} else {\nif((zprint.zfns.zsexpr.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zsexpr.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zsexpr.call(null,zloc)) === true){\nreturn new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [zstr,zprint.zprint.zcolor_map(options__$4,new cljs.core.Keyword(null,\"true\",\"true\",-1114210334)),new cljs.core.Keyword(null,\"element\",\"element\",1974019749)], null)], null);\n} else {\nif((zprint.zfns.zsexpr.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zsexpr.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zsexpr.call(null,zloc)) === false){\nreturn new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [zstr,zprint.zprint.zcolor_map(options__$4,new cljs.core.Keyword(null,\"false\",\"false\",1277713805)),new cljs.core.Keyword(null,\"element\",\"element\",1974019749)], null)], null);\n} else {\nif(cljs.core.char_QMARK_((zprint.zfns.zsexpr.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zsexpr.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zsexpr.call(null,zloc)))){\nreturn new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [zstr,zprint.zprint.zcolor_map(options__$4,new cljs.core.Keyword(null,\"char\",\"char\",-641587586)),new cljs.core.Keyword(null,\"element\",\"element\",1974019749)], null)], null);\n} else {\nif(cljs.core.truth_((function (){var or__4212__auto__ = (function (){var c__4243__auto__ = cljs.core.type(/regex/);\nvar x__4244__auto__ = (zprint.zfns.zsexpr.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zsexpr.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zfns.zsexpr.call(null,zloc));\nreturn (x__4244__auto__ instanceof c__4243__auto__);\n})();\nif(cljs.core.truth_(or__4212__auto__)){\nreturn or__4212__auto__;\n} else {\nreturn cljs.core.re_find(/^#\\\".*\\\"$/,zstr);\n}\n})())){\nreturn new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [zstr,zprint.zprint.zcolor_map(options__$4,new cljs.core.Keyword(null,\"regex\",\"regex\",939488856)),new cljs.core.Keyword(null,\"element\",\"element\",1974019749)], null)], null);\n} else {\nreturn new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [zstr,zprint.zprint.zcolor_map(options__$4,new cljs.core.Keyword(null,\"none\",\"none\",1333468478)),new cljs.core.Keyword(null,\"element\",\"element\",1974019749)], null)], null);\n\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n\n}\n}\n}\n}\n}\n}\n}\n\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n});\n/**\n * If this is an inline comment, returns a vector with the amount\n *   of space that was between this and the previous element and the\n *   starting column of this inline comment.  That means that if we\n *   go left, we get something other than whitespace before a newline.\n *   If we get only whitespace before a newline, then this is considered\n *   an inline comment if the comment at the end of the previous line\n *   was an inline comment and we were aligned with that comment.\n *   Assumes zloc is a comment.\n */\nzprint.zprint.inlinecomment_QMARK_ = (function zprint$zprint$inlinecomment_QMARK_(zloc){\nvar nloc = (zprint.zutil.left_STAR_.cljs$core$IFn$_invoke$arity$1 ? zprint.zutil.left_STAR_.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zutil.left_STAR_.call(null,zloc));\nvar spaces = (0);\nvar passed_nl_QMARK_ = false;\nwhile(true){\nvar vec__46095 = (function (){var tnloc = (zprint.zfns.ztag.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.ztag.cljs$core$IFn$_invoke$arity$1(nloc) : zprint.zfns.ztag.call(null,nloc));\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(tnloc,new cljs.core.Keyword(null,\"whitespace\",\"whitespace\",-1340035483))){\nvar nstr = (zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1(nloc) : zprint.zfns.zstring.call(null,nloc));\nvar trim_nstr = clojure.string.trimr(nstr);\nif((((trim_nstr).length) > (0))){\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,\"comma\",\"comma\",1699024745),(spaces + (cljs.core.count(nstr) - ((trim_nstr).length)))], null);\n} else {\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,\"whitespace\",\"whitespace\",-1340035483),spaces], null);\n}\n} else {\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [tnloc,spaces], null);\n}\n})();\nvar tnloc = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__46095,(0),null);\nvar spaces__$1 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__46095,(1),null);\nif((tnloc == null)){\nreturn null;\n} else {\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(tnloc,new cljs.core.Keyword(null,\"newline\",\"newline\",1790071323))){\nvar G__46608 = (zprint.zutil.left_STAR_.cljs$core$IFn$_invoke$arity$1 ? zprint.zutil.left_STAR_.cljs$core$IFn$_invoke$arity$1(nloc) : zprint.zutil.left_STAR_.call(null,nloc));\nvar G__46609 = spaces__$1;\nvar G__46610 = true;\nnloc = G__46608;\nspaces = G__46609;\npassed_nl_QMARK_ = G__46610;\ncontinue;\n} else {\nif(((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(tnloc,new cljs.core.Keyword(null,\"comment\",\"comment\",532206069))) || (cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(tnloc,new cljs.core.Keyword(null,\"comment-inline\",\"comment-inline\",712944405))))){\nif(cljs.core.truth_((zprint.zprint.inlinecomment_QMARK_.cljs$core$IFn$_invoke$arity$1 ? zprint.zprint.inlinecomment_QMARK_.cljs$core$IFn$_invoke$arity$1(nloc) : zprint.zprint.inlinecomment_QMARK_.call(null,nloc)))){\nvar nloc_length_before = zprint.zprint.length_before(nloc);\nvar zloc_length_before = zprint.zprint.length_before(zloc);\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(nloc_length_before,zloc_length_before)){\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [spaces__$1,zloc_length_before], null);\n} else {\nreturn null;\n}\n} else {\nreturn null;\n}\n} else {\nif(cljs.core.not_EQ_.cljs$core$IFn$_invoke$arity$2(tnloc,new cljs.core.Keyword(null,\"whitespace\",\"whitespace\",-1340035483))){\nif(cljs.core.truth_(passed_nl_QMARK_)){\nreturn null;\n} else {\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [spaces__$1,zprint.zprint.length_before(zloc)], null);\n}\n} else {\nvar G__46611 = (zprint.zutil.left_STAR_.cljs$core$IFn$_invoke$arity$1 ? zprint.zutil.left_STAR_.cljs$core$IFn$_invoke$arity$1(nloc) : zprint.zutil.left_STAR_.call(null,nloc));\nvar G__46612 = ((zprint.zutil.length.cljs$core$IFn$_invoke$arity$1 ? zprint.zutil.length.cljs$core$IFn$_invoke$arity$1(nloc) : zprint.zutil.length.call(null,nloc)) + spaces__$1);\nvar G__46613 = passed_nl_QMARK_;\nnloc = G__46611;\nspaces = G__46612;\npassed_nl_QMARK_ = G__46613;\ncontinue;\n\n}\n}\n}\n}\nbreak;\n}\n});\n/**\n * Take a string and an index, and look for the last space prior to the\n *   index. If we wanted to tie ourselves to 1.8, we could use \n *   clojure.string/last-index-of, but we don't.  However, we use similar\n *   conventions, i.e., if no space is found, return nil, and if the index\n *   is a space return that value, and accept any from-index, including one\n *   larger than the length of the string.\n */\nzprint.zprint.last_space = (function zprint$zprint$last_space(s,from_index){\nvar from_index__$1 = (function (){var x__4298__auto__ = (cljs.core.count(s) - (1));\nvar y__4299__auto__ = from_index;\nreturn ((x__4298__auto__ < y__4299__auto__) ? x__4298__auto__ : y__4299__auto__);\n})();\nvar rev_seq = cljs.core.reverse(cljs.core.take.cljs$core$IFn$_invoke$arity$2((from_index__$1 + (1)),s));\nvar seq_after_space = cljs.core.take_while.cljs$core$IFn$_invoke$arity$2((function (p1__46098_SHARP_){\nreturn cljs.core.not_EQ_.cljs$core$IFn$_invoke$arity$2(p1__46098_SHARP_,\" \");\n}),rev_seq);\nvar space_index = (from_index__$1 - cljs.core.count(seq_after_space));\nif((space_index < (0))){\nreturn null;\n} else {\nreturn space_index;\n}\n});\n/**\n * Take a string and an index, and look for the next space *after* the\n *   index. If no space is found, return nil. Accept any from-index, \n *   including one larger than the length of the string.\n */\nzprint.zprint.next_space = (function zprint$zprint$next_space(s,from_index){\nvar from_index__$1 = (from_index + (1));\nif((from_index__$1 < cljs.core.count(s))){\nvar seq_after_space = cljs.core.take_while.cljs$core$IFn$_invoke$arity$2((function (p1__46099_SHARP_){\nreturn cljs.core.not_EQ_.cljs$core$IFn$_invoke$arity$2(p1__46099_SHARP_,\" \");\n}),cljs.core.drop.cljs$core$IFn$_invoke$arity$2(from_index__$1,cljs.core.seq(s)));\nvar space_index = (from_index__$1 + cljs.core.count(seq_after_space));\nif((space_index >= cljs.core.count(s))){\nreturn null;\n} else {\nreturn space_index;\n}\n} else {\nreturn null;\n}\n});\n/**\n * If this is a comment, and it is too long, word wrap it to the right width.\n *   Note that top level comments may well end with a newline, so remove it\n *   and reapply it at the end if that is the case.\n */\nzprint.zprint.wrap_comment = (function zprint$zprint$wrap_comment(width,p__46100,start){\nvar vec__46101 = p__46100;\nvar s = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__46101,(0),null);\nvar color = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__46101,(1),null);\nvar stype = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__46101,(2),null);\nvar element = vec__46101;\nif((!(((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(stype,new cljs.core.Keyword(null,\"comment\",\"comment\",532206069))) || (cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(stype,new cljs.core.Keyword(null,\"comment-inline\",\"comment-inline\",712944405))))))){\nreturn element;\n} else {\nvar comment_width = (width - start);\nvar semi_str = cljs.core.re_find(/;*/,s);\nvar rest_str = cljs.core.subs.cljs$core$IFn$_invoke$arity$2(s,cljs.core.count(semi_str));\nvar space_str = cljs.core.re_find(/ */,rest_str);\nvar rest_str__$1 = cljs.core.subs.cljs$core$IFn$_invoke$arity$2(rest_str,cljs.core.count(space_str));\nvar newline_QMARK_ = cljs.core.re_find(/\\n$/,s);\nvar comment_width__$1 = ((comment_width - cljs.core.count(semi_str)) - cljs.core.count(space_str));\nvar comment_str = rest_str__$1;\nvar out = cljs.core.transient$(cljs.core.PersistentVector.EMPTY);\nwhile(true){\nif(cljs.core.empty_QMARK_(comment_str)){\nif((cljs.core.count(out) === (0))){\nif(cljs.core.truth_(newline_QMARK_)){\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [semi_str,color,stype], null),new cljs.core.PersistentVector(null, 4, 5, cljs.core.PersistentVector.EMPTY_NODE, [\"\\n\",new cljs.core.Keyword(null,\"none\",\"none\",1333468478),new cljs.core.Keyword(null,\"indent\",\"indent\",-148200125),(38)], null)], null);\n} else {\nreturn new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [semi_str,color,stype], null)], null);\n}\n} else {\nreturn cljs.core.persistent_BANG_((cljs.core.truth_(newline_QMARK_)?cljs.core.conj_BANG_.cljs$core$IFn$_invoke$arity$2(out,new cljs.core.PersistentVector(null, 4, 5, cljs.core.PersistentVector.EMPTY_NODE, [\"\\n\",new cljs.core.Keyword(null,\"none\",\"none\",1333468478),new cljs.core.Keyword(null,\"indent\",\"indent\",-148200125),(39)], null)):out));\n}\n} else {\nvar last_space_index = (((((comment_str).length) <= comment_width__$1))?(((comment_str).length) - (1)):(((comment_width__$1 <= (0)))?(function (){var or__4212__auto__ = zprint.zprint.next_space(comment_str,(0));\nif(cljs.core.truth_(or__4212__auto__)){\nreturn or__4212__auto__;\n} else {\nreturn (((comment_str).length) - (1));\n}\n})():(function (){var or__4212__auto__ = zprint.zprint.last_space(comment_str,comment_width__$1);\nif(cljs.core.truth_(or__4212__auto__)){\nreturn or__4212__auto__;\n} else {\nvar or__4212__auto____$1 = zprint.zprint.next_space(comment_str,comment_width__$1);\nif(cljs.core.truth_(or__4212__auto____$1)){\nreturn or__4212__auto____$1;\n} else {\nreturn (((comment_str).length) - (1));\n}\n}\n})()));\nvar next_comment = clojure.string.trimr(cljs.core.subs.cljs$core$IFn$_invoke$arity$3(comment_str,(0),(last_space_index + (1))));\nvar G__46614 = cljs.core.subs.cljs$core$IFn$_invoke$arity$2(comment_str,(last_space_index + (1)));\nvar G__46615 = (((cljs.core.count(out) === (0)))?cljs.core.conj_BANG_.cljs$core$IFn$_invoke$arity$2(out,new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [[cljs.core.str.cljs$core$IFn$_invoke$arity$1(semi_str),cljs.core.str.cljs$core$IFn$_invoke$arity$1(space_str),next_comment].join(''),color,stype], null)):cljs.core.conj_BANG_.cljs$core$IFn$_invoke$arity$2(cljs.core.conj_BANG_.cljs$core$IFn$_invoke$arity$2(out,new cljs.core.PersistentVector(null, 4, 5, cljs.core.PersistentVector.EMPTY_NODE, [[\"\\n\",cljs.core.str.cljs$core$IFn$_invoke$arity$1(zprint.zprint.blanks(start))].join(''),new cljs.core.Keyword(null,\"none\",\"none\",1333468478),new cljs.core.Keyword(null,\"indent\",\"indent\",-148200125),(40)], null)),new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [[cljs.core.str.cljs$core$IFn$_invoke$arity$1(semi_str),cljs.core.str.cljs$core$IFn$_invoke$arity$1(space_str),next_comment].join(''),color,new cljs.core.Keyword(null,\"comment-wrap\",\"comment-wrap\",720664128)], null)));\ncomment_str = G__46614;\nout = G__46615;\ncontinue;\n}\nbreak;\n}\n}\n});\n/**\n * Takes the start of this vector and the vector itself.\n */\nzprint.zprint.loc_vec = (function zprint$zprint$loc_vec(start,p__46104){\nvar vec__46105 = p__46104;\nvar s = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__46105,(0),null);\nvar split = zprint.zprint.split_lf(s);\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(cljs.core.count(split),(1))){\nreturn (start + cljs.core.count(s));\n} else {\nreturn cljs.core.count(cljs.core.last(split));\n}\n});\n/**\n * Take a style-vec and produce a style-loc-vec with the starting column\n *   of each element in the style-vec. Accepts a beginning indent.\n */\nzprint.zprint.style_loc_vec = (function zprint$zprint$style_loc_vec(indent,style_vec){\nreturn cljs.core.butlast(cljs.core.reductions.cljs$core$IFn$_invoke$arity$3(zprint.zprint.loc_vec,indent,style_vec));\n});\n/**\n * Take a transient output vector and a vector and lift any style-vec elements\n *   out of the input vector.\n */\nzprint.zprint.lift_vec = (function zprint$zprint$lift_vec(out_vec,element){\nif(typeof cljs.core.first(element) === 'string'){\nreturn cljs.core.conj.cljs$core$IFn$_invoke$arity$2(out_vec,element);\n} else {\nvar element_vec = element;\nvar out = out_vec;\nwhile(true){\nif(cljs.core.not(element_vec)){\nreturn out;\n} else {\nvar G__46620 = cljs.core.next(element_vec);\nvar G__46621 = cljs.core.conj.cljs$core$IFn$_invoke$arity$2(out,cljs.core.first(element_vec));\nelement_vec = G__46620;\nout = G__46621;\ncontinue;\n}\nbreak;\n}\n}\n});\n/**\n * Take a style-vec [[s color type] [s color type] [[s color type]\n *   [s color type]] [s color type] ...] and lift out the inner vectors.\n */\nzprint.zprint.lift_style_vec = (function zprint$zprint$lift_style_vec(style_vec){\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(zprint.zprint.lift_vec,cljs.core.PersistentVector.EMPTY,style_vec);\n});\n/**\n * Take the final output style-vec, and wrap any comments which run over\n *   the width. Looking for \n */\nzprint.zprint.fzprint_wrap_comments = (function zprint$zprint$fzprint_wrap_comments(p__46108,style_vec){\nvar map__46109 = p__46108;\nvar map__46109__$1 = cljs.core.__destructure_map(map__46109);\nvar options = map__46109__$1;\nvar width = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__46109__$1,new cljs.core.Keyword(null,\"width\",\"width\",-384071477));\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options))){\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),\"fzprint-wrap-comments: indent:\",new cljs.core.Keyword(null,\"indent\",\"indent\",-148200125).cljs$core$IFn$_invoke$arity$1(options)], 0));\n} else {\n}\n\nvar start_col = zprint.zprint.style_loc_vec((function (){var or__4212__auto__ = new cljs.core.Keyword(null,\"indent\",\"indent\",-148200125).cljs$core$IFn$_invoke$arity$1(options);\nif(cljs.core.truth_(or__4212__auto__)){\nreturn or__4212__auto__;\n} else {\nreturn (0);\n}\n})(),style_vec);\nvar _ = (cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options))?cljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),\"fzprint-wrap-comments: style-vec:\",cljs.core.pr_str.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([style_vec], 0))], 0)):null);\nvar ___$1 = (cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options))?cljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),\"fzprint-wrap-comments: start-col:\",start_col], 0)):null);\nvar wrap_style_vec = cljs.core.mapv.cljs$core$IFn$_invoke$arity$3(cljs.core.partial.cljs$core$IFn$_invoke$arity$2(zprint.zprint.wrap_comment,width),style_vec,start_col);\nvar ___$2 = (cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options))?cljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),\"fzprint-wrap-comments: wrap:\",cljs.core.pr_str.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([style_vec], 0))], 0)):null);\nvar out_style_vec = zprint.zprint.lift_style_vec(wrap_style_vec);\nreturn out_style_vec;\n});\n/**\n * Find a the first element of this type working from the end of a \n *   style-vec.  Return the index of the element.\n */\nzprint.zprint.find_element_from_end = (function zprint$zprint$find_element_from_end(element_pred_QMARK_,style_vec){\nvar index = (cljs.core.count(style_vec) - (1));\nwhile(true){\nif((index < (0))){\nreturn null;\n} else {\nvar vec__46110 = cljs.core.nth.cljs$core$IFn$_invoke$arity$2(style_vec,index);\nvar _ = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__46110,(0),null);\nvar ___$1 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__46110,(1),null);\nvar e = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__46110,(2),null);\nif(cljs.core.truth_((element_pred_QMARK_.cljs$core$IFn$_invoke$arity$1 ? element_pred_QMARK_.cljs$core$IFn$_invoke$arity$1(e) : element_pred_QMARK_.call(null,e)))){\nreturn index;\n} else {\nvar G__46625 = (index - (1));\nindex = G__46625;\ncontinue;\n}\n}\nbreak;\n}\n});\n/**\n * Given a style-vec, how big is it in actual characters.  This doesn't\n *   handle newlines.\n */\nzprint.zprint.line_size = (function zprint$zprint$line_size(style_vec){\nreturn cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core._PLUS_,cljs.core.map.cljs$core$IFn$_invoke$arity$2(cljs.core.partial.cljs$core$IFn$_invoke$arity$2(zprint.zprint.loc_vec,(0)),style_vec));\n});\n/**\n * Given a style-vec, whose last element in a comment, find the amount\n *   of space before that comment on the line.\n */\nzprint.zprint.space_before_comment = (function zprint$zprint$space_before_comment(style_vec){\nvar indent_index = zprint.zprint.find_element_from_end((function (p1__46113_SHARP_){\nreturn ((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(p1__46113_SHARP_,new cljs.core.Keyword(null,\"indent\",\"indent\",-148200125))) || (cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(p1__46113_SHARP_,new cljs.core.Keyword(null,\"newline\",\"newline\",1790071323))));\n}),style_vec);\nvar this_line_vec = (cljs.core.truth_(indent_index)?cljs.core.nthnext(style_vec,indent_index):style_vec);\nreturn zprint.zprint.line_size(cljs.core.butlast(this_line_vec));\n});\n/**\n * Try to bring inline comments back onto the line on which they belong.\n */\nzprint.zprint.fzprint_inline_comments = (function zprint$zprint$fzprint_inline_comments(p__46114,style_vec){\nvar map__46115 = p__46114;\nvar map__46115__$1 = cljs.core.__destructure_map(map__46115);\nvar options = map__46115__$1;\nvar width = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__46115__$1,new cljs.core.Keyword(null,\"width\",\"width\",-384071477));\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options))){\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),cljs.core.pr_str.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\"fzprint-inline-comments:\",style_vec], 0))], 0));\n} else {\n}\n\nvar cvec = style_vec;\nvar last_out = new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [\"\",null,null], null);\nvar out = cljs.core.PersistentVector.EMPTY;\nwhile(true){\nif(cljs.core.not(cvec)){\nreturn out;\n} else {\nvar vec__46125 = cljs.core.first(cvec);\nvar s = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__46125,(0),null);\nvar c = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__46125,(1),null);\nvar e = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__46125,(2),null);\nvar element = vec__46125;\nvar vec__46128 = cljs.core.second(cvec);\nvar _ = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__46128,(0),null);\nvar ___$1 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__46128,(1),null);\nvar ne = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__46128,(2),null);\nvar nn = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__46128,(3),null);\nvar next_element = vec__46128;\nvar vec__46131 = last_out;\nvar ___$2 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__46131,(0),null);\nvar ___$3 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__46131,(1),null);\nvar le = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__46131,(2),null);\nvar new_element = ((((((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(e,new cljs.core.Keyword(null,\"indent\",\"indent\",-148200125))) || (cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(e,new cljs.core.Keyword(null,\"newline\",\"newline\",1790071323))))) && (cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(ne,new cljs.core.Keyword(null,\"comment-inline\",\"comment-inline\",712944405)))))?(((!(((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(le,new cljs.core.Keyword(null,\"comment\",\"comment\",532206069))) || (cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(le,new cljs.core.Keyword(null,\"comment-inline\",\"comment-inline\",712944405)))))))?new cljs.core.PersistentVector(null, 4, 5, cljs.core.PersistentVector.EMPTY_NODE, [zprint.zprint.blanks(nn),c,new cljs.core.Keyword(null,\"whitespace\",\"whitespace\",-1340035483),(25)], null):new cljs.core.PersistentVector(null, 4, 5, cljs.core.PersistentVector.EMPTY_NODE, [[\"\\n\",cljs.core.str.cljs$core$IFn$_invoke$arity$1(zprint.zprint.blanks(zprint.zprint.space_before_comment(out)))].join(''),c,new cljs.core.Keyword(null,\"indent\",\"indent\",-148200125),(41)], null)):element\n);\nvar G__46633 = cljs.core.next(cvec);\nvar G__46634 = new_element;\nvar G__46635 = cljs.core.conj.cljs$core$IFn$_invoke$arity$2(out,new_element);\ncvec = G__46633;\nlast_out = G__46634;\nout = G__46635;\ncontinue;\n}\nbreak;\n}\n});\nzprint.zprint.max_aligned_inline_comment_distance = (5);\n/**\n * Given a style-vec, find previously aligned inline comments and\n *   output the as a sequence of vectors of comments. The previously\n *   aligned comments do not have to be consecutive, but they can't\n *   be separated by more than max-aligned-inline-comment-distance.\n *   Each comment itself is a vector: [indent-index inline-comment-index],\n *   yielding a [[[indent-index inline-comment-index] [indent-index\n *   inline-comment-index] ...] ...].  The indexes are into the\n *   style-vec.\n */\nzprint.zprint.find_aligned_inline_comments = (function zprint$zprint$find_aligned_inline_comments(style_vec){\nvar cvec = style_vec;\nvar index = (0);\nvar last_indent = (0);\nvar current_seq = cljs.core.PersistentVector.EMPTY;\nvar current_column = (0);\nvar distance = (0);\nvar out = cljs.core.PersistentVector.EMPTY;\nwhile(true){\nif(cljs.core.not(cvec)){\nvar out__$1 = (((cljs.core.count(current_seq) > (1)))?cljs.core.conj.cljs$core$IFn$_invoke$arity$2(out,current_seq):out);\nreturn out__$1;\n} else {\nvar vec__46137 = cljs.core.first(cvec);\nvar s = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__46137,(0),null);\nvar c = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__46137,(1),null);\nvar e = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__46137,(2),null);\nvar spaces = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__46137,(3),null);\nvar start_column = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__46137,(4),null);\nvar element = vec__46137;\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(e,new cljs.core.Keyword(null,\"comment-inline\",\"comment-inline\",712944405))){\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(start_column,current_column)){\nvar G__46636 = cljs.core.next(cvec);\nvar G__46637 = (index + (1));\nvar G__46638 = null;\nvar G__46639 = (cljs.core.truth_(last_indent)?cljs.core.conj.cljs$core$IFn$_invoke$arity$2(current_seq,new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [last_indent,index], null)):(function (){\nthrow (new Error([\"find-aligned-inline-comments a:\",cljs.core.str.cljs$core$IFn$_invoke$arity$1(index)].join('')));\n\nreturn cljs.core.PersistentVector.EMPTY;\n})()\n);\nvar G__46640 = current_column;\nvar G__46641 = (0);\nvar G__46642 = out;\ncvec = G__46636;\nindex = G__46637;\nlast_indent = G__46638;\ncurrent_seq = G__46639;\ncurrent_column = G__46640;\ndistance = G__46641;\nout = G__46642;\ncontinue;\n} else {\nvar G__46643 = cljs.core.next(cvec);\nvar G__46644 = (index + (1));\nvar G__46645 = null;\nvar G__46646 = (cljs.core.truth_(last_indent)?new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [last_indent,index], null)], null):(function (){\nthrow (new Error([\"find-aligned-inline-comments b:\",cljs.core.str.cljs$core$IFn$_invoke$arity$1(index)].join('')));\n\nreturn cljs.core.PersistentVector.EMPTY;\n})()\n);\nvar G__46647 = start_column;\nvar G__46648 = (0);\nvar G__46649 = (((cljs.core.count(current_seq) > (1)))?cljs.core.conj.cljs$core$IFn$_invoke$arity$2(out,current_seq):out);\ncvec = G__46643;\nindex = G__46644;\nlast_indent = G__46645;\ncurrent_seq = G__46646;\ncurrent_column = G__46647;\ndistance = G__46648;\nout = G__46649;\ncontinue;\n}\n} else {\nif(((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(e,new cljs.core.Keyword(null,\"indent\",\"indent\",-148200125))) || (cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(e,new cljs.core.Keyword(null,\"newline\",\"newline\",1790071323))))){\nif((distance >= zprint.zprint.max_aligned_inline_comment_distance)){\nvar G__46661 = cljs.core.next(cvec);\nvar G__46662 = (index + (1));\nvar G__46663 = index;\nvar G__46664 = cljs.core.PersistentVector.EMPTY;\nvar G__46665 = (0);\nvar G__46666 = (0);\nvar G__46667 = (((cljs.core.count(current_seq) > (1)))?cljs.core.conj.cljs$core$IFn$_invoke$arity$2(out,current_seq):out);\ncvec = G__46661;\nindex = G__46662;\nlast_indent = G__46663;\ncurrent_seq = G__46664;\ncurrent_column = G__46665;\ndistance = G__46666;\nout = G__46667;\ncontinue;\n} else {\nvar G__46675 = cljs.core.next(cvec);\nvar G__46676 = (index + (1));\nvar G__46677 = index;\nvar G__46678 = current_seq;\nvar G__46679 = current_column;\nvar G__46680 = (distance + (1));\nvar G__46681 = out;\ncvec = G__46675;\nindex = G__46676;\nlast_indent = G__46677;\ncurrent_seq = G__46678;\ncurrent_column = G__46679;\ndistance = G__46680;\nout = G__46681;\ncontinue;\n}\n} else {\nvar G__46682 = cljs.core.next(cvec);\nvar G__46683 = (index + (1));\nvar G__46684 = last_indent;\nvar G__46685 = current_seq;\nvar G__46686 = current_column;\nvar G__46687 = distance;\nvar G__46688 = out;\ncvec = G__46682;\nindex = G__46683;\nlast_indent = G__46684;\ncurrent_seq = G__46685;\ncurrent_column = G__46686;\ndistance = G__46687;\nout = G__46688;\ncontinue;\n\n}\n}\n}\nbreak;\n}\n});\n/**\n * Given a style-vec, find consecutive inline comments and output\n *   the as a sequence of vectors of comments.  Each comment itself\n *   is a vector: [indent-index inline-comment-index], yielding a\n *   [[[indent-index inline-comment-index] [indent-index inline-comment-index]\n *   ...] ...]\n */\nzprint.zprint.find_consecutive_inline_comments = (function zprint$zprint$find_consecutive_inline_comments(style_vec){\nvar cvec = style_vec;\nvar index = (0);\nvar last_indent = (0);\nvar current_seq = cljs.core.PersistentVector.EMPTY;\nvar out = cljs.core.PersistentVector.EMPTY;\nwhile(true){\nif(cljs.core.not(cvec)){\nreturn out;\n} else {\nvar vec__46143 = cljs.core.first(cvec);\nvar s = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__46143,(0),null);\nvar c = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__46143,(1),null);\nvar e = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__46143,(2),null);\nvar element = vec__46143;\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(e,new cljs.core.Keyword(null,\"comment-inline\",\"comment-inline\",712944405))){\nvar G__46689 = cljs.core.next(cvec);\nvar G__46690 = (index + (1));\nvar G__46691 = null;\nvar G__46692 = (cljs.core.truth_(last_indent)?cljs.core.conj.cljs$core$IFn$_invoke$arity$2(current_seq,new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [last_indent,index], null)):(function (){\nthrow (new Error([\"find-consecutive-inline-comments:\",cljs.core.str.cljs$core$IFn$_invoke$arity$1(index)].join('')));\n\nreturn cljs.core.PersistentVector.EMPTY;\n})()\n);\nvar G__46693 = out;\ncvec = G__46689;\nindex = G__46690;\nlast_indent = G__46691;\ncurrent_seq = G__46692;\nout = G__46693;\ncontinue;\n} else {\nif(((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(e,new cljs.core.Keyword(null,\"indent\",\"indent\",-148200125))) || (cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(e,new cljs.core.Keyword(null,\"newline\",\"newline\",1790071323))))){\nvar G__46694 = cljs.core.next(cvec);\nvar G__46695 = (index + (1));\nvar G__46696 = index;\nvar G__46697 = (cljs.core.truth_(last_indent)?cljs.core.PersistentVector.EMPTY:current_seq);\nvar G__46698 = (cljs.core.truth_(last_indent)?(((cljs.core.count(current_seq) > (1)))?cljs.core.conj.cljs$core$IFn$_invoke$arity$2(out,current_seq):out):out);\ncvec = G__46694;\nindex = G__46695;\nlast_indent = G__46696;\ncurrent_seq = G__46697;\nout = G__46698;\ncontinue;\n} else {\nvar G__46699 = cljs.core.next(cvec);\nvar G__46700 = (index + (1));\nvar G__46701 = last_indent;\nvar G__46702 = current_seq;\nvar G__46703 = out;\ncvec = G__46699;\nindex = G__46700;\nlast_indent = G__46701;\ncurrent_seq = G__46702;\nout = G__46703;\ncontinue;\n\n}\n}\n}\nbreak;\n}\n});\n/**\n * Takes a single vector of [indent-index comment-index] and will show the\n *   column on the line in which the comment starts.\n */\nzprint.zprint.comment_column = (function zprint$zprint$comment_column(p__46146,style_vec){\nvar vec__46147 = p__46146;\nvar indent_index = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__46147,(0),null);\nvar comment_index = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__46147,(1),null);\nif(cljs.core.vector_QMARK_(style_vec)){\n} else {\nthrow (new Error([\"comment-column: style-vec not a vector!! \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(style_vec)].join('')));\n}\n\nvar index = indent_index;\nvar column = (0);\nwhile(true){\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(index,comment_index)){\nreturn column;\n} else {\nvar G__46710 = (index + (1));\nvar G__46711 = zprint.zprint.loc_vec(column,cljs.core.nth.cljs$core$IFn$_invoke$arity$2(style_vec,index));\nindex = G__46710;\ncolumn = G__46711;\ncontinue;\n}\nbreak;\n}\n});\n/**\n * Take a single inline comment vector:\n *   [indent-index inline-comment-index] \n *   and replace it with [inline-comment-index start-column spaces-before].\n */\nzprint.zprint.comment_vec_column = (function zprint$zprint$comment_vec_column(style_vec,p__46150){\nvar vec__46151 = p__46150;\nvar indent_index = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__46151,(0),null);\nvar inline_comment_index = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__46151,(1),null);\nvar comment_vec = vec__46151;\nvar start_column = zprint.zprint.comment_column(comment_vec,style_vec);\nvar spaces_before = zprint.zprint.loc_vec((0),cljs.core.nth.cljs$core$IFn$_invoke$arity$2(style_vec,(inline_comment_index - (1))));\nreturn new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [inline_comment_index,start_column,spaces_before], null);\n});\n/**\n * Take a single vector of inline comments\n *   [[indent-index inline-comment-index] [indent-index inline-comment-index]\n * ...] and replace it with [[inline-comment-index start-column spaces-before]\n * [inline-comment-index start-column spaces-before] ...]\n */\nzprint.zprint.comment_vec_seq_column = (function zprint$zprint$comment_vec_seq_column(style_vec,comment_vec_seq){\nreturn cljs.core.map.cljs$core$IFn$_invoke$arity$2(cljs.core.partial.cljs$core$IFn$_invoke$arity$2(zprint.zprint.comment_vec_column,style_vec),comment_vec_seq);\n});\n/**\n * Take a seq of all of the comments as produced by \n *   find-consecutive-inline-comments, and turn it into:\n *   [[[inline-comment-index start-column spaces-before] [inline-comment-index\n *   start-column spaces-before]\n *   ...] ...]\n */\nzprint.zprint.comment_vec_all_column = (function zprint$zprint$comment_vec_all_column(style_vec,comment_vec_all){\nreturn cljs.core.map.cljs$core$IFn$_invoke$arity$2(cljs.core.partial.cljs$core$IFn$_invoke$arity$2(zprint.zprint.comment_vec_seq_column,style_vec),comment_vec_all);\n});\n/**\n * Given a set of inline comments:\n *   [[inline-comment-index start-column spaces-before]\n * [inline-comment-index start-column spaces-before] ...], determine\n * the minimum column at which they could be aligned.\n */\nzprint.zprint.minimum_column = (function zprint$zprint$minimum_column(comment_vec){\nvar minimum_vec = cljs.core.map.cljs$core$IFn$_invoke$arity$2((function (p1__46154_SHARP_){\nreturn ((cljs.core.second(p1__46154_SHARP_) - cljs.core.nth.cljs$core$IFn$_invoke$arity$2(p1__46154_SHARP_,(2))) + (1));\n}),comment_vec);\nvar minimum_col = cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core.max,minimum_vec);\nreturn minimum_col;\n});\n/**\n * Given a new start-column, and a vector \n *   [[inline-comment-index start-column spaces-before]\n *   and a style-vec, return a new style-vec with the inline-comment starting\n *   at a new column.\n */\nzprint.zprint.change_start_column = (function zprint$zprint$change_start_column(new_start_column,style_vec,p__46155){\nvar vec__46156 = p__46155;\nvar inline_comment_index = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__46156,(0),null);\nvar start_column = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__46156,(1),null);\nvar spaces_before = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__46156,(2),null);\nvar comment_vec = vec__46156;\nvar delta_spaces = (new_start_column - start_column);\nvar new_spaces = (spaces_before + delta_spaces);\nvar previous_element_index = (inline_comment_index - (1));\nvar vec__46159 = cljs.core.nth.cljs$core$IFn$_invoke$arity$2(style_vec,previous_element_index);\nvar s = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__46159,(0),null);\nvar c = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__46159,(1),null);\nvar e = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__46159,(2),null);\nvar previous_element = vec__46159;\nvar new_previous_element = ((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(e,new cljs.core.Keyword(null,\"indent\",\"indent\",-148200125)))?new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [[\"\\n\",cljs.core.str.cljs$core$IFn$_invoke$arity$1(zprint.zprint.blanks(new_spaces))].join(''),c,e], null):((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(e,new cljs.core.Keyword(null,\"whitespace\",\"whitespace\",-1340035483)))?new cljs.core.PersistentVector(null, 4, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.str.cljs$core$IFn$_invoke$arity$1(zprint.zprint.blanks(new_spaces)),c,e,(26)], null):(function(){throw (new Error([\"change-start-column: comment preceded by neither\",\" an :indent nor :whitespace!\",cljs.core.str.cljs$core$IFn$_invoke$arity$1(e)].join('')))})()\n));\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(style_vec,previous_element_index,new_previous_element);\n});\n/**\n * Given one set of inline comments: \n *   [[inline-comment-index start-column spaces-before]\n * [inline-comment-index start-column spaces-before] ...], align them \n * as best as possible, and return the modified style-vec.\n */\nzprint.zprint.align_comment_vec = (function zprint$zprint$align_comment_vec(style_vec,comment_vec){\nvar minimum_col = zprint.zprint.minimum_column(comment_vec);\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(cljs.core.partial.cljs$core$IFn$_invoke$arity$2(zprint.zprint.change_start_column,minimum_col),style_vec,comment_vec);\n});\n/**\n * Given the current style-vec, align all consecutive inline comments.\n */\nzprint.zprint.fzprint_align_inline_comments = (function zprint$zprint$fzprint_align_inline_comments(options,style_vec){\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options))){\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),cljs.core.pr_str.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\"fzprint-align-inline-comments: style-vec:\",style_vec], 0))], 0));\n} else {\n}\n\nvar style = new cljs.core.Keyword(null,\"inline-align-style\",\"inline-align-style\",1548722575).cljs$core$IFn$_invoke$arity$1(new cljs.core.Keyword(null,\"comment\",\"comment\",532206069).cljs$core$IFn$_invoke$arity$1(options));\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(style,new cljs.core.Keyword(null,\"none\",\"none\",1333468478))){\nreturn style_vec;\n} else {\nvar comment_vec = ((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(style,new cljs.core.Keyword(null,\"aligned\",\"aligned\",-1015148916)))?zprint.zprint.find_aligned_inline_comments(style_vec):((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(style,new cljs.core.Keyword(null,\"consecutive\",\"consecutive\",-1628234596)))?zprint.zprint.find_consecutive_inline_comments(style_vec):null));\nvar comment_vec_column = zprint.zprint.comment_vec_all_column(style_vec,comment_vec);\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(zprint.zprint.align_comment_vec,style_vec,comment_vec_column);\n}\n});\n/**\n * The pretty print part of fzprint.\n */\nzprint.zprint.fzprint = (function zprint$zprint$fzprint(options,indent,zloc){\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options))){\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),\"fzprint: indent:\",indent,\"(:indent options)\",new cljs.core.Keyword(null,\"indent\",\"indent\",-148200125).cljs$core$IFn$_invoke$arity$1(options)], 0));\n} else {\n}\n\nvar zloc__$1 = ((cljs.core.not((function (){var and__4210__auto__ = cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(new cljs.core.Keyword(null,\"ztype\",\"ztype\",-562179020).cljs$core$IFn$_invoke$arity$1(options),new cljs.core.Keyword(null,\"zipper\",\"zipper\",1500694438));\nif(and__4210__auto__){\nreturn new cljs.core.Keyword(null,\"value\",\"value\",305978217).cljs$core$IFn$_invoke$arity$1(new cljs.core.Keyword(null,\"spec\",\"spec\",347520401).cljs$core$IFn$_invoke$arity$1(options));\n} else {\nreturn and__4210__auto__;\n}\n})()))?zloc:zprint.zutil.add_spec_to_docstring(zloc,new cljs.core.Keyword(null,\"value\",\"value\",305978217).cljs$core$IFn$_invoke$arity$1(new cljs.core.Keyword(null,\"spec\",\"spec\",347520401).cljs$core$IFn$_invoke$arity$1(options))));\nvar style_vec = zprint.zprint.fzprint_STAR_(cljs.core.assoc.cljs$core$IFn$_invoke$arity$variadic(options,new cljs.core.Keyword(null,\"depth\",\"depth\",1768663640),(0),cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"map-depth\",\"map-depth\",-191378641),(0)], 0)),indent,zloc__$1);\nreturn style_vec;\n});\n/**\n * Count lines in a string.\n */\nzprint.zprint.line_count = (function zprint$zprint$line_count(s){\nreturn (cljs.core.count(cljs.core.re_seq(/\\n/,s)) + (1));\n});\n/**\n * Return a vector the lengths of lines.\n */\nzprint.zprint.line_widths = (function zprint$zprint$line_widths(s){\nreturn cljs.core.map.cljs$core$IFn$_invoke$arity$2(cljs.core.count,clojure.string.split.cljs$core$IFn$_invoke$arity$2(s,/\\n/));\n});\n/**\n * Split a string into lines, and figure the max width.\n */\nzprint.zprint.max_width = (function zprint$zprint$max_width(s){\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$2(cljs.core.max,zprint.zprint.line_widths(s));\n});\n/**\n * Takes a string, and expands tabs inside of the string based\n *   on a tab-size argument.\n */\nzprint.zprint.expand_tabs = (function zprint$zprint$expand_tabs(var_args){\nvar G__46163 = arguments.length;\nswitch (G__46163) {\ncase 2:\nreturn zprint.zprint.expand_tabs.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 1:\nreturn zprint.zprint.expand_tabs.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\n(zprint.zprint.expand_tabs.cljs$core$IFn$_invoke$arity$2 = (function (tab_size,s){\nreturn cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core.str,(function (){var char_seq = cljs.core.seq(s);\nvar cur_len = cljs.core.long$((0));\nvar out = cljs.core.transient$(cljs.core.PersistentVector.EMPTY);\nwhile(true){\nif(cljs.core.empty_QMARK_(char_seq)){\nreturn cljs.core.persistent_BANG_(out);\n} else {\nvar this_char = cljs.core.first(char_seq);\nvar tab_expansion = ((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(this_char,\"\\t\"))?(tab_size - cljs.core.mod(cur_len,tab_size)):null);\nvar G__46721 = cljs.core.rest(char_seq);\nvar G__46722 = ((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(this_char,\"\\n\"))?(0):(cur_len + cljs.core.long$((function (){var or__4212__auto__ = tab_expansion;\nif(cljs.core.truth_(or__4212__auto__)){\nreturn or__4212__auto__;\n} else {\nreturn (1);\n}\n})())));\nvar G__46723 = (cljs.core.truth_(tab_expansion)?cljs.core.apply.cljs$core$IFn$_invoke$arity$3(zprint.zprint.conj_it_BANG_,out,cljs.core.seq(zprint.zprint.blanks(tab_expansion))):cljs.core.conj_BANG_.cljs$core$IFn$_invoke$arity$2(out,this_char));\nchar_seq = G__46721;\ncur_len = G__46722;\nout = G__46723;\ncontinue;\n}\nbreak;\n}\n})());\n}));\n\n(zprint.zprint.expand_tabs.cljs$core$IFn$_invoke$arity$1 = (function (s){\nreturn zprint.zprint.expand_tabs.cljs$core$IFn$_invoke$arity$2((8),s);\n}));\n\n(zprint.zprint.expand_tabs.cljs$lang$maxFixedArity = 2);\n\n\n/**\n* @constructor\n * @implements {cljs.core.IRecord}\n * @implements {cljs.core.IKVReduce}\n * @implements {cljs.core.IEquiv}\n * @implements {cljs.core.IHash}\n * @implements {cljs.core.ICollection}\n * @implements {cljs.core.ICounted}\n * @implements {cljs.core.ISeqable}\n * @implements {cljs.core.IMeta}\n * @implements {cljs.core.ICloneable}\n * @implements {cljs.core.IPrintWithWriter}\n * @implements {cljs.core.IIterable}\n * @implements {cljs.core.IWithMeta}\n * @implements {cljs.core.IAssociative}\n * @implements {cljs.core.IMap}\n * @implements {cljs.core.ILookup}\n*/\nzprint.zprint.r = (function (left,right,__meta,__extmap,__hash){\nthis.left = left;\nthis.right = right;\nthis.__meta = __meta;\nthis.__extmap = __extmap;\nthis.__hash = __hash;\nthis.cljs$lang$protocol_mask$partition0$ = 2230716170;\nthis.cljs$lang$protocol_mask$partition1$ = 139264;\n});\n(zprint.zprint.r.prototype.cljs$core$ILookup$_lookup$arity$2 = (function (this__4461__auto__,k__4462__auto__){\nvar self__ = this;\nvar this__4461__auto____$1 = this;\nreturn this__4461__auto____$1.cljs$core$ILookup$_lookup$arity$3(null,k__4462__auto__,null);\n}));\n\n(zprint.zprint.r.prototype.cljs$core$ILookup$_lookup$arity$3 = (function (this__4463__auto__,k46165,else__4464__auto__){\nvar self__ = this;\nvar this__4463__auto____$1 = this;\nvar G__46169 = k46165;\nvar G__46169__$1 = (((G__46169 instanceof cljs.core.Keyword))?G__46169.fqn:null);\nswitch (G__46169__$1) {\ncase \"left\":\nreturn self__.left;\n\nbreak;\ncase \"right\":\nreturn self__.right;\n\nbreak;\ndefault:\nreturn cljs.core.get.cljs$core$IFn$_invoke$arity$3(self__.__extmap,k46165,else__4464__auto__);\n\n}\n}));\n\n(zprint.zprint.r.prototype.cljs$core$IKVReduce$_kv_reduce$arity$3 = (function (this__4481__auto__,f__4482__auto__,init__4483__auto__){\nvar self__ = this;\nvar this__4481__auto____$1 = this;\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3((function (ret__4484__auto__,p__46170){\nvar vec__46171 = p__46170;\nvar k__4485__auto__ = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__46171,(0),null);\nvar v__4486__auto__ = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__46171,(1),null);\nreturn (f__4482__auto__.cljs$core$IFn$_invoke$arity$3 ? f__4482__auto__.cljs$core$IFn$_invoke$arity$3(ret__4484__auto__,k__4485__auto__,v__4486__auto__) : f__4482__auto__.call(null,ret__4484__auto__,k__4485__auto__,v__4486__auto__));\n}),init__4483__auto__,this__4481__auto____$1);\n}));\n\n(zprint.zprint.r.prototype.cljs$core$IPrintWithWriter$_pr_writer$arity$3 = (function (this__4476__auto__,writer__4477__auto__,opts__4478__auto__){\nvar self__ = this;\nvar this__4476__auto____$1 = this;\nvar pr_pair__4479__auto__ = (function (keyval__4480__auto__){\nreturn cljs.core.pr_sequential_writer(writer__4477__auto__,cljs.core.pr_writer,\"\",\" \",\"\",opts__4478__auto__,keyval__4480__auto__);\n});\nreturn cljs.core.pr_sequential_writer(writer__4477__auto__,pr_pair__4479__auto__,\"#zprint.zprint.r{\",\", \",\"}\",opts__4478__auto__,cljs.core.concat.cljs$core$IFn$_invoke$arity$2(new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [(new cljs.core.PersistentVector(null,2,(5),cljs.core.PersistentVector.EMPTY_NODE,[new cljs.core.Keyword(null,\"left\",\"left\",-399115937),self__.left],null)),(new cljs.core.PersistentVector(null,2,(5),cljs.core.PersistentVector.EMPTY_NODE,[new cljs.core.Keyword(null,\"right\",\"right\",-452581833),self__.right],null))], null),self__.__extmap));\n}));\n\n(zprint.zprint.r.prototype.cljs$core$IIterable$_iterator$arity$1 = (function (G__46164){\nvar self__ = this;\nvar G__46164__$1 = this;\nreturn (new cljs.core.RecordIter((0),G__46164__$1,2,new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,\"left\",\"left\",-399115937),new cljs.core.Keyword(null,\"right\",\"right\",-452581833)], null),(cljs.core.truth_(self__.__extmap)?cljs.core._iterator(self__.__extmap):cljs.core.nil_iter())));\n}));\n\n(zprint.zprint.r.prototype.cljs$core$IMeta$_meta$arity$1 = (function (this__4459__auto__){\nvar self__ = this;\nvar this__4459__auto____$1 = this;\nreturn self__.__meta;\n}));\n\n(zprint.zprint.r.prototype.cljs$core$ICloneable$_clone$arity$1 = (function (this__4456__auto__){\nvar self__ = this;\nvar this__4456__auto____$1 = this;\nreturn (new zprint.zprint.r(self__.left,self__.right,self__.__meta,self__.__extmap,self__.__hash));\n}));\n\n(zprint.zprint.r.prototype.cljs$core$ICounted$_count$arity$1 = (function (this__4465__auto__){\nvar self__ = this;\nvar this__4465__auto____$1 = this;\nreturn (2 + cljs.core.count(self__.__extmap));\n}));\n\n(zprint.zprint.r.prototype.cljs$core$IHash$_hash$arity$1 = (function (this__4457__auto__){\nvar self__ = this;\nvar this__4457__auto____$1 = this;\nvar h__4319__auto__ = self__.__hash;\nif((!((h__4319__auto__ == null)))){\nreturn h__4319__auto__;\n} else {\nvar h__4319__auto____$1 = (function (coll__4458__auto__){\nreturn (-1384233907 ^ cljs.core.hash_unordered_coll(coll__4458__auto__));\n})(this__4457__auto____$1);\n(self__.__hash = h__4319__auto____$1);\n\nreturn h__4319__auto____$1;\n}\n}));\n\n(zprint.zprint.r.prototype.cljs$core$IEquiv$_equiv$arity$2 = (function (this46166,other46167){\nvar self__ = this;\nvar this46166__$1 = this;\nreturn (((!((other46167 == null)))) && ((((this46166__$1.constructor === other46167.constructor)) && (((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(this46166__$1.left,other46167.left)) && (((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(this46166__$1.right,other46167.right)) && (cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(this46166__$1.__extmap,other46167.__extmap)))))))));\n}));\n\n(zprint.zprint.r.prototype.cljs$core$IMap$_dissoc$arity$2 = (function (this__4471__auto__,k__4472__auto__){\nvar self__ = this;\nvar this__4471__auto____$1 = this;\nif(cljs.core.contains_QMARK_(new cljs.core.PersistentHashSet(null, new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(null,\"right\",\"right\",-452581833),null,new cljs.core.Keyword(null,\"left\",\"left\",-399115937),null], null), null),k__4472__auto__)){\nreturn cljs.core.dissoc.cljs$core$IFn$_invoke$arity$2(cljs.core._with_meta(cljs.core.into.cljs$core$IFn$_invoke$arity$2(cljs.core.PersistentArrayMap.EMPTY,this__4471__auto____$1),self__.__meta),k__4472__auto__);\n} else {\nreturn (new zprint.zprint.r(self__.left,self__.right,self__.__meta,cljs.core.not_empty(cljs.core.dissoc.cljs$core$IFn$_invoke$arity$2(self__.__extmap,k__4472__auto__)),null));\n}\n}));\n\n(zprint.zprint.r.prototype.cljs$core$IAssociative$_contains_key_QMARK_$arity$2 = (function (this__4468__auto__,k46165){\nvar self__ = this;\nvar this__4468__auto____$1 = this;\nvar G__46174 = k46165;\nvar G__46174__$1 = (((G__46174 instanceof cljs.core.Keyword))?G__46174.fqn:null);\nswitch (G__46174__$1) {\ncase \"left\":\ncase \"right\":\nreturn true;\n\nbreak;\ndefault:\nreturn cljs.core.contains_QMARK_(self__.__extmap,k46165);\n\n}\n}));\n\n(zprint.zprint.r.prototype.cljs$core$IAssociative$_assoc$arity$3 = (function (this__4469__auto__,k__4470__auto__,G__46164){\nvar self__ = this;\nvar this__4469__auto____$1 = this;\nvar pred__46175 = cljs.core.keyword_identical_QMARK_;\nvar expr__46176 = k__4470__auto__;\nif(cljs.core.truth_((pred__46175.cljs$core$IFn$_invoke$arity$2 ? pred__46175.cljs$core$IFn$_invoke$arity$2(new cljs.core.Keyword(null,\"left\",\"left\",-399115937),expr__46176) : pred__46175.call(null,new cljs.core.Keyword(null,\"left\",\"left\",-399115937),expr__46176)))){\nreturn (new zprint.zprint.r(G__46164,self__.right,self__.__meta,self__.__extmap,null));\n} else {\nif(cljs.core.truth_((pred__46175.cljs$core$IFn$_invoke$arity$2 ? pred__46175.cljs$core$IFn$_invoke$arity$2(new cljs.core.Keyword(null,\"right\",\"right\",-452581833),expr__46176) : pred__46175.call(null,new cljs.core.Keyword(null,\"right\",\"right\",-452581833),expr__46176)))){\nreturn (new zprint.zprint.r(self__.left,G__46164,self__.__meta,self__.__extmap,null));\n} else {\nreturn (new zprint.zprint.r(self__.left,self__.right,self__.__meta,cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(self__.__extmap,k__4470__auto__,G__46164),null));\n}\n}\n}));\n\n(zprint.zprint.r.prototype.cljs$core$ISeqable$_seq$arity$1 = (function (this__4474__auto__){\nvar self__ = this;\nvar this__4474__auto____$1 = this;\nreturn cljs.core.seq(cljs.core.concat.cljs$core$IFn$_invoke$arity$2(new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [(new cljs.core.MapEntry(new cljs.core.Keyword(null,\"left\",\"left\",-399115937),self__.left,null)),(new cljs.core.MapEntry(new cljs.core.Keyword(null,\"right\",\"right\",-452581833),self__.right,null))], null),self__.__extmap));\n}));\n\n(zprint.zprint.r.prototype.cljs$core$IWithMeta$_with_meta$arity$2 = (function (this__4460__auto__,G__46164){\nvar self__ = this;\nvar this__4460__auto____$1 = this;\nreturn (new zprint.zprint.r(self__.left,self__.right,G__46164,self__.__extmap,self__.__hash));\n}));\n\n(zprint.zprint.r.prototype.cljs$core$ICollection$_conj$arity$2 = (function (this__4466__auto__,entry__4467__auto__){\nvar self__ = this;\nvar this__4466__auto____$1 = this;\nif(cljs.core.vector_QMARK_(entry__4467__auto__)){\nreturn this__4466__auto____$1.cljs$core$IAssociative$_assoc$arity$3(null,cljs.core._nth(entry__4467__auto__,(0)),cljs.core._nth(entry__4467__auto__,(1)));\n} else {\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(cljs.core._conj,this__4466__auto____$1,entry__4467__auto__);\n}\n}));\n\n(zprint.zprint.r.getBasis = (function (){\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\"left\",\"left\",1241415590,null),new cljs.core.Symbol(null,\"right\",\"right\",1187949694,null)], null);\n}));\n\n(zprint.zprint.r.cljs$lang$type = true);\n\n(zprint.zprint.r.cljs$lang$ctorPrSeq = (function (this__4505__auto__){\nreturn (new cljs.core.List(null,\"zprint.zprint/r\",null,(1),null));\n}));\n\n(zprint.zprint.r.cljs$lang$ctorPrWriter = (function (this__4505__auto__,writer__4506__auto__){\nreturn cljs.core._write(writer__4506__auto__,\"zprint.zprint/r\");\n}));\n\n/**\n * Positional factory function for zprint.zprint/r.\n */\nzprint.zprint.__GT_r = (function zprint$zprint$__GT_r(left,right){\nreturn (new zprint.zprint.r(left,right,null,null,null));\n});\n\n/**\n * Factory function for zprint.zprint/r, taking a map of keywords to field values.\n */\nzprint.zprint.map__GT_r = (function zprint$zprint$map__GT_r(G__46168){\nvar extmap__4501__auto__ = (function (){var G__46178 = cljs.core.dissoc.cljs$core$IFn$_invoke$arity$variadic(G__46168,new cljs.core.Keyword(null,\"left\",\"left\",-399115937),cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"right\",\"right\",-452581833)], 0));\nif(cljs.core.record_QMARK_(G__46168)){\nreturn cljs.core.into.cljs$core$IFn$_invoke$arity$2(cljs.core.PersistentArrayMap.EMPTY,G__46178);\n} else {\nreturn G__46178;\n}\n})();\nreturn (new zprint.zprint.r(new cljs.core.Keyword(null,\"left\",\"left\",-399115937).cljs$core$IFn$_invoke$arity$1(G__46168),new cljs.core.Keyword(null,\"right\",\"right\",-452581833).cljs$core$IFn$_invoke$arity$1(G__46168),null,cljs.core.not_empty(extmap__4501__auto__),null));\n});\n\nzprint.zprint.make_record = (function zprint$zprint$make_record(left,right){\nreturn (new zprint.zprint.r(left,right,null,null,null));\n});\n","~:ns-info",["^ ","~:rename-macros",null,"~:renames",["^ "],"~:meta",["^ ","~:file","zprint/zprint.cljc","~:line",1,"~:column",14,"~:end-line",1,"~:end-column",27,"~:no-doc",true],"~:ns-aliases",["^ ","~$cljs.loader","~$shadow.loader","~$react","~$module$node_modules$react$index","~$react-dom","~$module$node_modules$react_dom$index","~$highlight.js","~$module$node_modules$highlight_DOT_js$lib$index","~$clojure.pprint","~$cljs.pprint","~$clojure.spec.alpha","~$cljs.spec.alpha","~$clojure.repl","~$cljs.repl"],"~:use-macros",["^ ","~$dbg","~$zprint.macros","~$dbg-pr","^M","~$dbg-form","^M","~$dbg-print","^M","~$zfuture","^M"],"~:excludes",["~#set",[]],"~:name","~$zprint.zprint","~:op","~:ns","~:imports",null,"~:requires",["^ ","~$rewrite-clj.parser","^Z","~$p","^Z","~$zprint.config","^[","~$rewrite-clj.zip","^10","~$cljs.core","^11","~$zprint.finish","^12","~$goog","^13","~$zprint.zfns","^14","~$zprint.ansi","^15","~$s","~$clojure.string","~$z","^10","^16","^16","~$zprint.zutil","^17"],"~:seen",["^S",["~:require","~:require-macros"]],"~:uses",["^ ","~$zcount-zloc-seq-nc-nws","^14","~$zreader-cond-w-symbol?","^14","~$zarray-to-shift-seq","^14","~$zlist?","^14","~$zvector?","^14","~$zarray?","^14","~$zmap-w-nl-comma","^14","~$zcomment?","^14","~$znamespacedmap?","^14","~$zanonfn?","^14","~$zfirst-no-comment","^14","~$zkeyword?","^14","~$zseqnws-w-nl","^14","~$znextnws-w-nl","^14","~$zdelay?","^14","~$zns?","^14","~$zconstant?","^14","~$znewline?","^14","~$ztake-append","^14","~$merge-deep","^[","~$zmap?","^14","~$zatom?","^14","~$zstring","^14","~$validate-options","^[","~$zlast","^14","~$zdotdotdot","^14","~$znthnext","^14","~$znil?","^14","~$zset?","^14","~$color-str","^15","~$zsymbol?","^14","~$zfn-obj?","^14","~$zreader-cond-w-coll?","^14","~$zmeta?","^14","~$add-spec-to-docstring","^17","~$zfocus","^14","~$zfirst","^14","~$zagent?","^14","~$zbyte-array?","^14","~$zcount","^14","~$zexpandarray","^14","~$zstart","^14","~$zwhitespace?","^14","~$znextnws","^14","~$zreader-macro?","^14","~$zcoll?","^14","~$zseqnws-w-bl","^14","~$zmap-w-bl","^14","~$zfuture?","^14","~$zpromise?","^14","~$zderef","^14","~$zlift-ns","^14","~$zsecond","^14","~$zsexpr","^14","~$zrecord?","^14","~$zobj-to-vec","^14","~$zfocus-style","^14","~$zwhitespaceorcomment?","^14","~$zmap-all","^14","~$zmap","^14","~$ztag","^14","~$zseqnws","^14","~$zmap-w-nl","^14","~$newline-vec","^12","~$zfind-path","^14","~$zuneval?","^14","~$zfind","^14","~$znumstr","^14"],"^1:",["^ ","^M","^M","^11","^11"],"~:form",["~#list",["~$ns","^U",["^1:",["^M","~:refer",["^L","^N","^O","^P","^Q"]]],["^2U",["^19",["^16","~:as","~$s"],["^12","^2W",["^2O"]],["^14","^2W",["^1R","^2S","^26","^1C","^2E","^2M","^1H","^2H","^29","^24","^1F","^2D","^1V","^27","^2K","^1E","^1[","^23","^2P","^2:","^1?","^1<","^1@","^1P","^1X","^2=","^2Q","^21","^2L","^1T","^1A","^1Q","^2B","^2F","^1K","^2G","^28","^1M","^2I","^2J","^2A","^2@","^1J","^1G","^1L","^25","^2<","^1>","^1U","^1Z","^1W","^1=","^20","^2C","^2R","^2N","^1B","^1N","^1I","^2;","^1D","^2?","^2>"]],["^15","^2W",["^1Y"]],["^[","^2W",["^1S","^1O"]],["^17","^2W",["^22"]],["^Z","^2X","~$p"],["^10","^2X","~$z"]]]]],"~:flags",["^ ","^1:",["^S",[]],"^19",["^S",[]]],"~:js-deps",["^ "],"~:deps",["^13","^11","^16","^12","^14","^15","^[","^17","^Z","^10"]],"^W","^U","~:resource-id",["~:shadow.build.classpath/resource","zprint/zprint.cljc"],"~:compiled-at",1638904288255,"~:resource-name","zprint/zprint.cljc","~:warnings",[],"~:source","(ns ^:no-doc zprint.zprint\n  #?@(:cljs [[:require-macros\n              [zprint.macros :refer [dbg dbg-pr dbg-form dbg-print zfuture]]]])\n  (:require\n    #?@(:clj [[zprint.macros :refer [dbg-pr dbg dbg-form dbg-print zfuture]]])\n    [clojure.string :as s]\n    [zprint.finish :refer [newline-vec]]\n    [zprint.zfns :refer\n     [zstring znumstr zbyte-array? zcomment? zsexpr zseqnws zseqnws-w-nl\n      zfocus-style zstart zfirst zfirst-no-comment zsecond znthnext zcount zmap\n      zanonfn? zfn-obj? zfocus zfind-path zwhitespace? zlist?\n      zcount-zloc-seq-nc-nws zvector? zmap? zset? zcoll? zuneval? zmeta? ztag\n      zlast zarray? zatom? zderef zrecord? zns? zobj-to-vec zexpandarray\n      znewline? zwhitespaceorcomment? zmap-all zpromise? zfuture? zdelay?\n      zkeyword? zconstant? zagent? zreader-macro? zarray-to-shift-seq zdotdotdot\n      zsymbol? znil? zreader-cond-w-symbol? zreader-cond-w-coll? zlift-ns zfind\n      zmap-w-nl zmap-w-nl-comma ztake-append znextnws-w-nl znextnws\n      znamespacedmap? zmap-w-bl zseqnws-w-bl]]\n    [zprint.ansi :refer [color-str]]\n    [zprint.config :refer [validate-options merge-deep]]\n    [zprint.zutil :refer [add-spec-to-docstring]]\n    [rewrite-clj.parser :as p]\n    [rewrite-clj.zip :as z]\n    #_[taoensso.tufte :as tufte :refer (p defnp profiled profile)]))\n\n#_(tufte/add-basic-println-handler! {})\n\n;;\n;; # Utility Functions\n;;\n\n(defn blanks\n  \"Produce a blank string of desired size.\"\n  [n]\n  (apply str (repeat n \" \")))\n\n(defn dots\n  \"Produce a dot string of desired size.\"\n  [n]\n  (apply str (repeat n \".\")))\n\n(defn conj-it!\n  \"Make a version of conj! that take multiple arguments.\"\n  [& rest]\n  (loop [out (first rest)\n         more (next rest)]\n    (if more (recur (conj! out (first more)) (next more)) out)))\n\n(defn split-lf\n  \"Do split for newlines, instead of using regular expressions.\"\n  [s]\n  (loop [input s\n         out []]\n    (if-not input\n      out\n      (let [next-lf (clojure.string/index-of input \"\\n\")\n            chunk (if next-lf (subs input 0 next-lf) input)]\n        (recur (if next-lf (subs input (inc next-lf)) nil) (conj out chunk))))))\n\n(defn split-lf-2\n  \"Do split for newlines, instead of using regular expressions.\n  Maximum split is 2.\"\n  [s]\n  (if-let [next-lf (clojure.string/index-of s \"\\n\")]\n    [(subs s 0 next-lf) (subs s (inc next-lf))]\n    [s]))\n\n;;\n;; # Use pmap when we have it\n;;\n\n#?(:clj (defn zpmap\n          ([options f coll]\n           (if (:parallel? options) (pmap f coll) (map f coll)))\n          ([options f coll1 coll2]\n           (if (:parallel? options) (pmap f coll1 coll2) (map f coll1 coll2))))\n   :cljs (defn zpmap\n           ([options f coll] (map f coll))\n           ([options f coll1 coll2] (map f coll1 coll2))))\n\n;;\n;; # More parallelism issues -- zderef to go with zfuture macro\n;;\n\n(defn zat\n  \"Takes an option map and the return from zfuture.  If the\n  options map has (:parallel? options) as true, then deref\n  the value, otherwise just pass it through.\"\n  [options value]\n  #?(:clj (if (:parallel? options) (deref value) value)\n     :cljs value))\n\n;;\n;; # Debugging Assistance\n;;\n\n(def fzprint-dbg (atom nil))\n\n(defn log-lines\n  \"Accept a style-vec that we are about to hand to style-lines, and\n  output it if called for, to aid in debugging.\"\n  [{:keys [dbg-print? dbg-indent in-hang?], :as options} dbg-output ind\n   style-vec]\n  (when dbg-print?\n    (if style-vec\n      (do (println dbg-indent dbg-output \"--------------\" \"in-hang?\" in-hang?)\n          (prn style-vec)\n          #_(println (apply str (blanks ind) (map first style-vec))))\n      (println dbg-indent dbg-output \"--------------- no style-vec\"))))\n\n;;\n;; # What is a function?\n;;\n\n(defn showfn?\n  \"Show this thing as a function?\"\n  [fn-map f]\n  (when (not (string? f))\n    (let [f-str (str f)]\n      (or (fn-map f-str)\n          (re-find #\"clojure\" f-str)\n          (if (symbol? f)\n            ; This is necessary because f can be a symbol that\n            ; resolve will have a problem with.  The obvious ones\n            ; were (ns-name <some-namespace>), but there are almost\n            ; certainly others.\n            (try (or (re-find #\"clojure\"\n                              (str (:ns (meta #?(:clj (resolve f)\n                                                 :cljs f)))))\n                     (fn-map (name f)))\n                 (catch #?(:clj Exception\n                           :cljs :default)\n                   e\n                   nil)))))))\n\n(defn show-user-fn?\n  \"Show this thing as a user defined function?  Assumes that we\n  have already handled any clojure defined functions!\"\n  [options f]\n  (when (not (string? f))\n    (let [f-str (str f)\n          user-fn-map (:user-fn-map options)]\n      (or (get user-fn-map f-str)\n          (if (symbol? f)\n            ; This is necessary because f can be a symbol that\n            ; resolve will have a problem with.  The obvious ones\n            ; were (ns-name <some-namespace>), but there are almost\n            ; certainly others.\n            (try (or (not (empty? (str (:ns (meta #?(:clj (resolve f)\n                                                     :cljs f))))))\n                     (get user-fn-map (name f)))\n                 (catch #?(:clj Exception\n                           :cljs :default)\n                   e\n                   nil)))))))\n\n(def right-separator-map {\")\" 1, \"]\" 1, \"}\" 1})\n\n;;\n;; # Functions to compare alternative printing approaches\n;;\n\n(declare fix-rightcnt)\n(declare contains-nil?)\n\n(defn good-enough?\n  \"Given the fn-style, is the first output good enough to be worth\n  doing. p is pretty, which is typically hanging, and b is basic, which\n  is typically flow. p-count is the number of elements in the hang.\"\n  [caller\n   {:keys [width rightcnt dbg?],\n    {:keys [hang-flow hang-type-flow hang-flow-limit general-hang-adjust\n            hang-if-equal-flow?]}\n      :tuning,\n    {:keys [hang-expand hang-diff hang-size hang-adjust]} caller,\n    :as options} fn-style p-count indent-diff\n   [p-lines p-maxwidth p-length-seq p-what] [b-lines b-maxwidth _ b-what]]\n  (let [p-last-maxwidth (last p-length-seq)\n        hang-diff (or hang-diff 0)\n        hang-expand (or hang-expand 1000.)\n        hang-adjust (or hang-adjust general-hang-adjust)\n        #_(options (if (and p-lines\n                            p-count\n                            (pos? p-count)\n                            (not (<= indent-diff hang-diff))\n                            (not (<= (/ (dec p-lines) p-count) hang-expand)))\n                     (assoc options :dbg? true)\n                     options))\n        options (if (or p-what b-what) (assoc options :dbg? true) options)\n        result (if (not b-lines)\n                 true\n                 (and p-lines\n                      ; Does the last line fit, including the collection ending\n                      ; stuff?\n                      ; Do we really need this anymore?\n                      (<= p-last-maxwidth (- width (fix-rightcnt rightcnt)))\n                      ; Does it widest line fit?\n                      ; Do we have a problem if the widest line has a rightcnt?\n                      (<= p-maxwidth width)\n                      ;      (<= p-maxwidth (- width (fix-rightcnt rightcnt)))\n                      (or (zero? p-lines)\n                          (and ; do we have lines to operate on?\n                            (> b-lines 0)\n                            (> p-count 0)\n                            ; if the hang and the flow are the same size, why\n                            ; not\n                            ; hang?\n                            (if (and (= p-lines b-lines) hang-if-equal-flow?)\n                              true\n                              ; is the difference between the indents so small\n                              ; that\n                              ; we don't care?\n                              (and (if (<= indent-diff hang-diff)\n                                     true\n                                     ; Do the number of lines in the hang exceed\n                                     ; the number\n                                     ; of elements in the hang?\n                                     (<= (/ (dec p-lines) p-count) hang-expand))\n                                   (if hang-size (< p-lines hang-size) true)\n                                   (let [factor (if (= fn-style :hang)\n                                                  hang-type-flow\n                                                  hang-flow)]\n                                     ; if we have more than n lines, take the\n                                     ; shortest\n                                     (if (> p-lines hang-flow-limit)\n                                       (<= (dec p-lines) b-lines)\n                                       ; if we have less then n lines, we don't\n                                       ; necessarily\n                                       ; take the shortest\n                                       ; once we did (dec p-lines) here, fwiw\n                                       ; then we tried it w/out the dec, now we\n                                       ; let you\n                                       ; set it in :tuning.  The whole point of\n                                       ; having a\n                                       ; hang-adjust of -1 is to allow hangs\n                                       ; when\n                                       ; the\n                                       ; number of lines in a hang is the same\n                                       ; as\n                                       ; the\n                                       ; number of lines in a flow.\n                                       ;(< (/ p-lines b-lines) factor)))))))]\n                                       (< (/ (+ p-lines hang-adjust) b-lines)\n                                          factor)))))))))]\n    (dbg options\n         (if result \"++++++\" \"XXXXXX\")\n         \"p-what\" p-what\n         \"good-enough? caller:\" caller\n         \"fn-style:\" fn-style\n         \"width:\" width\n         \"rightcnt:\" rightcnt\n         \"hang-expand:\" hang-expand\n         \"p-count:\" p-count\n         \"p-lines:\" p-lines\n         \"p-maxwidth:\" p-maxwidth\n         \"indent-diff:\" indent-diff\n         \"hang-diff:\" hang-diff\n         \"p-last-maxwidth:\" p-last-maxwidth\n         \"b-lines:\" b-lines\n         \"b-maxwidth:\" b-maxwidth)\n    result))\n\n;;\n;; # Utility Functions\n;;\n\n(defn in-hang\n  \"Add :in-hang? true to the options map.\"\n  [options]\n  (if (:in-hang? options)\n    options\n    (if (:do-in-hang? options)\n      (assoc options :in-hang? (or (:depth options) true))\n      options)))\n\n(defn contains-nil?\n  \"Scan a collection, and return true if it contains any nils or empty\n  collections.\"\n  [coll]\n  (some #(if (coll? %) (empty? %) (nil? %)) coll))\n\n(defn concat-no-nil-alt\n  \"Concatentate multiple sequences, but if any of them are nil, return nil.\n  This version is 15-20% slower than the version below. Keeping it around\n  just for illustrative purposes.\"\n  [& rest]\n  (loop [coll rest\n         out (transient [])]\n    (let [c (first coll)]\n      (if-not c\n        (persistent! out)\n        (when (or (and (coll? c) (not (empty? c))) (not (nil? c)))\n          (recur (next coll) (conj! out c)))))))\n\n(defn concat-no-nil-pre-noseq\n  \"Concatentate multiple sequences, but if any of them are nil or empty\n  collections, return nil.\"\n  [& rest]\n  (let [result (reduce (fn [v o]\n                         (if (coll? o)\n                           (if (empty? o) (reduced nil) (reduce conj! v o))\n                           (if (nil? o) (reduced nil) (conj! v o))))\n                 (transient [])\n                 rest)]\n    (when result (persistent! result))))\n\n(declare count-right-blanks)\n(declare trimr-blanks)\n\n(defn concat-no-nil\n  \"Concatentate multiple sequences, but if any of them are nil or empty\n  collections, return nil. If any of them are :noseq, just skip them.\n  When complete, check the last element-- if it is a :right, and if it\n  the previous element is a :newline or :indent, then ensure that the\n  number of spaces in that previous element matches the number to the\n  right of the :right.\"\n  [& rest]\n  (let [result (reduce (fn [v o]\n                         (if (coll? o)\n                           (if (empty? o) (reduced nil) (reduce conj! v o))\n                           (if (= :noseq o)\n                             ; if the supposed sequence is :noseq, skip it\n                             v\n                             (if (nil? o) (reduced nil) (conj! v o)))))\n                 (transient [])\n                 rest)]\n    (when result\n      (let [result (persistent! result)]\n        (if (< (count result) 2)\n          result\n          (let [[_ _ what right-ind :as last-element] (peek result)]\n            (if (= what :right)\n              ; we have a right paren, bracket, brace as the last thing\n              (let [previous-index (- (count result) 2)\n                    [s color previous-what] (nth result previous-index)]\n                (if (or (= previous-what :newline) (= previous-what :indent))\n                  ; we have a newline or equivalent before the last thing\n                  (if (= (count-right-blanks s) right-ind)\n                    ; we already have the right number of blanks!\n                    result\n                    (let [new-previous [(str (trimr-blanks s)\n                                             (blanks right-ind)) color\n                                        previous-what]]\n                      (assoc result previous-index new-previous)))\n                  result))\n              result)))))))\n\n\n(defn concat-no-nil-pre-right\n  \"Concatentate multiple sequences, but if any of them are nil or empty\n  collections, return nil. If any of them are :noseq, just skip them.\"\n  [& rest]\n  (let [result (reduce (fn [v o]\n                         (if (coll? o)\n                           (if (empty? o) (reduced nil) (reduce conj! v o))\n                           (if (= :noseq o)\n                             ; if the supposed sequence is :noseq, skip it\n                             v\n                             (if (nil? o) (reduced nil) (conj! v o)))))\n                 (transient [])\n                 rest)]\n    (when result (persistent! result))))\n\n(defn remove-one\n  \"Remove a single thing from a sequence.\"\n  [s index]\n  (concat (take index s) (drop (inc index) s)))\n\n(defn force-vector\n  \"Ensure that whatever we have is a vector.\"\n  [coll]\n  (if (vector? coll) coll (into [] coll)))\n\n(defn keyword-fn?\n  \"Takes a string, and returns the fn-style if it is a keyword and\n  without the : it can be found in the fn-map.\"\n  [options s]\n  (let [[left right] (clojure.string/split s #\"^:\")]\n    (when right ((:fn-map options) right))))\n\n(defn get-max-length\n  \"Given the options map, return the max length.  This might be\n  a constant number, but it might be based on the depth as well.\n  Returns nil of there is no max-length set.\"\n  [{:as options, :keys [max-length depth]}]\n  (when max-length\n    (if (vector? max-length)\n      (nth max-length (min (dec depth) (dec (count max-length))))\n      max-length)))\n\n(defn no-max-length\n  \"Given an options map, return another options map with no\n  :max-length key.  This is to that you can call a routine that\n  normally deals with :max-length and get it to do the normal\n  thing.\"\n  [options]\n  (assoc options :max-length 10000))\n\n;;\n;; # Work with style-vecs and analyze results\n;;\n\n;; Transients don't help here, though they don't hurt much either.\n\n(defn accumulate-ll\n  \"Take the vector carrying the intermediate results, and\n  do the right thing with a new string. Vector is\n  [ 0 out - vector accumulating line lengths \n    1 cur-len - length of current line\n    just-eol? - did we just do an eol?\n    ]\n  s - string to add to current line\n  tag - element type of string (comment's don't count in length)\n  eol? - should we terminate line after adding count of s\"\n  [count-comment? [out cur-len just-eol? just-comment? :as in] s tag eol?]\n  (let [comment? (or (= tag :comment) (= tag :comment-inline))\n        count-s (if (and comment? (not count-comment?)) 0 (count s))]\n    (cond\n      ; if we are told to terminate the line or it\n      ; is a comment, we terminate the line with the\n      ; size of the string added to it\n      (or (and eol? (not (and just-eol? (zero? count-s)))) comment?)\n        [(conj out (+ cur-len count-s)) 0 true comment?]\n      ;(assoc in 0 (conj out (+ cur-len count-s)) 1 0 2 true 3 comment?)\n      ; no reason to terminate the line, just accumulate\n      ; the size in cur-len\n      :else [out (+ cur-len count-s) nil comment?])))\n\n(defn generate-ll\n  [count-comment? [out cur-len just-eol? just-comment? :as in]\n   [s _ tag :as element]]\n  (let [[l r] (if (or (= tag :whitespace) (= tag :indent) (= tag :newline))\n                (split-lf-2 s)\n                (list s))\n        ; if tag = :comment, shouldn't have \\n and\n        ; therefore shouldn't have r\n        ; if r is non-nil, then we had a newline, so we want to\n        ; terminate the current line\n        ; if we are already in a comment and we have something\n        ; that is not whitespace, then we want to terminate the\n        ; current line\n        in (accumulate-ll count-comment? in l tag (not (nil? r)))\n        in (if (empty? r) in (accumulate-ll count-comment? in r tag nil))]\n    in))\n\n\n(defn line-lengths-iter\n  \"Take a style-vec, and output a sequence of numbers, one for each\n  line, which contains the actual length. Must take the current\n  indent to have a prayer of getting this right, but it is used\n  only for the first line.  The ind can be an integer or a seq of\n  integers, in which case only the first integer is used. Newlines\n  can come anywhere in an element in a style-vec, it will account\n  for both sides.  Will break lines on comments even if no newlines\n  in them.  This doesn't count the length of comment lines unless\n  [:comment :count?] is true, so that we don't format based on\n  comment size -- that is handled with the wrap-comments elsewhere.\n  Note that only vectors with :whitespace, :indent, or :newline are scanned\n  for newlines, and if consecutive newlines appear, only the first\n  is counted as a newline -- the second is counted as a regular \n  character. A single comment is counted as two lines. Lots of edge\n  conditions that are really quite important.\"\n  [options ind style-vec]\n  (let [count-comment? (:count? (:comment options))\n        ind (if (coll? ind) (first ind) ind)]\n    (dbg-pr options \"line-lengths-iter: style-vec:\" style-vec)\n    (loop [next-vec style-vec\n           current-string nil\n           line-length ind\n           previous-comment? nil\n           out []]\n      (if (or (and (empty? next-vec) (empty? current-string)))\n        ; A trailing newline isn't counted.\n        (cond (and (zero? line-length) (not previous-comment?)) out\n              previous-comment? (conj out line-length 0)\n              :else (conj out line-length))\n        (let [advance? (empty? current-string)\n              [next-string _ tag] (when advance? (first next-vec))\n              comment? (or (= tag :comment) (= tag :comment-inline))\n              s (if advance? next-string current-string)\n              [l r] (when s\n                      ; if we have a current-string, then we are looking for\n                      ; newlines\n                      (cond (and comment? (not count-comment?)) [\"\"]\n                            (or (and advance?\n                                     (or (= tag :whitespace)\n                                         (= tag :newline)\n                                         (= tag :indent)))\n                                current-string)\n                              (split-lf-2 s)\n                            :else [s]))\n              ; If r non-nil, we had a newline at end of l.\n              ; If we had a previous-comment, then we want to\n              ; imply a newline unless we have a newline at the\n              ; start of s.\n              ; If r is non-nil, and l is empty, then the newline\n              ; was at the front of r, in which case we don't need to\n              ; do an implied newline for the comment (if any).\n              ; Choices:\n              ;  leave l and r alone\n              ;  l becomes nil and r is (str l r)\n              force-newline? (and previous-comment? (not (empty? l)))\n              #_(prn \"l:\" l\n                     \"r:\" r\n                     \"force-newline?\" force-newline?\n                     \"comment?\" comment?)\n              r (if force-newline? (str l r) r)\n              l (if force-newline? nil l)\n              new-line-length (+ line-length (count l))]\n          #_(prn \"current-string:\" current-string\n                 \"line-length:\" line-length\n                 \"advance?\" advance?\n                 \"s:\" s\n                 \"l:\" l\n                 \"r:\" r\n                 \"new-line-length:\" new-line-length)\n          (recur (if advance? (next next-vec) next-vec)\n                 r\n                 (if r 0 new-line-length)\n                 comment?\n                 (if r (conj out new-line-length) out)))))))\n\n(defn line-lengths\n  \"Take a style-vec, and output a sequence of numbers, one for each\n  line, which contains the actual length. Must take the current\n  indent to have a prayer of getting this right, but it is used\n  only for the first line.  The ind can be an integer or a seq of\n  integers, in which case only the first integer is used. Newlines\n  can come anywhere in an element in a style-vec, it will account\n  for both sides.  Will break lines on comments even if no newlines\n  in them.  This doesn't count the length of comment lines unless\n  [:comment :count?] is true, so that we don't format based on\n  comment size -- that is handled with the wrap-comments at the\n  end. Note that only vectors with :whitespace or :indent are scanned\n  for newlines, and if consecutive newlines appear, only the first\n  is counted as a newline -- the second is counted as a regular \n  character.\"\n  [options ind style-vec]\n  (let [length-vec (first ; this final accumulate-ll is to terminate the last\n                          ; line, the one in progress\n                     (let [count-comment? (:count? (:comment options))\n                           [_ _ just-eol? just-comment? :as result]\n                             (reduce (partial generate-ll count-comment?)\n                               [[] (if (coll? ind) (first ind) ind) nil nil]\n                               style-vec)]\n                       (if (and just-eol? (not just-comment?))\n                         result\n                         (accumulate-ll count-comment?\n                                        (assoc result 2 nil)\n                                        \"\"\n                                        nil\n                                        true))))]\n    (dbg-pr options\n            \"line-lengths: style-vec:\" style-vec\n            \"ind:\" ind\n            \"length-vec:\" length-vec)\n    length-vec))\n\n(defn single-line?\n  \"This looks at a style vec and doesn't do all that style-lines does.\n  It just looks for a new-line in the strings, and returns true if it\n  doesn't find one.\"\n  [style-vec]\n  #_(prn \"style-vec:\" style-vec)\n  (not (reduce #(or %1 %2)\n         false\n         (map #(clojure.string/includes? (first %) \"\\n\") style-vec))))\n\n(defn find-what\n  \"Given a style-vec, come up with a string that gives some hint of \n  where this style-vec came from.\"\n  [style-vec]\n  (loop [s-vec style-vec]\n    (when s-vec\n      (let [[what _ this] (first s-vec)]\n        (if (= this :element) what (recur (next s-vec)))))))\n\n(defn first-nl?\n  \"Look at a style vec ready to be given to concat-no-nil, and see if\n  the first thing in there is a newline of some sort.\"\n  [style-vec]\n  (let [[s color what] (first style-vec)]\n    (or (= what :newline) (= what :indent))))\n\n(defn prepend-nl\n  \"Given an indent ind and a style-vec coll, place a newline (actually an\n  indent) at the front of coll.  If the first thing in coll is a newline,\n  then don't add any spaces after the newline that we prepend.\"\n  [options ind coll]\n  (concat-no-nil [[(str \"\\n\" (blanks (if (first-nl? coll) 0 ind))) :none :indent\n                   1]]\n                 coll))\n\n; Debugging help to find differences between line-lengths and\n; line-lengths-iter.  Surprisingly helpful!\n#_(defonce lldiff (atom []))\n\n(defn style-lines\n  \"Take a style output, and tell us how many lines it takes to print it\n  and the maximum width that it reaches. Returns \n  [<line-count> <max-width> [line-lengths]].\n  Doesn't require any max-width inside the style-vec. Also returns the\n  line lengths in case that is helpful (since we have them anyway).\n  If (:dbg-ge options) has value, then uses find-what to see if what it\n  finds matches the value, and if it does, place the value in the\n  resulting vector.\"\n  [options ind style-vec]\n  (when (and style-vec (not (empty? style-vec)) (not (contains-nil? style-vec)))\n    (let [;lengths (line-lengths options ind style-vec)\n          lengths (line-lengths-iter options ind style-vec)\n          count-lengths (count lengths)\n          result [count-lengths (if (zero? count-lengths) 0 (apply max lengths))\n                  lengths]\n          dbg-ge (:dbg-ge options)\n          what (when (and dbg-ge (= (find-what style-vec) dbg-ge)) dbg-ge)]\n      #_(when (not= lengths lengths-iter) (swap! lldiff conj style-vec))\n      (if what (conj result what) result))))\n\n(defn fzfit\n  \"Given output from style-lines and options, see if it fits the width.  \n  Return the number of lines it takes if it fits, nil otherwise.\"\n  [{:keys [width rightcnt dbg?], :as options}\n   [line-count max-width :as style-lines-return]]\n  (dbg options\n       \"fzfit: fixed-rightcnt:\" (fix-rightcnt rightcnt)\n       \"line-count:\" line-count\n       \"max-width:\" max-width\n       \"width:\" width)\n  (when style-lines-return\n    (if (<= max-width (- width (fix-rightcnt rightcnt))) line-count nil)))\n\n(defn fzfit-one-line\n  \"Given the return from style-lines  and options, \n  return true if it fits on a single line.\"\n  [options style-lines-return]\n  (let [lines (fzfit options style-lines-return)]\n    (and (number? lines) (= lines 1))))\n\n;;\n;; # Handle Rightmost Size\n;;\n\n(defn rightmost\n  \"Increase the rightmost count, if any, and return one if not.\"\n  [options]\n  (assoc options :rightcnt (inc (:rightcnt options 0))))\n\n(defn not-rightmost\n  \"Remove the rightmost count.\"\n  [options]\n  (dissoc options :rightcnt))\n\n(defn c-r-pair\n  \"Handle the complexity of commas and rightmost-pair with options.\n  If it isn't a rightmost, it loses rightmost status.\n  If it is a rightmost, and in the rightmost pair, it gain one rightmost\n  since it has the right end thing (and we don't care about the comma).\n  If it is the rightmost of the non-rightmost-pair, then the comma\n  matters, and we handle that appropriately.  Whew!\"\n  [commas? rightmost-pair? rightmost? options]\n  (if-not rightmost?\n    (not-rightmost options)\n    (if rightmost-pair?\n      options\n      (if commas?\n        (rightmost (not-rightmost options))\n        (not-rightmost options)))))\n\n(defn fix-rightcnt\n  \"Handle issue with rightcnt.\"\n  [rightcnt]\n  (if (number? rightcnt) rightcnt 0))\n\n;;\n;; # First pass at color -- turn string or type into keyword color\n;;\n\n;;\n;; ## Translate from a string to a keyword as needed.\n;;\n\n(def str->key\n  {\"(\" :paren,\n   \")\" :paren,\n   \"[\" :bracket,\n   \"]\" :bracket,\n   \"{\" :brace,\n   \"}\" :brace,\n   \"#{\" :hash-brace,\n   \"#(\" :hash-paren,\n   \"#_\" :uneval,\n   \"'\" :quote,\n   \"`\" :syntax-quote,\n   \"~\" :unquote,\n   \"~@\" :unquote-splicing,\n   \"@\" :deref})\n\n\n(defn zcolor-map\n  \"Look up the thing in the zprint-color-map.  Accepts keywords or\n  strings.\"\n  [{:keys [color-map], :as options} key-or-str]\n  (color-map (if (keyword? key-or-str) key-or-str (str->key key-or-str))))\n\n\n;;\n;; ## Pretty Printer Code\n;;\n\n(declare fzprint*)\n(declare fzprint-flow-seq)\n\n(defn hangflow\n  \"Take a style-vec, and if hangflow? is true, return a\n  vector [hang-or-flow style-vec], else return style-vec.\n  But a nil style-vec returns nil.\"\n  [hangflow? hang-or-flow style-vec]\n  (when style-vec (if hangflow? [hang-or-flow style-vec] style-vec)))\n\n(defn fzprint-hang-unless-fail\n  \"Try to hang something and if it doesn't hang at all, then flow it,\n  but strongly prefer hang.  Has hang and flow indents, and fzfn is the\n  fzprint-? function to use with zloc.  Callers need to know whether this\n  was hang or flow, so it returns [{:hang | :flow} style-vec] all the time.\"\n  [options hindent findent fzfn zloc]\n  (dbg options\n       \"fzprint-hang-unless-fail: hindent:\" hindent\n       \"findent:\" findent\n       \"zloc:\" (zstring (zfirst zloc)))\n  ; If the hindent is different than the findent, we'll try hang, otherwise\n  ; we will just do the flow\n  (let [hanging (when (not= hindent findent)\n                  (fzfn (in-hang options) hindent zloc))]\n    (dbg-form\n      options\n      \"fzprint-hang-unless-fail: exit:\"\n      (if (and hanging (fzfit options (style-lines options hindent hanging)))\n        [:hang hanging]\n        ; hang didn't work, do flow\n        (do (dbg options \"fzprint-hang-unless-fail: hang failed, doing flow\")\n            [:flow\n             (prepend-nl options findent (fzfn options findent zloc))])))))\n\n(defn replace-color\n  \"Given a style-vec with exactly one thing in it, replace the color\n  with whatever local color we have determined is correct.\"\n  [local-color style-vec]\n  (if (= (count style-vec) 1)\n    (let [[[string color element]] style-vec] [[string local-color element]])\n    style-vec))\n\n(declare fzprint-binding-vec)\n(declare middle-element?)\n\n(defn use-hang?\n  \"This routine tries to figure out if existing hang should be used without\n  even bothering to do a flow and compare them with good-enough?.\"\n  [caller\n   {:keys [depth width],\n    {:keys [hang-accept ha-depth-factor ha-width-factor]} caller,\n    :as options} ind hang-count hanging-line-count]\n  (when (and hanging-line-count hang-accept (pos? hang-count))\n    #_(prn \"use-hang? caller:\" caller \"(/ ind width):\" (double (/ ind width)))\n    (let [hang-accept (+ hang-accept\n                         (* depth ha-depth-factor)\n                         (* (/ ind width) ha-width-factor))]\n      (<= (/ (dec hanging-line-count) hang-count) hang-accept))))\n\n;;\n;; Performance Debugging\n;;\n\n#_(def pass-count (atom 0))\n#_(defn reset-pass-count! [] (reset! pass-count 0))\n#_(defn inc-pass-count [] (swap! pass-count inc))\n#_(defn print-pass-count [] (println \"pass-count:\" @pass-count))\n\n(defn fzprint-two-up\n  \"Print a single pair of things (though it might not be exactly a\n  pair, given comments and :extend and the like), like bindings in\n  a let, clauses in a cond, keys and values in a map.  Controlled\n  by various maps, the key of which is caller.  Returns \n  [:hang <style-vec>] or [:flow <style-vec>] so that the upstream folks\n  know whether this was a hang or flow and can do the right thing\n  based on that.\"\n  [caller\n   {:keys [one-line? dbg? dbg-indent in-hang? do-in-hang? map-depth],\n    {:keys [hang? dbg-local? dbg-cnt? indent indent-arg flow? key-color\n            key-depth-color key-value-color]}\n      caller,\n    :as options} ind commas? justify-width rightmost-pair?\n   [lloc rloc xloc :as pair]]\n  (if dbg-cnt? (println \"two-up: caller:\" caller \"hang?\" hang? \"dbg?\" dbg?))\n  (if (or dbg? dbg-local?)\n    (println\n      (or dbg-indent \"\")\n      \"==========================\"\n      (str \"\\n\" (or dbg-indent \"\"))\n      (pr-str \"fzprint-two-up:\" (zstring lloc)\n              \"tag:\" (ztag lloc)\n              \"caller:\" caller\n              \"count:\" (count pair)\n              \"ind:\" ind\n              \"indent:\" indent\n              \"indent-arg:\" indent-arg\n              \"justify-width:\" justify-width\n              \"one-line?:\" one-line?\n              \"hang?:\" hang?\n              \"in-hang?\" in-hang?\n              \"do-in-hang?\" do-in-hang?\n              \"flow?\" flow?\n              \"commas?\" commas?\n              \"rightmost-pair?\" rightmost-pair?)))\n  (let [local-hang? (or one-line? hang?)\n        indent (or indent indent-arg)\n        local-options\n          (if (not local-hang?) (assoc options :one-line? true) options)\n        loptions (c-r-pair commas? rightmost-pair? nil options)\n        roptions (c-r-pair commas? rightmost-pair? :rightmost options)\n        local-roptions\n          (c-r-pair commas? rightmost-pair? :rightmost local-options)\n        ; If we have a key-value-color map, and the key we have matches any\n        ; of the keys in the map, then merge the resulting color-map elements\n        ; into the current color-map.  Could be problematic if lloc is a\n        ; modifier, but at present modifiers are only for extend and\n        ; key-value-color is only for maps, so they can't both show up\n        ; at once.\n        value-color-map (and key-value-color (key-value-color (zsexpr lloc)))\n        local-roptions (if value-color-map\n                         (merge-deep local-roptions\n                                     {:color-map value-color-map})\n                         local-roptions)\n        roptions (if value-color-map\n                   (merge-deep roptions {:color-map value-color-map})\n                   roptions)\n        ; It is possible that lloc is a modifier, and if we have exactly\n        ; three things, we will pull rloc in with it, and move xloc to rloc.\n        ; If it is just two, we'll leave it to be handled normally.\n        ; Which might need to be re-thought due to justification, but since\n        ; we are really only talking :extend here, maybe not.\n        modifier-set (:modifiers (options caller))\n        modifier? (or (and modifier-set\n                           (modifier-set (zstring lloc))\n                           (> (count pair) 2))\n                      (middle-element? options rloc))\n        ; Figure out if we want to color keys based on their depth, and if so,\n        ; figure out the color for this one.\n        local-color (get key-depth-color (dec map-depth))\n        ; Doesn't work if we have a modifier, but at this point, key-color\n        ; is only for maps and modifiers are only for extend.\n        local-color (if key-color (key-color (zsexpr lloc)) local-color)\n        #_local-color\n        #_(cond (and map-depth (= caller :map) (= map-depth 2)) :green\n                (and map-depth (= caller :map) (= map-depth 1)) :blue\n                (and map-depth (= caller :map) (= map-depth 3)) :yellow\n                (and map-depth (= caller :map) (= map-depth 4)) :red\n                :else nil)\n        arg-1 (fzprint* loptions ind lloc)\n        ; If we have a newline, make it one shorter since we did a newline\n        ; after the previous pair.  Unless this is the first pair, but we\n        ; should have done one before that pair too, maybe?\n        arg-1-newline? (and (= (count pair) 1) (znewline? lloc))\n        #_#_arg-1\n          (if arg-1-newline? (first (remove-last-newline [arg-1])) arg-1)\n        arg-1 (if local-color (replace-color local-color arg-1) arg-1)\n        ; If we are going to print the second thing on the line, we need\n        ; to know how big the first thing is, so we can see if the second\n        ; thing fits on the line.\n        [arg-1-line-count arg-1-max-width :as arg-1-lines]\n          (style-lines options ind arg-1)\n        ; If arg-1 already takes multiple lines, we aren't going to do\n        ; anything interesting with a modifier.\n        _ (dbg options\n               \"fzprint-two-up before modifier: arg-1-line-count:\"\n                 arg-1-line-count\n               \"arg-1-max-width:\" arg-1-max-width)\n        modifier? (if (or (and arg-1-line-count (> arg-1-line-count 1))\n                          arg-1-newline?)\n                    nil\n                    modifier?)\n        ; See if we can merge the first and second things and have them\n        ; stay on the same line?\n        combined-arg-1 (if modifier?\n                         (concat-no-nil arg-1\n                                        [[(str \" \") :none :whitespace 1]]\n                                        (fzprint* (in-hang loptions)\n                                                  (+ ind arg-1-max-width)\n                                                  rloc))\n                         arg-1)\n        ; If they fit, then they are the new arg-1\n        arg-1 (if combined-arg-1 combined-arg-1 arg-1)\n        ; If they fit, then we are still doing modifier if we are already\n        modifier? (if combined-arg-1 modifier? nil)\n        ; If they fit, we need to recalculate the size of arg-1\n        [arg-1-line-count arg-1-max-width :as arg-1-lines]\n          (if combined-arg-1 (style-lines options ind arg-1) arg-1-lines)\n        _ (dbg options\n               \"fzprint-two-up after modifier: arg-1-line-count:\"\n                 arg-1-line-count\n               \"arg-1-max-width:\" arg-1-max-width)\n        lloc (if modifier? rloc lloc)\n        rloc (if modifier? xloc rloc)\n        ;     arg-1-fit-oneline? (and (not force-nl?)\n        ;                             (fzfit-one-line loptions arg-1-lines))\n        arg-1-fit-oneline? (and (not flow?)\n                                (fzfit-one-line loptions arg-1-lines))\n        arg-1-fit? (or arg-1-fit-oneline?\n                       (when (not one-line?) (fzfit loptions arg-1-lines)))\n        ; sometimes arg-1-max-width is nil because fzprint* returned nil,\n        ; but we need to have something for later code to use as a number\n        arg-1-width (- (or arg-1-max-width 0) ind)]\n    ; If we don't *have* an arg-1, no point in continuing...\n    ;  If arg-1 doesn't fit, maybe that's just how it is!\n    ;  If we are in-hang, then we can bail, but otherwise, not.\n    (dbg-pr options \"fzprint-two-up: arg-1:\" arg-1)\n    (when (and arg-1 (or arg-1-fit? (not in-hang?)))\n      (cond\n        arg-1-newline? [:flow arg-1]\n        (= (count pair) 1) [:hang (fzprint* roptions ind lloc)]\n        (or (= (count pair) 2) (and modifier? (= (count pair) 3)))\n          ;concat-no-nil\n          ;  arg-1\n          ; We used to think:\n          ; We will always do hanging, either fully or with one-line? true,\n          ; we will then do flow if hanging didn't do anything or if it did,\n          ; we will try to see if flow is better.\n          ;\n          ; But now, we don't do hang if arg-1-fit-oneline? is false, since\n          ; we won't use it.\n          (let [hanging-width (if justify-width justify-width arg-1-width)\n                hanging-spaces\n                  (if justify-width (inc (- justify-width arg-1-width)) 1)\n                hanging-indent (+ 1 hanging-width ind)\n                flow-indent (+ indent ind)]\n            (if (and (zstring lloc)\n                     (keyword-fn? options (zstring lloc))\n                     (zvector? rloc))\n              ; This is an embedded :let or :when-let or something\n              ; Presently we assume that anything with a vector after something\n              ; that is a keyword must be one of these, but we could check\n              ; for a :binding fn-style instead which might make more sense.\n              (let [[hang-or-flow style-vec] (fzprint-hang-unless-fail\n                                               loptions\n                                               hanging-indent\n                                               flow-indent\n                                               fzprint-binding-vec\n                                               rloc)\n                    arg-1 (if (= hang-or-flow :hang)\n                            (concat-no-nil arg-1\n                                           [[(blanks hanging-spaces) :none\n                                             :whitespace 2]])\n                            arg-1)]\n                [hang-or-flow (concat-no-nil arg-1 style-vec)])\n              ; This is a normal two element pair thing\n              (let [; Perhaps someday we could figure out if we are already\n                    ; completely in flow to this point, and be smarter about\n                    ; possibly dealing with the hang or flow now.  But for\n                    ; now, we will simply do hang even if arg-1 didn't fit\n                    ; on one line if the flow indent isn't better than the\n                    ; hang indent.\n                    _ (dbg options\n                           \"fzprint-two-up: before hang.  hanging tried?\"\n                           (or arg-1-fit-oneline?\n                               (and (not flow?)\n                                    (>= flow-indent hanging-indent))))\n                    hanging (when (or arg-1-fit-oneline?\n                                      (and (not flow?)\n                                           (>= flow-indent hanging-indent)))\n                              (fzprint* (if (< flow-indent hanging-indent)\n                                          (in-hang local-roptions)\n                                          local-roptions)\n                                        hanging-indent\n                                        rloc))\n                    hang-count (zcount rloc)\n                    _ (log-lines options\n                                 \"fzprint-two-up: hanging:\"\n                                 hanging-indent\n                                 hanging)\n                    hanging-lines (style-lines options hanging-indent hanging)\n                    fit? (fzfit-one-line local-roptions hanging-lines)\n                    hanging-lines (if fit?\n                                    hanging-lines\n                                    (when (and (not one-line?) hang?)\n                                      hanging-lines))\n                    hanging-line-count (first hanging-lines)\n                    ; Don't flow if it fit, or it didn't fit and we were doing\n                    ; one line on input.  Do flow if we don't have\n                    ; hanging-lines\n                    ; and we were not one-line on input.\n                    _ (dbg options\n                           \"fzprint-two-up: fit?\" fit?\n                           \"hanging-lines:\" hanging-lines)\n                    _ (log-lines options\n                                 \"fzprint-two-up: hanging-2:\"\n                                 hanging-indent\n                                 hanging)\n                    flow-it?\n                      #_(and (or (and (not hanging-lines) (not one-line?))\n                                 (not (or fit? one-line?)))\n                             ; this is for situations where the first\n                             ; element is short and so the hanging indent\n                             ; is the same as the flow indent, so there\n                             ; is\n                             ; no point in flow -- unless we don't have\n                             ; any hanging-lines, in which case we better\n                             ; do flow\n                             (or (< flow-indent hanging-indent)\n                                 (not hanging-lines)))\n                      (or (not hanging-lines)\n                          ; TODO: figure out what this was supposed to\n                          ; be and fix it, w/out (not hanging-lines)\n                          (and (or (and (not hanging-lines) (not one-line?))\n                                   (not (or fit? one-line?)))\n                               ; this is for situations where the first\n                               ; element is short and so the hanging indent\n                               ; is the same as the flow indent, so there\n                               ; is\n                               ; no point in flow -- unless we don't have\n                               ; any hanging-lines, in which case we better\n                               ; do flow\n                               (or (< flow-indent hanging-indent)\n                                   (not hanging-lines))))\n                    flow-it? (if (use-hang? caller\n                                            options\n                                            ind\n                                            hang-count\n                                            hanging-line-count)\n                               false\n                               flow-it?)\n                    #_(inc-pass-count)\n                    _ (dbg options\n                           \"fzprint-two-up: before flow. flow-it?\"\n                           flow-it?)\n                    flow (when flow-it? (fzprint* roptions flow-indent rloc))\n                    _ (log-lines options\n                                 \"fzprint-two-up: flow:\"\n                                 (+ indent ind)\n                                 flow)\n                    flow-lines (style-lines options (+ indent ind) flow)]\n                (when dbg-local?\n                  (prn \"fzprint-two-up: local-hang:\" local-hang?)\n                  (prn \"fzprint-two-up: one-line?:\" one-line?)\n                  (prn \"fzprint-two-up: hanging-indent:\" hanging-indent)\n                  (prn \"fzprint-two-up: hanging-lines:\" hanging-lines)\n                  (prn \"fzprint-two-up: flow?:\" flow?)\n                  (prn \"fzprint-two-up: flow-it?:\" flow-it?)\n                  (prn \"fzprint-two-up: fit?:\" fit?)\n                  (prn \"fzprint-two-up: flow-indent:\" flow-indent)\n                  (prn \"fzprint-two-up: hanging:\" (zstring lloc) hanging)\n                  (prn \"fzprint-two-up: (+ indent ind):\" (+ indent ind))\n                  (prn \"fzprint-two-up: flow:\" (zstring lloc) flow))\n                (dbg options \"fzprint-two-up: before good-enough\")\n                (if fit?\n                  [:hang\n                   (concat-no-nil arg-1\n                                  [[(blanks hanging-spaces) :none :whitespace\n                                    3]]\n                                  hanging)]\n                  (when (or hanging-lines flow-lines)\n                    (if (good-enough? caller\n                                      roptions\n                                      :none-two-up\n                                      hang-count\n                                      (- hanging-indent flow-indent)\n                                      hanging-lines\n                                      flow-lines)\n                      [:hang\n                       (concat-no-nil arg-1\n                                      [[(blanks hanging-spaces) :none\n                                        :whitespace 4]]\n                                      hanging)]\n                      (if justify-width\n                        nil\n                        [:flow\n                         (concat-no-nil\n                           arg-1\n                           (prepend-nl options (+ indent ind) flow))])))))))\n        :else [:flow ; The following always flows things of 3 or more\n               ; (absent modifers).  If the lloc is a single char,\n               ; then that can look kind of poor.  But that case\n               ; is rare enough that it probably isn't worth dealing\n               ; with.  Possibly a hang-remaining call might fix it.\n               (concat-no-nil\n                 arg-1\n                 (fzprint-flow-seq options\n                                   (+ indent ind)\n                                   (if modifier? (nnext pair) (next pair))\n                                   :force-nl\n                                   :newline-first))]))))\n\n;;\n;; # Two-up printing\n;;\n\n(defn fzprint-justify-width\n  \"Figure the width for a justification of a set of pairs in coll.  \n  Also, decide if it makes any sense to justify the pairs at all.\n  For instance, they all need to be one-line.\"\n  [caller {{:keys [justify?]} caller, :as options} ind coll]\n  (let [firsts (remove nil?\n                 (map #(when (> (count %) 1) (fzprint* options ind (first %)))\n                   coll))\n        #_(def just firsts)\n        style-seq (map (partial style-lines options ind) firsts)\n        #_(def styleseq style-seq)\n        each-one-line? (reduce #(when %1 (= (first %2) 1)) true style-seq)\n        #_(def eol each-one-line?)\n        justify-width (when each-one-line?\n                        (reduce #(max %1 (second %2)) 0 style-seq))]\n    (when justify-width (- justify-width ind))))\n\n(defn fit-within?\n  \"Take a size and a collection of vectors with two or more elements\n  per vector.  The elements are zlocs, the vectors are not.  Return\n  the remaining character count or nil if it for sure doesn't fit.\n  In order to be sure it doesn't fit, this version doesn't assume\n  *any* separators, so it really underestimates the size.\"\n  ([size coll depth]\n   (reduce (fn [size element]\n             (or (if (= depth 0)\n                   (fit-within? size element (inc depth))\n                   (let [remaining (- size (count (zstring element)))]\n                     (when (pos? remaining) remaining)))\n                 (reduced nil)))\n     size\n     coll))\n  ([size coll] (fit-within? size coll 0)))\n\n(defn remove-hangflow\n  \"Convert a hangflow style-vec to a regular style-vec.\"\n  [hf-style-vec]\n  (when hf-style-vec (map second hf-style-vec)))\n\n(defn fzprint-map-two-up\n  \"Accept a sequence of pairs, and map fzprint-two-up across those pairs.\n  If you have :one-line? set, this will return nil if it is way over,\n  but it can't accurately tell exactly what will fit on one line, since\n  it doesn't know the separators and such.  So, :one-line? true is a\n  performance optimization, so it doesn't do a whole huge map just to\n  find out that it could not possibly have fit on one line.  So, this\n  returns a sequence of style-vecs, where the indentation for the\n  stuff inside of the pairs is already there, but the separators of\n  the style-vecs (including indentation and commas) is done by the\n  caller of fzprint-map-two-up. Always returns a sequence of vector pairs:\n  [[:hang <style-vec-for-one-pair>] [:flow <style-vec-for-one-pair>] ...].\n  If you want a style vec instead, call remove-hangflow on the return \n  from fzprint-map-two-up.  This will use one-line?, but not check to see\n  that it actually fits.  If you care about that, then you should check the\n  return yourself.  It will, however, make an estimate of whether or not\n  it will fit and if it clearly doesn't, it will return a nil.\"\n  [caller\n   {{:keys [justify? force-nl?]} caller,\n    :keys [width rightcnt one-line? parallel?],\n    :as options} ind commas? coll]\n  (let [caller-map (caller options)\n        len (count coll)\n        justify-width (when (and justify? (not one-line?))\n                        (fzprint-justify-width caller options ind coll))\n        caller-options (when justify-width (options caller))]\n    (dbg-print options\n               \"fzprint-map-two-up: one-line?\" (:one-line? options)\n               \"justify?:\" justify?)\n    ; If it is one-line? and force-nl? and there is more than one thing,\n    ; this can't work.\n    (when (not (and one-line? force-nl? (> len 1)))\n      #_(def jo [])\n      (loop [justify-width justify-width\n             justify-options\n               (if justify-width\n                 (-> options\n                     (merge-deep {caller (caller-options :justify-hang)})\n                     (merge-deep {:tuning (caller-options :justify-tuning)}))\n                 options)]\n        #_(def jo (conj jo [justify-width justify-options]))\n        (let [beginning-coll (butlast coll)\n              ; If beginning-coll is () because there is only a single pair\n              ; in coll, then this all works -- but only because\n              ; () is truthy, and zpmap returns () which is also truthy.\n              ; I hate relying on the truthy-ness of (), but in this case\n              ; it works out and it would be even more complicated to do\n              ; it another way.\n              beginning-remaining\n                (if one-line? (fit-within? (- width ind) beginning-coll) true)\n              _ (dbg options\n                     \"fzprint-map-two-up: remaining:\" (- width ind)\n                     \"beginning-remaining:\" beginning-remaining)\n              beginning (when beginning-remaining\n                          (zpmap options\n                                 (partial fzprint-two-up\n                                          caller\n                                          justify-options\n                                          ind\n                                          commas?\n                                          justify-width\n                                          nil)\n                                 beginning-coll))\n              ; this line will fix the justify, but not necessarily\n              ; the rest of the problems with hangflow output -- like\n              ; the style-lines below.\n              beginning (if (contains-nil? beginning) nil beginning)\n              end-coll [(last coll)]\n              end-remaining (if one-line?\n                              (and beginning\n                                   (fit-within? (- beginning-remaining rightcnt)\n                                                end-coll))\n                              true)\n              _ (dbg options\n                     \"fzprint-map-two-up: beginning-remaining:\"\n                       beginning-remaining\n                     \"rightcnt:\" rightcnt\n                     \"end-remaining:\" end-remaining)\n              end (when end-remaining\n                    (when-let [end-result (fzprint-two-up caller\n                                                          justify-options\n                                                          ind\n                                                          commas?\n                                                          justify-width\n                                                          :rightmost-pair\n                                                          (first end-coll))]\n                      [end-result]))\n              result (cond (= len 1) end\n                           :else (concat-no-nil beginning end))]\n          (dbg-pr options\n                  \"fzprint-map-two-up: len:\" len\n                  \"(nil? end):\" (nil? end)\n                  \"end:\" end\n                  \"(nil? beginning):\" (nil? beginning)\n                  \"beginning:\" beginning\n                  \"(count end):\" (count end)\n                  \"(count beginnging):\" (count beginning)\n                  \"justify-width:\" justify-width\n                  \"result:\" result)\n          ; if we got a result or we didn't but it wasn't because we\n          ; were trying to justify things\n          (if (or result (not justify-width))\n            result\n            ; try again, without justify-width\n            (recur nil options)))))))\n\n;;\n;; ## Support sorting of map keys\n;;\n\n(defn compare-keys\n  \"Do a key comparison that works well for numbers as well as\n  strings.\"\n  [x y]\n  (cond (and (number? x) (number? y)) (compare x y)\n        :else (compare (str x) (str y))))\n\n(defn compare-ordered-keys\n  \"Do a key comparison that places ordered keys first.\"\n  [key-value zdotdotdot x y]\n  (cond (and (key-value x) (key-value y)) (compare (key-value x) (key-value y))\n        (key-value x) -1\n        (key-value y) +1\n        (= zdotdotdot x) +1\n        (= zdotdotdot y) -1\n        :else (compare-keys x y)))\n\n(defn order-out\n  \"A variety of sorting and ordering options for the output of\n  partition-all-2-nc.  It can sort, which is the default, but if\n  the caller has a key-order vector, it will extract any keys in\n  that vector and place them first (in order) before sorting the\n  other keys.  If sorting is not called for, does nothing.\"\n  [caller\n   {{:keys [sort? sort-in-code? key-order key-value]} caller,\n    :keys [in-code?],\n    :as options} access out]\n  (if (and sort? (if in-code? sort-in-code? true))\n    (sort #((partial compare-ordered-keys (or key-value {}) (zdotdotdot))\n              (zsexpr (access %1))\n              (zsexpr (access %2)))\n          out)\n    out))\n\n(defn pair-element?\n  \"This checks to see if an element should be considered part of a\n  pair if it comes between other elements, and a single element on\n  its own if it would otherwise be the first part of a pair.  Mostly\n  this will trigger on comments, but a #_(...) element will also\n  trigger this, as will a newline if one appears.\"\n  [zloc]\n  (or (zcomment? zloc) (zuneval? zloc) (znewline? zloc)))\n\n(defn middle-element?\n  \"This checks to see if an element should be considered the middle element\n  of a pair.  At some point, we can expand this, but for now there is only\n  one middle element.\"\n  [{:keys [in-code?], :as options} zloc]\n  ;  nil)\n  (when (= in-code? \"condp\") (= (zstring zloc) \":>>\")))\n\n;;\n;; # Ignore keys in maps\n;;\n\n(defn remove-key-seq\n  \"If given a non-collection, simply does a dissoc of the key, but\n  if given a sequence of keys, will remove the final one.\"\n  [m ks]\n  (if (coll? ks)\n    (let [this-key (first ks)\n          next-key (next ks)]\n      (if next-key\n        (let [removed-map (remove-key-seq (get m this-key) (next ks))]\n          (if (empty? removed-map)\n            (dissoc m this-key)\n            (assoc m this-key removed-map)))\n        (dissoc m this-key)))\n    (dissoc m ks)))\n\n(defn ignore-key-seq-silent\n  \"Given a map and a key sequence, remove that key sequence if\n  it appears in the map, and terminate the reduce if it changes\n  the map.\"\n  [m ks]\n  (if (coll? ks)\n    (if (= (get-in m ks :zprint-not-found) :zprint-not-found)\n      m\n      (remove-key-seq m ks))\n    (if (= (get m ks :zprint-not-found) :zprint-not-found) m (dissoc m ks))))\n\n(defn ignore-key-seq\n  \"Given a map and a key sequence, remove that key sequence if\n  it appears in the map leaving behind a key :zprint-ignored, \n  and terminate the reduce if it changes the map.\"\n  [m ks]\n  (if (coll? ks)\n    (if (= (get-in m ks :zprint-not-found) :zprint-not-found)\n      m\n      (assoc-in m ks :zprint-ignored))\n    (if (= (get m ks :zprint-not-found) :zprint-not-found)\n      m\n      (assoc m ks :zprint-ignored))))\n\n(defn map-ignore\n  \"Take a map and remove any of the key sequences specified from it.\n  Note that this only works for sexpressions, not for actual zippers.\"\n  [caller {{:keys [key-ignore key-ignore-silent]} caller, :as options} zloc]\n  (let [ignored-silent (if key-ignore-silent\n                         (reduce ignore-key-seq-silent zloc key-ignore-silent)\n                         zloc)\n        ignored (if key-ignore\n                  (reduce ignore-key-seq ignored-silent key-ignore)\n                  ignored-silent)]\n    ignored))\n\n;;\n;; # Pre-processing for two-up printing\n;;\n\n(defn partition-all-2-nc\n  \"Input is (zseqnws zloc) or (zseqnws-w-nl) where one assumes that\n  these are pairs.  Thus, a seq of zlocs.  Output is a sequence of\n  seqs, where the seqs are usually pairs, but might be single things.\n  Doesn't pair up comments or #_(...) unevaled sexpressions.  The\n  ones before the first part of a pair come as a single element in\n  what would usually be a pair, and the ones between the first and\n  second parts of a pair come inside the pair.  There may be an\n  arbitrary number of elements between the first and second elements\n  of the pair (one per line).  If there are any comments or unevaled\n  sexpressions, don't sort the keys, as we might lose track of where\n  the comments or unevaled s-expressions go.\"\n  [options coll]\n  (when-not (empty? coll)\n    (let [max-length (get-max-length options)]\n      (loop [remaining coll\n             no-sort? nil\n             index 0\n             out (transient [])]\n        (dbg-pr options\n                \"partition-all-2-nc: index:\" index\n                \"no-sort?:\" no-sort?\n                ;  \"out:\" (map (comp zstring first)(persistent! out))\n                \"first remaining:\" (zstring (first remaining))\n                \"second remaining:\" (zstring (second remaining)))\n        (if-not remaining\n          [no-sort? (persistent! out)]\n          (let [[new-remaining pair-vec new-no-sort?]\n                  (cond\n                    (pair-element? (first remaining)) [(next remaining)\n                                                       [(first remaining)] true]\n                    (or (pair-element? (second remaining))\n                        (middle-element? options (second remaining)))\n                      (let [[comment-seq rest-seq]\n                              ;(split-with pair-element? (next remaining))\n                              (split-with #(or (pair-element? %)\n                                               (middle-element? options %))\n                                          (next remaining))]\n                        (if (first rest-seq)\n                          ; We have more to than just a comment, so we can\n                          ; pair it up between two things.\n                          [(next rest-seq)\n                           (into []\n                                 (concat [(first remaining)]\n                                         comment-seq\n                                         [(first rest-seq)])) true]\n                          ; This is the end, don't pair a comment up\n                          ; with something on the left if there isn't\n                          ; something on the right of it.\n                          [(next remaining) [(first remaining)] true]))\n                    (= (count remaining) 1) [(next remaining)\n                                             [(first remaining)] nil]\n                    :else [(next (next remaining))\n                           [(first remaining) (second remaining)] nil])]\n            #_(println \"partition-all-2-nc: count new-remaining:\"\n                       (count new-remaining))\n            (dbg-pr options\n                    \"partition-all-2-nc: pair-vec: first:\" (zstring (first\n                                                                      pair-vec))\n                    \"first tag:\" (ztag (first pair-vec))\n                    \"count:\" (count pair-vec)\n                    \"last:\" (zstring (last pair-vec)))\n            (recur (cond (< (inc index) max-length) new-remaining\n                         (and (= (inc index) max-length) new-remaining)\n                           (list (zdotdotdot))\n                         :else nil)\n                   (or no-sort? new-no-sort?)\n                   (inc index)\n                   (conj! out pair-vec))))))))\n\n;;\n;; ## Multi-up printing pre-processing\n;;\n\n(defn cleave-end\n  \"Take a seq, and if it is contains a single symbol, simply return\n  it in another seq.  If it contains something else, remove any non\n  collections off of the end and return them in their own double seqs,\n  as well as return the remainder (the beginning) as a double seq.\"\n  [coll]\n  (if (or (zsymbol? (first coll)) (zreader-cond-w-symbol? (first coll)))\n    ;(symbol? (first coll))\n    (list coll)\n    (let [rev-seq (reverse coll)\n          [split-non-coll _]\n            ;(split-with (comp not zcoll?) rev-seq)\n            (split-with #(not (or (zcoll? %) (zreader-cond-w-coll? %)))\n                        rev-seq)\n          #_(def sncce split-non-coll)\n          split-non-coll (map list (reverse split-non-coll))\n          remainder (take (- (count coll) (count split-non-coll)) coll)]\n      (if (empty? remainder)\n        split-non-coll\n        (concat (list remainder) split-non-coll)))))\n\n(defn partition-all-sym\n  \"Similar to partition-all-2-nc, but instead of trying to pair things\n  up (modulo comments and unevaled expressions), this begins things\n  with a symbol, and then accumulates collections until the next symbol.\n  Returns a seq of seqs, where the first thing in each internal seq is\n  a protocol and the remaining thing(s) in that seq are the expressions that\n  follow.  If there is a single thing, it is returned in its own internal\n  seq. ((P (foo [this a) (bar-me [this] b) (barx [this y] (+ c y))) ...)\n  Made harder by the fact that the symbol might be inside of a #?() reader\n  conditional.  It handles comments before symbols on the symbol indent, \n  and the comments before the collections on the collection indent.  \n  Since it doesn't know how many collections there are, this is not trivial.  \n  Must be called with a sequence of z-things (these days called a zseq)\"\n  [options modifier-set coll]\n  (dbg-pr options \"partition-all-sym:\" modifier-set)\n  #_(def scoll coll)\n  (dbg options \"partition-all-sym: coll:\" (map zstring coll))\n  (let [part-sym (partition-by\n                   #(or (zsymbol? %) (znil? %) (zreader-cond-w-symbol? %))\n                   coll)\n        split-non-coll (mapcat cleave-end part-sym)]\n    #_(def ps part-sym)\n    #_(def snc split-non-coll)\n    (loop [remaining split-non-coll\n           out (transient [])]\n      #_(prn \"remaining:\" (zprint.repl/pseqzseq remaining))\n      #_(prn \"out:\" (zprint.repl/pseqzseq out))\n      (if (empty? remaining)\n        (do #_(def pasn out) (persistent! out))\n        (let [[next-remaining new-out]\n                (cond\n                  (and (or (zsymbol? (ffirst remaining))\n                           (znil? (ffirst remaining))\n                           (zreader-cond-w-symbol? (ffirst remaining)))\n                       (not (empty? (second remaining)))\n                       ; This keeps a comment after a symbol with no\n                       ; collections from being associated with the previous\n                       ; symbol instead of standing on its own (as it should)\n                       (or (not\n                             (or (= (ztag (first (second remaining))) :comment)\n                                 (= (ztag (first (second remaining)))\n                                    :newline)))\n                           (zcoll? (last (second remaining)))))\n                    ; We have a non-collection in (first remaining) and\n                    ; we might have more than one, either because we just\n                    ; have a bunch of non-colls with no colls\n                    ; or because we have a modifier and then one or more\n                    ; non-colls (possibly with their own modifiers).\n                    (if (= (count (first remaining)) 1)\n                      ; original\n                      (do #_(prn \"a:\")\n                          ; We have a single non-coll, pull the next seq\n                          ; of one or more seqs into a seq with it.\n                          ; This is where we marry up the non-coll with\n                          ; all of its associated colls.\n                          [(nthnext remaining 2)\n                           (conj! out\n                                  (concat (first remaining)\n                                          (second remaining)))])\n                      (do #_(prn \"b:\")\n                          (if (and modifier-set\n                                   (modifier-set (zstring (ffirst remaining))))\n                            (if (= (count (first remaining)) 2)\n                              ; We have exactly two things in\n                              ; (first remaining), and the first one is\n                              ; both a non-coll and a modifier, so we know\n                              ; that the second one is a non-coll, and we\n                              ; know that we have a (second remaining) from\n                              ; above, so we bring the second remaining\n                              ; into the first remaining like we did\n                              ; above\n                              (do #_(prn \"d:\")\n                                  [(nthnext remaining 2)\n                                   (conj! out\n                                          (concat (first remaining)\n                                                  (second remaining)))])\n                              ; We have a modifier as the first thing in a\n                              ; seq of non-colls and then some more non-colls\n                              ; after that (since we don't have exactly two,\n                              ; as that case was caught above).\n                              ; Pull the next one into a seq with it.\n                              ; Do we need to check that the next one is\n                              ; also a non-coll?  That shouldn't be\n                              ; necessary,as you won't get colls in\n                              ;with non-colls.\n                              (do #_(prn \"c:\")\n                                  [(if (next (next (first remaining)))\n                                     (cons (next (next (first remaining)))\n                                           (next remaining))\n                                     (next remaining))\n                                   (conj! out\n                                          (list (ffirst remaining)\n                                                (second (first remaining))))]))\n                            ; we have more than one non-coll in first\n                            ; remaining, so pull one out, and leave the\n                            ; next ones for the next loop\n                            [(cons (next (first remaining)) (next remaining))\n                             (conj! out (list (ffirst remaining)))])))\n                  :else [(next remaining) (conj! out (first remaining))])]\n          (recur next-remaining new-out))))))\n\n(defn rstr-vec\n  \"Create an r-str-vec with the indent appropriate for the r-str if\n  it is preceded by a newline.\"\n  ([options ind zloc r-str r-type]\n   [[r-str (zcolor-map options (or r-type r-str)) (or r-type :right) ind]])\n  ([options ind zloc r-str] (rstr-vec options ind zloc r-str nil)))\n\n(declare interpose-nl-hf)\n(declare fzprint-get-zloc-seq)\n\n(defn fzprint-binding-vec\n  [{{:keys [nl-separator?]} :binding, :as options} ind zloc]\n  (dbg options \"fzprint-binding-vec: ind:\" ind \"zloc:\" (zstring (zfirst zloc)))\n  (let [options (rightmost options)\n        l-str \"[\"\n        r-str \"]\"\n        l-str-vec [[l-str (zcolor-map options l-str) :left]]\n        r-str-vec (rstr-vec options ind zloc r-str)]\n    (dbg-form options\n              \"fzprint-binding-vec exit:\"\n              (if (= (zcount zloc) 0)\n                (concat-no-nil l-str-vec r-str-vec)\n                (concat-no-nil\n                  l-str-vec\n                  (interpose-nl-hf\n                    (:binding options)\n                    (inc ind)\n                    (fzprint-map-two-up\n                      :binding\n                      options\n                      (inc ind)\n                      false\n                      (second (partition-all-2-nc\n                                options\n                                ; This is controlled by the :vector config\n                                ; options, because if we added it to the\n                                ; :binding option, it would not work because\n                                ; the fzprint-list* one line testing doesn't\n                                ; know it is a binding vector, it thinks\n                                ; that it is just a vector.  Alternatively\n                                ; we could probably notice that we were in\n                                ; a :binding fn-type, and force :vector\n                                ; :respect-nl? to be the same as :binding\n                                ; :respect-nl? for the one-line test.  Which\n                                ; would fail if there were some other vector\n                                ; with newlines in it that wasn't the\n                                ; binding vector.  Ultimately this is because\n                                ; :respect-nl? (and :respect-bl?) are only\n                                ; defined for vectors, maps, lists and sets,\n                                ; and that is implemented by changing what\n                                ; gets returned as a zloc-seq.\n                                (fzprint-get-zloc-seq :vector options zloc)))))\n                  r-str-vec)))))\n\n(defn fzprint-hang\n  \"Try to hang something and try to flow it, and then see which is\n  better.  Has hang and flow indents. fzfn is the function to use \n  to do zloc.  Note what fzfn does with the input. Presumably the\n  caller knows what the fzfn does, so it has to count the items\n  itself and pass it in here as zloc-count if it isn't just (zcount zloc).\"\n  [{:keys [one-line? force-eol-blanks?], :as options} caller hindent findent\n   fzfn zloc-count zloc]\n  (dbg options \"fzprint-hang: caller:\" caller)\n  (let [hanging (when (and (not= hindent findent)\n                           ((options caller) :hang?)\n                           ; If it starts with a newline, we aren't hanging\n                           ; it.  Comment, sure, but not newline.\n                           (not (znewline? (first zloc))))\n                  (concat-no-nil [[(str \" \") :none :whitespace 5]]\n                                 (fzfn (in-hang options) hindent zloc)))\n        #_(prn \"fzprint-hang: first hanging:\" (first hanging) (second hanging))\n        hanging (when (not= (nth (second hanging) 2) :comment-inline) hanging)\n        hang-count (or zloc-count (zcount zloc))\n        hr-lines (style-lines options (dec hindent) hanging)\n        ;flow (fzfn options findent zloc)\n       ]\n    (if (or (fzfit-one-line options hr-lines) one-line?)\n      hanging\n      (let [flow (let [result (fzfn options findent zloc)]\n                   (concat-no-nil\n                     ; This will create an end-of-line blanks situation so\n                     ; we can test our ability to see it.  If we weren't\n                     ; intentionally creating end-of-line blanks, we would\n                     ; use prepend-nl here.\n                     (if (if force-eol-blanks? nil (first-nl? result))\n                       [[(str \"\\n\") :none :indent 42]]\n                       [[(str \"\\n\" (blanks findent)) :none :indent 4]])\n                     result))\n            _ (log-lines options \"fzprint-hang: flow:\" findent flow)\n            fd-lines (style-lines options findent flow)\n            _ (dbg-pr options\n                      \"fzprint-hang: ending: hang-count:\" hang-count\n                      \"hanging:\" hanging\n                      \"flow:\" flow)\n            hr-good? (when hanging\n                       (good-enough? caller\n                                     options\n                                     :none-hang\n                                     hang-count\n                                     (- hindent findent)\n                                     hr-lines\n                                     fd-lines))]\n        (if hr-good? hanging flow)))))\n\n(defn fzprint-pairs\n  \"Always prints pairs on a different line from other pairs. Takes a zloc-seq\"\n  [{{:keys [nl-separator? respect-nl?]} :pair, :as options} ind zloc-seq]\n  (dbg-pr options \"fzprint-pairs:\" (zstring (first zloc-seq)))\n  (dbg-form\n    options\n    \"fzprint-pairs: exit:\"\n    (interpose-nl-hf\n      (:pair options)\n      ind\n      (fzprint-map-two-up :pair\n                          options\n                          ind\n                          false\n                          (let [[_ part] (partition-all-2-nc options zloc-seq)]\n                            #_(def fp part)\n                            (dbg-pr options\n                                    \"fzprint-pairs: partition:\"\n                                      (map (comp zstring first) part)\n                                    \"respect-nl?\" respect-nl?)\n                            part)))))\n\n(defn fzprint-extend\n  \"Print things with a symbol and collections following.  Kind of like with\n  pairs, but not quite. Takes a zloc-seq.\"\n  [{{:keys [nl-separator?]} :extend, :as options} ind zloc-seq]\n  #_(def fezloc zloc-seq)\n  (dbg options \"fzprint-extend:\" (zstring (first zloc-seq)))\n  (dbg-form\n    options\n    \"fzprint-extend: exit:\"\n    (interpose-nl-hf\n      (:extend options)\n      ind\n      (fzprint-map-two-up\n        :extend\n        (assoc options :fn-style :fn)\n        ind\n        false\n        (let [part (partition-all-sym options\n                                      (:modifiers (:extend options))\n                                      zloc-seq)]\n          #_(def fe part)\n          (dbg options \"fzprint-extend: partition:\" (map #(map zstring %) part))\n          part)))))\n\n(defn concatv!\n  \"Given a transient vector v, concatenate all of the other\n  elements in all of the remaining collections onto v.\"\n  [v & rest]\n  (loop [cols rest\n         out v]\n    (if cols\n      (recur (next cols)\n             (loop [col (first cols)\n                    out out]\n               (if col (recur (next col) (conj! out (first col))) out)))\n      out)))\n\n(defn fzprint-one-line\n  \"Do a fzprint-seq like thing, but do it incrementally and\n  if it gets too big, return nil.\"\n  [options ind zloc-seq]\n  (dbg-print options \"fzprint-one-line:\")\n  (let [seq-right zloc-seq\n        len (count seq-right)\n        last-index (dec len)\n        gt-1? (> (count seq-right) 1)\n        options (assoc options :one-line? true)]\n    (loop [zloc-seq seq-right\n           new-ind (long ind)\n           index 0\n           out (transient [])]\n      (if (empty? zloc-seq)\n        (do (dbg options \"fzprint-one-line: exiting count:\" (count out))\n            (persistent! out))\n        (let [next-zloc (first zloc-seq)\n              [sep next-options]\n                (cond ; this needs to come first in case there\n                      ; is only one\n                      ; element in the list -- it needs to have\n                      ; the rightcnt\n                      ; passed through\n                  (= index last-index) [(if-not (zero? index)\n                                          [[\" \" :none :whitespace 6]]) options]\n                  (= index 0) [nil (not-rightmost options)]\n                  :else [[[\" \" :none :whitespace 7]] (not-rightmost options)])\n              next-out (fzprint* next-options new-ind next-zloc)\n              _ (log-lines options \"fzprint-one-line:\" new-ind next-out)\n              [line-count max-width :as next-lines]\n                (style-lines options new-ind next-out)]\n          (if-not (fzfit-one-line next-options next-lines)\n            (do (dbg options\n                     \"fzprint-one-line: failed, too wide or too many lines!\")\n                nil)\n            (recur (next zloc-seq)\n                   (inc (long max-width))\n                   (inc index)\n                   (concatv! out sep next-out))))))))\n\n(defn fzprint-seq\n  \"Take a seq of a zloc, created by (zmap identity zloc).  Return\n  a seq of the fzprint* of each element.  No spacing between any\n  of these elements. Note that this is not a style-vec, but a seq\n  of style-vecs of each of the elements.  These would need to be\n  concatenated together to become a style-vec.  ind is either a\n  constant or a seq of indents, one for each element in zloc-seq.\n  Note that right gets evaluated immediately, while left yields a\n  lazy sequence which get evaluated later.\"\n  [options ind zloc-seq]\n  (let [max-length (get-max-length options)\n        len (count zloc-seq)\n        zloc-seq (if (> len max-length)\n                   (concat (take max-length zloc-seq) (list (zdotdotdot)))\n                   zloc-seq)\n        len (count zloc-seq)]\n    (dbg options\n         \"fzprint-seq: (count zloc-seq):\" len\n         \"max-length:\" max-length\n         \"ind:\" ind)\n    (cond\n      (empty? zloc-seq) nil\n      (zero? max-length) [[[\"#?#\" (zcolor-map options :keyword) :element]]]\n      :else (let [left (zpmap options\n                              #(fzprint* (not-rightmost options) %1 %2)\n                              (if (coll? ind) ind (repeat ind))\n                              (butlast zloc-seq))\n                  right [(fzprint* options\n                                   (if (coll? ind) (last ind) ind)\n                                   (last zloc-seq))]]\n              (cond (= len 1) right\n                    :else (concat-no-nil left right))))))\n\n(declare precede-w-nl)\n\n(defn fzprint-flow-seq\n  \"Takes zloc-seq, a seq of a zloc, created by (zmap identity zloc),\n  and returns a style-vec of the result.  Either it fits on one\n  line, or it is rendered on multiple lines.  You can force multiple\n  lines with force-nl?. If the seq is empty, returns :noseq, which\n  is what you give concat-no-nil if you want this to just disappear.\n  If you want it to do less than everything in the original zloc,\n  modify the result of (zmap identity zloc) to just contain what\n  you want to print. ind is either a single indent, or a seq of\n  indents, one for each element in zloc-seq.  Don't concatenate an\n  indent/newline on to the beginning of the output from this routine.\n  Let this routine do it for you, as it needs to know one is there\n  in order to properly deal with any newlines in the actual stream.\n  Else you will get two where you only should have one.\"\n  ([options ind zloc-seq force-nl? nl-first?]\n   (dbg-pr options\n           \"fzprint-flow-seq: count zloc-seq:\" (count zloc-seq)\n           \"nl-first?\" nl-first?\n           \"zloc-seq:\" (map zstring zloc-seq))\n   (let [coll-print (fzprint-seq options ind zloc-seq)\n         ; If we are force-nl?, then don't bother trying one-line\n         one-line (apply concat-no-nil\n                    (interpose [[\" \" :none :whitespace 8]] coll-print))\n         _ (log-lines options \"fzprint-flow-seq:\" ind one-line)\n         one-line-lines (style-lines options ind one-line)]\n     (dbg-pr options \"fzprint-flow-seq: coll-print:\" coll-print)\n     (dbg-form options\n               \"fzprint-flow-seq: exit:\"\n               (if (and (not force-nl?) (fzfit-one-line options one-line-lines))\n                 one-line\n                 (if (not (empty? coll-print))\n                   (apply concat-no-nil\n                     (precede-w-nl options ind coll-print (not nl-first?)))\n                   :noseq)))))\n  ([options ind zloc-seq] (fzprint-flow-seq options ind zloc-seq nil nil))\n  ([options ind zloc-seq force-nl?]\n   (fzprint-flow-seq options ind zloc-seq force-nl? nil)))\n\n(defn fzprint-hang-one\n  \"Try out the given zloc, and if it fits on the current line, just\n  do that. It might fit on the same line, as this may not be the rest\n  of the list that we are printing. If not, check it out with good-enough?\n  and do the best you can.  Three choices, really: fits on same line, \n  does ok as hanging, or better with flow. hindent is hang-indent, and \n  findent is flow-indent, and each contains the initial separator.  \n  Might be nice if the fn-style actually got sent to this fn.\"\n  [caller {:keys [one-line? width], {:keys [hang-avoid]} caller, :as options}\n   hindent findent zloc]\n  (dbg-pr options\n          \"fzprint-hang-one:\" (zstring zloc)\n          \" hindent:\" hindent\n          \"findent:\" findent)\n  (when (:dbg-hang options)\n    (println (dots (:pdepth options))\n             \"h1 caller:\"\n             caller\n             (zstring (if (zcoll? zloc) (zfirst zloc) zloc))))\n  (let [local-options (if (and (not one-line?) (not (:hang? (caller options))))\n                        (assoc options :one-line? true)\n                        options)\n        ; If we don't have an hindent, we better not be trying to hang\n        ; things -- in this case, we'll just flow.\n        hindent (or hindent findent)\n        hang-count (zcount zloc)\n        ; This implements :hang-avoid for fzprint-hang-one, instead of just\n        ; for fzprint-hang-remaining.  It didn't change the tests, but\n        ; removed some silly formatting when using :arg2 and small widths.\n        hanging (when (and (not= hindent findent)\n                           (or (not hang-avoid)\n                               (< hang-count (* (- width hindent) hang-avoid))))\n                  (fzprint* (in-hang local-options) hindent zloc))\n        hanging (concat-no-nil [[\" \" :none :whitespace 9]] hanging)\n        _ (log-lines options \"fzprint-hang-one: hanging:\" (dec hindent) hanging)\n        hr-lines (style-lines options (dec hindent) hanging)]\n    _\n    (dbg options\n         \"fzprint-hang-one: hr-lines:\" hr-lines\n         \"hang-count:\" hang-count)\n    ; if hanging is nil and one-line? is true, then we didn't fit\n    ; and should exit\n    ;\n    ; if hanging is nil and one-line? is nil, and hang? nil,\n    ; then we we don't hang and this didn't fit on the same\n    ; line and we should contine\n    ;\n    ; if hanging is true, then if one-line? is true and fzfit-one-line\n    ; is true, then we just go with hanging\n    ;\n    ; if hanging is true and if fzfit-one-line is true, then we go\n    ; with hanging.  Which is probably the same as just above.\n    ;\n    ; if hanging is true and if one-line? is nil, and if hang? is\n    ; nil, and fzfit-one-line is true then it fit on one line and we\n    ; should go with hanging.\n    ;\n    ;\n    ; Summary:\n    ;\n    ; go with hanging if:\n    ;\n    ;  o fzfit-one-line true\n    ;  o one-line? true\n    ;\n    ; Otherwise, see about flow too\n    ;\n    (if (or (fzfit-one-line options hr-lines) one-line?)\n      hanging\n      (let [flow (prepend-nl options findent (fzprint* options findent zloc))\n            _ (log-lines options \"fzprint-hang-one: flow:\" findent flow)\n            fd-lines (style-lines options findent flow)\n            _ (dbg options \"fzprint-hang-one: fd-lines:\" fd-lines)\n            _ (dbg options\n                   \"fzprint-hang-one: ending: hang-count:\" hang-count\n                   \"hanging:\" (pr-str hanging)\n                   \"flow:\" (pr-str flow))\n            hr-good? (and (:hang? (caller options))\n                          (good-enough? caller\n                                        options\n                                        :none-hang-one\n                                        hang-count\n                                        (- hindent findent)\n                                        hr-lines\n                                        fd-lines))]\n        (if hr-good? hanging flow)))))\n\n;;\n;; # Constant pair support\n;;\n\n(declare zcomment-or-newline?)\n\n; This, you might think, would be faster.  But in reality it is almost\n; exactly the same as the version that reverses the list.\n; And even a bit more complex to understand, so we'll leave it\n; here for additional possible optimizations and simplifications later.\n\n#_(defn count-constant-pairs-new\n    \"Given a seq of zlocs, work backwards from the end, and see how\n  many elements are pairs of constants (using zconstant?).  So that\n  (... :a (stuff) :b (bother)) returns 4, since both :a and :b are\n  zconstant? true. This is made more difficult by having to skip\n  comments along the way as part of the pair check, but keep track\n  of the ones we skip so the count is right in the end.  We don't\n  expect any spaces in this but newlines must be handled, because \n  this seq should have been produced by zmap or its equivalent.\n  Returns two things: [paired-item-count actual-paired-items],\n  where paired-item-count is the number of things from the end of\n  the seq you have to trim off to get the constant pairs included,\n  and the actual-paired-items is the count of the items to be checked\n  against the constant-pair-min (which is exclusive of comments and\n  newlines).  \"\n    [zloc-seq]\n    (let [zloc-seq (if (vector? zloc-seq) zloc-seq (into [] zloc-seq))\n          len (count zloc-seq)\n          last-element-idx (dec len)]\n      ; If we don't have at least two elements, we aren't doing anything useful\n      (if (not (pos? last-element-idx))\n        [0 0]\n        (loop [idx last-element-idx\n               element-count 0\n               paired-element-count 0\n               ; since it is reversed, we need a constant every second element\n               constant-required? nil\n               pair-size 0\n               actual-pair-size 0]\n          (let [element (nth zloc-seq idx)]\n            #_(prn \"count-constant-pairs: element-count:\" element-count\n                   \"paired-element-count:\" paired-element-count\n                   \"constant-required:\" constant-required?\n                   \"pair-size:\" pair-size\n                   \"actual-pair-size:\" actual-pair-size\n                   \"element:\" (zstring element))\n            (let [comment-or-newline? (zcomment-or-newline? element)]\n              (if (and (not comment-or-newline?)\n                       constant-required?\n                       (not (zconstant? element)))\n                ; we counted the right-hand and any comments of this pair, but\n                ; it isn't a pair so exit now with whatever we have so far\n                [(- element-count pair-size)\n                 (- paired-element-count actual-pair-size)]\n                (let [element-count (inc element-count)\n                      paired-element-count (if comment-or-newline?\n                                             paired-element-count\n                                             (inc paired-element-count))\n                      pair-size (if (and constant-required?\n                                         (not comment-or-newline?))\n                                  ; must be a constant, so start count over\n                                  0\n                                  (inc pair-size))\n                      actual-pair-size (if (and constant-required?\n                                                (not comment-or-newline?))\n                                         ; start count of actual pairs over as\n                                         ; well\n                                         0\n                                         (if comment-or-newline?\n                                           ; we are only counting actual pairs\n                                           ; here\n                                           actual-pair-size\n                                           (inc actual-pair-size)))]\n                  ; Are we finished?\n                  (if (zero? idx)\n                    ; Yes, remove potential elements of this pair, since we\n                    ; haven't\n                    ; seen the end of it, and return\n                    [(- element-count pair-size)\n                     (- paired-element-count actual-pair-size)]\n                    ; Not yet finished\n                    (recur (dec idx)\n                           element-count\n                           paired-element-count\n                           (if comment-or-newline?\n                             constant-required?\n                             (not constant-required?))\n                           pair-size\n                           actual-pair-size))))))))))\n\n(defn count-constant-pairs\n  \"Given a seq of zlocs, work backwards from the end, and see how\n  many elements are pairs of constants (using zconstant?).  So that\n  (... :a (stuff) :b (bother)) returns 4, since both :a and :b are\n  zconstant? true. This is made more difficult by having to skip\n  comments along the way as part of the pair check, but keep track\n  of the ones we skip so the count is right in the end.  We don't\n  expect any spaces in this but newlines must be handled, because \n  this seq should have been produced by zmap or its equivalent.\n  Returns two things: [paired-item-count actual-paired-items],\n  where paired-item-count is the number of things from the end of\n  the seq you have to trim off to get the constant pairs included,\n  and the actual-paired-items is the count of the items to be checked\n  against the constant-pair-min (which is exclusive of comments and\n  newlines).\"\n  [zloc-seq]\n  (loop [zloc-seq-rev (reverse zloc-seq)\n         element-count 0\n         paired-element-count 0\n         ; since it is reversed, we need a constant every second element\n         constant-required? nil\n         pair-size 0\n         actual-pair-size 0]\n    (let [element (first zloc-seq-rev)]\n      #_(prn \"count-constant-pairs: element-count:\" element-count\n             \"paired-element-count:\" paired-element-count\n             \"constant-required:\" constant-required?\n             \"pair-size:\" pair-size\n             \"actual-pair-size:\" actual-pair-size\n             \"element:\" (zstring element))\n      (if (empty? zloc-seq-rev)\n        ; remove potential elements of this pair, since we haven't\n        ; seen the end of it, and return\n        [(- element-count pair-size) (- paired-element-count actual-pair-size)]\n        (let [comment-or-newline? (zcomment-or-newline? element)]\n          (if (and (not comment-or-newline?)\n                   constant-required?\n                   (not (zconstant? element)))\n            ; we counted the right-hand and any comments of this pair, but it\n            ; isn't a pair so exit now with whatever we have so far\n            [(- element-count pair-size)\n             (- paired-element-count actual-pair-size)]\n            (recur (next zloc-seq-rev)\n                   (inc element-count)\n                   (if comment-or-newline?\n                     paired-element-count\n                     (inc paired-element-count))\n                   (if comment-or-newline?\n                     constant-required?\n                     (not constant-required?))\n                   (if (and constant-required? (not comment-or-newline?))\n                     ; must be a constant, so start count over\n                     0\n                     (inc pair-size))\n                   (if (and constant-required? (not comment-or-newline?))\n                     ; start count of actual pairs over as well\n                     0\n                     (if comment-or-newline?\n                       ; we are only counting actual pairs here\n                       actual-pair-size\n                       (inc actual-pair-size))))))))))\n\n(defn constant-pair\n  \"Argument is a zloc-seq.  Output is a [pair-seq non-paired-item-count],\n  if any.  If there are no pair-seqs, pair-seq must be nil, not an\n  empty seq.  This will largely ignore newlines and comments.\"\n  [caller {{:keys [constant-pair? constant-pair-min]} caller, :as options}\n   zloc-seq]\n  (if constant-pair?\n    (let [[paired-item-count actual-paired-items] (count-constant-pairs\n                                                    zloc-seq)\n          non-paired-item-count (- (count zloc-seq) paired-item-count)\n          _ (dbg options\n                 \"constant-pair: non-paired-items:\" non-paired-item-count\n                 \"paired-item-count:\" paired-item-count\n                 \"actual-paired-items:\" actual-paired-items)\n          pair-seq (when (>= actual-paired-items constant-pair-min)\n                     (drop non-paired-item-count zloc-seq))]\n      [pair-seq non-paired-item-count])\n    [nil (count zloc-seq)]))\n\n;;\n;; # Take into account constant pairs\n;;\n\n(declare interpose-either-nl-hf)\n\n(declare fzprint-hang-remaining)\n\n(defn zcomment-or-newline?\n  \"If this zloc is a comment or a newline, return true.\"\n  [zloc]\n  (or (zcomment? zloc) (znewline? zloc)))\n\n(defn ensure-start-w-nl\n  \"Given a style-vec, ensure it starts with a newline.  If it doesn't,\n  then put one in.  We could take the whole newline, but the indent is\n  really the only unique thing.\"\n  [ind style-vec]\n  #_(def eswn style-vec)\n  #_(prn \"ensure-start-w-nl:\" style-vec)\n  (let [element-type (nth (first style-vec) 2)]\n    #_(prn \"ensure-start-w-nl:\" element-type)\n    (if (or (= element-type :newline) (= element-type :indent))\n      style-vec\n      ; Don't need prepend-nl, since we wouldn't be doing this if there\n      ; was a newline on the front of style-ec\n      (concat-no-nil [[(str \"\\n\" (blanks ind)) :none :indent 6]] style-vec))))\n\n(defn ensure-end-w-nl\n  \"Given a style-vec, ensure it ends with a newline.  If it doesn't,\n  then put one in.\"\n  [ind style-vec]\n  #_(def eewn style-vec)\n  #_(prn \"ensure-end-w-nl:\" style-vec)\n  (let [element-type (nth (last style-vec) 2)]\n    #_(prn \"ensure-end-w-nl:\" element-type)\n    (if (or (= element-type :newline) (= element-type :indent))\n      style-vec\n      (concat-no-nil style-vec [[(str \"\\n\" (blanks ind)) :none :indent 7]]))))\n\n\n; This version does hang first, and if it passes use-hang?, it\n; doesn't bother to do flow.\n\n(defn fzprint-hang-remaining\n  \"zloc-seq is a seq of zlocs of a collection.  We already know\n  that the given zloc won't fit on the current line. [Besides, we\n  ensure that if there are two things remaining anyway. ???] So\n  now, try hanging and see if that is better than flow.  Unless\n  :hang? is nil, in which case we will just flow.  hindent is\n  hang-indent, and findent is flow-indent. This should never be\n  called with :one-line because this is only called from fzprint-list*\n  after the one-line processing is done. If the hindent equals the\n  flow indent, then just do flow.  Do only zloc-count non-whitespace\n  elements of zloc-seq if it exists.\"\n  ([caller\n    {:keys [dbg? width],\n     {:keys [hang? constant-pair? constant-pair-min hang-avoid hang-expand\n             hang-diff nl-separator? respect-nl?]}\n       caller,\n     :as options} hindent findent zloc-seq fn-style zloc-count]\n   (when (:dbg-hang options)\n     (println (dots (:pdepth options)) \"hr:\" (zstring (first zloc-seq))))\n   (dbg-pr options\n           \"fzprint-hang-remaining first:\" (zstring (first zloc-seq))\n           \"hindent:\" hindent\n           \"findent:\" findent\n           \"caller:\" caller\n           \"nl-separator?:\" nl-separator?\n           \"(count zloc-seq):\" (count zloc-seq))\n   ; (in-hang options) slows things down here, for some reason\n   (let [seq-right zloc-seq\n         seq-right (if zloc-count (take zloc-count seq-right) seq-right)\n         [pair-seq non-paired-item-count]\n           (constant-pair caller options seq-right)\n         _ (dbg options\n                \"fzprint-hang-remaining count pair-seq:\"\n                (count pair-seq))\n         #_(dbg options\n                \"fzprint-hang-remaining: *=*=*=*=*=*\" (zstring (first zloc-seq))\n                \"hindent:\" hindent\n                \"findent:\" findent\n                \"caller:\" caller\n                \"hang?\" hang?\n                \"hang-diff\" hang-diff)\n         ; Now determine if there is any point in doing a hang, because\n         ; if the flow is beyond the expand limit, there is really no\n         ; chance that the hang is not beyond the expand limit.\n         ; This is what good-enough? does:\n         ;  (<= (/ (dec p-lines) p-count) hang-expand)\n         ;  Also need to account for the indent diffs.\n         ; Would be nice to move this into a common routine, since this\n         ; duplicates logic in good-enough?\n         ;\n         ; Yes, and this caused a problem when I put in the\n         ; hang-if-equal-flow? option in good-enough, so that now\n         ; we can't cancel the hang even though we are beyond the hang-expand\n         ; because the hang might be the same as the flow, and in that case\n         ; we don't really care how long the hang-expand is. We could make\n         ; this a feature, by having a large-ish hang-expand and having it\n         ; override hang-if-equal-flow.  If we do that, we have to reorder\n         ; the checks in good-enough to put the hang-expand check first.\n         ; I can't see any great reason for doing a flow if the hang and\n         ; flow are equal, though, so we won't do that now.  And this\n         ; code comes out.\n         ;\n         #_#_[flow flow-lines] (zat options flow) ; PT\n         _ (dbg options\n                \"fzprint-hang-remaining: first hang?\" hang?\n                \"hang-avoid\" hang-avoid\n                \"findent:\" findent\n                \"hindent:\" hindent\n                \"(count seq-right):\" (count seq-right)\n                \"thing:\" (when hang-avoid (* (- width hindent) hang-avoid)))\n         hang? (and\n                 hang?\n                 ; This is a key for \"don't hang no matter what\", it isn't\n                 ; about making it prettier. People call this routine with\n                 ; these values equal to ensure that it always flows.\n                 (not= hindent findent)\n                 ; This is not the original, below.\n                 ; If we are doing respect-nl?, then the count of seq-right\n                 ; is going to be a lot more, even if it doesn't end up\n                 ; looking different than before.  So, perhaps we should\n                 ; adjust hang-avoid here?  Perhaps double it or something?\n                 (or (not hang-avoid)\n                     (< (count seq-right) (* (- width hindent) hang-avoid)))\n                 ; If the first thing in the flow is a comment, maybe we\n                 ; shouldn't be hanging anything?\n                 #_(not= (nth (first flow) 2) :comment-inline) ; PT\n                 ;flow-lines\n                 ;;TODO make this uneval!!!\n                 #_(or (<= (- hindent findent) hang-diff)\n                       (<= (/ (dec (first flow-lines)) (count seq-right))\n                           hang-expand)))\n         _ (dbg options \"fzprint-hang-remaining: second hang?\" hang?)\n         hanging\n           (#?@(:clj [zfuture options]\n                :cljs [do])\n            (let [hang-result\n                    (when hang?\n                      (if-not pair-seq\n                        ; There are no paired elements\n                        (fzprint-flow-seq (in-hang options)\n                                          hindent\n                                          seq-right\n                                          :force-nl\n                                          nil ;nl-first?\n                        )\n                        (if (not (zero? non-paired-item-count))\n                          (concat-no-nil\n                            ; The elements that are not paired\n                            (dbg-form options\n                                      \"fzprint-hang-remaining: mapv:\"\n                                      (ensure-end-w-nl\n                                        hindent\n                                        (fzprint-flow-seq\n                                          (not-rightmost (in-hang options))\n                                          hindent\n                                          (take non-paired-item-count seq-right)\n                                          :force-nl\n                                          nil ;nl-first?\n                                        )))\n                            ; The elements that are paired\n                            (dbg-form options\n                                      \"fzprint-hang-remaining: fzprint-hang:\"\n                                      (fzprint-pairs (in-hang options)\n                                                     hindent\n                                                     pair-seq)))\n                          ; All elements are paired\n                          (fzprint-pairs (in-hang options) hindent pair-seq))))]\n              [hang-result (style-lines options hindent hang-result)]))\n         ; We used to calculate hang-count by doing the hang an then counting\n         ; the output.  But ultimately this is simple a series of map calls\n         ; to the elements of seq-right, so we go right to the source for this\n         ; number now.  That let's us move the interpose calls above this\n         ; point.\n         [hanging [hanging-line-count :as hanging-lines]] (zat options hanging)\n         hang-count (count seq-right)\n         flow?\n           (not\n             (use-hang? caller options hindent hang-count hanging-line-count))\n         #_(inc-pass-count)\n         flow\n           (when flow?\n             (#?@(:clj [zfuture options]\n                  :cljs [do])\n              (let [flow-result (if-not pair-seq\n                                  ; We don't have any constant pairs\n                                  (fzprint-flow-seq options\n                                                    findent\n                                                    seq-right\n                                                    :force-nl\n                                                    :nl-first)\n                                  (if (not (zero? non-paired-item-count))\n                                    ; We have constant pairs, ; but they follow\n                                    ; some stuff that isn't paired.\n                                    ; Do the elements that are not pairs\n                                    (concat-no-nil\n                                      (ensure-end-w-nl\n                                        findent\n                                        (fzprint-flow-seq\n                                          (not-rightmost options)\n                                          findent\n                                          (take non-paired-item-count seq-right)\n                                          :force-nl\n                                          :nl-first))\n                                      ; The elements that are constant pairs\n                                      (fzprint-pairs options findent pair-seq))\n                                    ; This code path is where we have all\n                                    ; constant\n                                    ; pairs.\n                                    (fzprint-pairs options findent pair-seq)))]\n                ; Skip the first line when doing the calcuation so that\n                ; good-enough doesn't change the layout from the original\n                [flow-result\n                 (style-lines\n                   options\n                   findent\n                   (if (not pair-seq) (next flow-result) flow-result))])))\n         [flow flow-lines] (when flow (zat options flow)) ; PT\n         _ (log-lines options\n                      \"fzprint-hang-remaining: hanging:\"\n                      hindent\n                      hanging)\n         _ (dbg options\n                \"fzprint-hang-remaining: hanging-lines:\" hanging-lines\n                \"hang-count:\" hang-count)]\n     (dbg options \"fzprint-hang-remaining: flow-lines:\" flow-lines)\n     (when dbg?\n       (if (zero? hang-count)\n         (println \"hang-count = 0:\" (str (map zstring zloc-seq)))))\n     (log-lines options \"fzprint-hang-remaining: flow\" findent flow)\n     ; If we did hang and not flow, then we better use it.\n     (if (and hanging-lines (not flow-lines))\n       (if (first-nl? hanging)\n         hanging\n         (concat-no-nil [[\" \" :none :whitespace 10]] hanging))\n       (when flow-lines\n         (if (good-enough? caller\n                           options\n                           fn-style\n                           hang-count\n                           (- hindent findent)\n                           hanging-lines\n                           flow-lines)\n           ; If hanging starts with a newline, don't put a blank at the\n           ; end of the previous line.\n           (if (first-nl? hanging)\n             hanging\n             (concat-no-nil [[\" \" :none :whitespace 10]] hanging))\n           (ensure-start-w-nl findent flow))))))\n  ([caller options hindent findent zloc fn-style]\n   (fzprint-hang-remaining caller options hindent findent zloc fn-style nil)))\n\n; This version overlaps hang and flow, which can run into trouble when\n; you get very deep -- it runs out of threads.  But we'll keep it here\n; just for illustrative purposes, since when it works, it is pretty fast.\n#_(defn fzprint-hang-remaining-overlap\n    \"zloc-seq is a seq of zlocs of a collection.  We already know\n  that the given zloc won't fit on the current line. [Besides, we\n  ensure that if there are two things remaining anyway. ???] So\n  now, try hanging and see if that is better than flow.  Unless\n  :hang? is nil, in which case we will just flow.  hindent is\n  hang-indent, and findent is flow-indent. This should never be\n  called with :one-line because this is only called from fzprint-list*\n  after the one-line processing is done. If the hindent equals the\n  flow indent, then just do flow.  Do only zloc-count non-whitespace\n  elements of zloc-seq if it exists.\"\n    ([caller\n      {:keys [dbg? width],\n       {:keys [hang? constant-pair? constant-pair-min hang-avoid hang-expand\n               hang-diff nl-separator? respect-nl?]}\n         caller,\n       :as options} hindent findent zloc-seq fn-style zloc-count]\n     (when (:dbg-hang options)\n       (println (dots (:pdepth options)) \"hr:\" (zstring (first zloc-seq))))\n     (dbg-pr options\n             \"fzprint-hang-remaining first:\" (zstring (first zloc-seq))\n             \"hindent:\" hindent\n             \"findent:\" findent\n             \"caller:\" caller\n             \"nl-separator?:\" nl-separator?\n             \"(count zloc-seq):\" (count zloc-seq))\n     ; (in-hang options) slows things down here, for some reason\n     (let [seq-right zloc-seq\n           seq-right (if zloc-count (take zloc-count seq-right) seq-right)\n           [pair-seq non-paired-item-count]\n             (constant-pair caller options seq-right)\n           _ (dbg options\n                  \"fzprint-hang-remaining count pair-seq:\"\n                  (count pair-seq))\n           flow\n             (#?@(:clj [zfuture options]\n                  :cljs [do])\n              (let [flow-result (if-not pair-seq\n                                  ; We don't have any constant pairs\n                                  (fzprint-flow-seq options\n                                                    findent\n                                                    seq-right\n                                                    :force-nl\n                                                    :nl-first)\n                                  (if (not (zero? non-paired-item-count))\n                                    ; We have constant pairs, ; but they follow\n                                    ; some stuff that isn't paired.\n                                    ; Do the elements that are not pairs\n                                    (concat-no-nil\n                                      (ensure-end-w-nl\n                                        findent\n                                        (fzprint-flow-seq\n                                          (not-rightmost options)\n                                          findent\n                                          (take non-paired-item-count seq-right)\n                                          :force-nl\n                                          :nl-first))\n                                      ; The elements that are constant pairs\n                                      (fzprint-pairs options findent pair-seq))\n                                    ; This code path is where we have all\n                                    ; constant\n                                    ; pairs.\n                                    (fzprint-pairs options findent pair-seq)))]\n                ; Skip the first line when doing the calcuation so that\n                ; good-enough doesn't change the layout from the original\n                [flow-result\n                 (style-lines\n                   options\n                   findent\n                   (if (not pair-seq) (next flow-result) flow-result))]))\n           #_(dbg options\n                  \"fzprint-hang-remaining: *=*=*=*=*=*\" (zstring (first\n                                                                   zloc-seq))\n                  \"hindent:\" hindent\n                  \"findent:\" findent\n                  \"caller:\" caller\n                  \"hang?\" hang?\n                  \"hang-diff\" hang-diff)\n           ; Now determine if there is any point in doing a hang, because\n           ; if the flow is beyond the expand limit, there is really no\n           ; chance that the hang is not beyond the expand limit.\n           ; This is what good-enough? does:\n           ;  (<= (/ (dec p-lines) p-count) hang-expand)\n           ;  Also need to account for the indent diffs.\n           ; Would be nice to move this into a common routine, since this\n           ; duplicates logic in good-enough?\n           ;\n           ; Yes, and this caused a problem when I put in the\n           ; hang-if-equal-flow? option in good-enough, so that now\n           ; we can't cancel the hang even though we are beyond the hang-expand\n           ; because the hang might be the same as the flow, and in that case\n           ; we don't really care how long the hang-expand is. We could make\n           ; this a feature, by having a large-ish hang-expand and having it\n           ; override hang-if-equal-flow.  If we do that, we have to reorder\n           ; the checks in good-enough to put the hang-expand check first.\n           ; I can't see any great reason for doing a flow if the hang and\n           ; flow are equal, though, so we won't do that now.  And this\n           ; code comes out.\n           ;\n           #_#_[flow flow-lines] (zat options flow) ; PT\n           _ (dbg options\n                  \"fzprint-hang-remaining: first hang?\" hang?\n                  \"hang-avoid\" hang-avoid\n                  \"findent:\" findent\n                  \"hindent:\" hindent\n                  \"(count seq-right):\" (count seq-right)\n                  \"thing:\" (when hang-avoid (* (- width hindent) hang-avoid)))\n           hang? (and\n                   hang?\n                   ; This is a key for \"don't hang no matter what\", it isn't\n                   ; about making it prettier. People call this routine with\n                   ; these values equal to ensure that it always flows.\n                   (not= hindent findent)\n                   ; This is not the original, below.\n                   ; If we are doing respect-nl?, then the count of seq-right\n                   ; is going to be a lot more, even if it doesn't end up\n                   ; looking different than before.  So, perhaps we should\n                   ; adjust hang-avoid here?  Perhaps double it or something?\n                   (or (not hang-avoid)\n                       (< (count seq-right) (* (- width hindent) hang-avoid)))\n                   ; If the first thing in the flow is a comment, maybe we\n                   ; shouldn't be hanging anything?\n                   #_(not= (nth (first flow) 2) :comment-inline) ; PT\n                   ;flow-lines\n                   ;;TODO make this uneval!!!\n                   #_(or (<= (- hindent findent) hang-diff)\n                         (<= (/ (dec (first flow-lines)) (count seq-right))\n                             hang-expand)))\n           _ (dbg options \"fzprint-hang-remaining: second hang?\" hang?)\n           hanging\n             (#?@(:clj [zfuture options]\n                  :cljs [do])\n              (let [hang-result\n                      (when hang?\n                        (if-not pair-seq\n                          ; There are no paired elements\n                          (fzprint-flow-seq (in-hang options)\n                                            hindent\n                                            seq-right\n                                            :force-nl\n                                            nil ;nl-first?\n                          )\n                          (if (not (zero? non-paired-item-count))\n                            (concat-no-nil\n                              ; The elements that are not paired\n                              (dbg-form\n                                options\n                                \"fzprint-hang-remaining: mapv:\"\n                                (ensure-end-w-nl\n                                  hindent\n                                  (fzprint-flow-seq\n                                    (not-rightmost (in-hang options))\n                                    hindent\n                                    (take non-paired-item-count seq-right)\n                                    :force-nl\n                                    nil ;nl-first?\n                                  )))\n                              ; The elements that are paired\n                              (dbg-form options\n                                        \"fzprint-hang-remaining: fzprint-hang:\"\n                                        (fzprint-pairs (in-hang options)\n                                                       hindent\n                                                       pair-seq)))\n                            ; All elements are paired\n                            (fzprint-pairs (in-hang options)\n                                           hindent\n                                           pair-seq))))]\n                [hang-result (style-lines options hindent hang-result)]))\n           ; We used to calculate hang-count by doing the hang an then counting\n           ; the output.  But ultimately this is simple a series of map calls\n           ; to the elements of seq-right, so we go right to the source for this\n           ; number now.  That let's us move the interpose calls above this\n           ; point.\n           [hanging hanging-lines] (zat options hanging)\n           [flow flow-lines] (zat options flow) ; PT\n           hang-count (count seq-right)\n           _ (log-lines options\n                        \"fzprint-hang-remaining: hanging:\"\n                        hindent\n                        hanging)\n           _ (dbg options\n                  \"fzprint-hang-remaining: hanging-lines:\" hanging-lines\n                  \"hang-count:\" hang-count)]\n       (dbg options \"fzprint-hang-remaining: flow-lines:\" flow-lines)\n       (when dbg?\n         (if (zero? hang-count)\n           (println \"hang-count = 0:\" (str (map zstring zloc-seq)))))\n       (log-lines options \"fzprint-hang-remaining: flow\" findent flow)\n       (when flow-lines\n         (if (good-enough? caller\n                           options\n                           fn-style\n                           hang-count\n                           (- hindent findent)\n                           hanging-lines\n                           flow-lines)\n           ; If hanging starts with a newline, don't put a blank at the\n           ; end of the previous line.\n           (if (first-nl? hanging)\n             hanging\n             (concat-no-nil [[\" \" :none :whitespace 10]] hanging))\n           (ensure-start-w-nl findent flow)))))\n    ([caller options hindent findent zloc fn-style]\n     (fzprint-hang-remaining caller options hindent findent zloc fn-style nil)))\n\n;;\n;; # Find out and print what comes before the next element\n;;\n\n(defn fzprint-get-zloc-seq\n  \"Get the zloc seq, with or without newlines, as indicated by the options.\"\n  [caller options zloc]\n  (let [caller-options (caller options)\n        zloc-seq (cond (:respect-nl? caller-options) (zmap-w-nl identity zloc)\n                       (:respect-bl? caller-options) (zmap-w-bl identity zloc)\n                       :else (zmap identity zloc))]\n    (dbg-pr options \"fzprint-get-zloc-seq:\" (map zstring zloc-seq))\n    zloc-seq))\n\n(defn newline-or-comment?\n  \"Given an zloc, is it a newline or a comment?\"\n  [zloc]\n  (when zloc\n    (let [zloc-tag (ztag zloc)]\n      (or (= zloc-tag :newline) (= zloc-tag :comment)))))\n\n(defn remove-last-newline\n  \"Given a seq of style-vecs, look at the last one, and if it is a\n  :newline, then remove it.  But the last one might be a single\n  one, in which case we will remove the whole thing, and it might be\n  the last one in a sequence, in which case we will remove just that\n  one.  If there is nothing left, return [[[\\\"\\\" :none :none]]].\"\n  [ssv]\n  #_(prn \"remove-last-newline:\" ssv)\n  (let [last-style-vec (last ssv)]\n    (if-not (= (nth (last last-style-vec) 2) :newline)\n      ssv\n      (let [last-len (count last-style-vec)\n            total-len (count ssv)\n            remove-one\n              (concat (butlast ssv)\n                      (if (= last-len 1) [] (vector (butlast last-style-vec))))]\n        (if (empty? remove-one) [[[\"\" :none :none]]] remove-one)))))\n\n(defn remove-one-newline\n  \"Given a single style-vec, look at the last element, and if it is a\n  :newline, remove it.  If there is nothing left, return :noseq\"\n  [style-vec]\n  #_(prn \"remove-one-newline:\" style-vec)\n  (let [last-style-vec (last style-vec)]\n    (if-not (= (nth last-style-vec 2) :newline)\n      style-vec\n      (let [remaining (butlast style-vec)]\n        (if (empty? remaining) :noseq remaining)))))\n\n(defn add-newline-to-comment\n  \"Given [[[\\\";stuff\\\" :none :comment]]] or \n  [[[\\\";bother\\\" :none :comment-inline 1]]] add [\\\"\\n\\\" :none :newline]\n  to the inside of it.\"\n  [indent fzprint*-return]\n  (let [the-type (nth (first fzprint*-return) 2)]\n    (if (or (= the-type :comment) (= the-type :comment-inline))\n      (concat fzprint*-return [[(str \"\\n\" (blanks indent)) :none :newline 1]])\n      fzprint*-return)))\n\n(defn gather-up-to-next-zloc\n  \"Given a zloc-seq, gather newlines and comments up to the next\n  zloc into a seq.  Returns [seq next-zloc next-count].\"\n  [zloc-seq]\n  (loop [nloc-seq zloc-seq\n         out []\n         next-count 0]\n    (if (not (newline-or-comment? (first nloc-seq)))\n      [out (first nloc-seq) next-count]\n      (recur (next nloc-seq) (conj out (first nloc-seq)) (inc next-count)))))\n\n(defn fzprint-up-to-next-zloc\n  \"Using the information returned from fzprint-up-to-first-zloc or\n  fzprint-up-to-next-zloc, find the next zloc and return \n  [pre-next-style-vec next-zloc next-count zloc-seq]\"\n  [caller options ind [_ _ current-count zloc-seq :as next-data]]\n  (let [starting-count (inc current-count)\n        nloc-seq (nthnext zloc-seq starting-count)]\n    (if-not (= (:ztype options) :zipper)\n      [:noseq (first nloc-seq) starting-count zloc-seq]\n      (let [[pre-next-zloc-seq next-zloc next-count] (gather-up-to-next-zloc\n                                                       nloc-seq)\n            next-count (+ starting-count next-count)]\n        (if (empty? pre-next-zloc-seq)\n          ; The normal case -- nothing before the first interesting zloc\n          [:noseq next-zloc next-count zloc-seq]\n          ; There were newlines or comments (or both) before the first\n          ; interesting zloc\n          (let [coll-print (fzprint-flow-seq options ind pre-next-zloc-seq)\n                ; we are set up for fzprint-seq, but fzprint-flow-seq does\n                ; a full-on style-vec, so turn it back into fzprint-seq style\n                ; output\n                coll-print (mapv vector coll-print)\n                ; We aren't trying to interpose anything here, we are just\n                ; trying to print the stuff we have in a way that will work.\n                ; Remove the last newline if we are not the first thing\n                coll-print (if (not= starting-count 0)\n                             (remove-last-newline coll-print)\n                             coll-print)\n                coll-out (apply concat-no-nil coll-print)\n                ; If we are down inside a list and  the first thing is a\n                ; comment, ensure we start with a newline.  If it is an\n                ; inline comment, then it will get fixed later.\n                coll-out (if (and (not= starting-count 0)\n                                  (let [first-type (nth (first coll-out) 2)]\n                                    (or (= first-type :comment)\n                                        (= first-type :comment-inline))))\n                           (ensure-start-w-nl ind coll-out)\n                           coll-out)\n                ; Eensure that we end with a newline if we are the first\n                ; thing\n                coll-out (if (not= starting-count 0)\n                           coll-out\n                           (ensure-end-w-nl ind coll-out))\n                ; Make sure it ends with a newline, since all comments and\n                ; newlines better end with a newline.  But how could it\n                ; not end with a newline?  We only put comments and newlines\n                ; in here, and added newlines to comments.  So we will assume\n                ; that it ends with a newline.\n               ]\n            [coll-out next-zloc next-count zloc-seq]))))))\n\n(defn fzprint-up-to-first-zloc\n  \"Returns [pre-first-style-vec first-zloc first-count zloc-seq], where\n  pre-first-style-vec will be :noseq if there isn't anything, and first-count\n  is what you give to nthnext to get to the first-zloc in zloc-seq.\"\n  [caller options ind zloc]\n  (if-not (= (:ztype options) :zipper)\n    [:noseq (first zloc) 0 zloc]\n    (let [zloc-seq (fzprint-get-zloc-seq caller options zloc)]\n      ; Start at -1 so that when fzprint-up-to-next-zloc skips, it goes\n      ; to zero.\n      (fzprint-up-to-next-zloc caller options ind [nil nil -1 zloc-seq]))))\n\n(defn get-zloc-seq-right\n  \"Using return from fzprint-up-to-first-zloc or fzprint-up-to-next-zloc,\n  [pre-next-style-vec next-zloc next-count zloc-seq], return a zloc-seq\n  pointer to just beyond the specific zloc which was found by the\n  fzprint-up-to-first or fzprint-up-to-next call.  You don't give this\n  a number, you give it the data structure from the thing that you found.\"\n  [[_ _ next-count zloc-seq :as input-data]]\n  (if (>= next-count (count zloc-seq))\n    (throw (#?(:clj Exception.\n               :cljs js/Error.)\n            (str \"get-zloc-seq-right input data inconsistent:\" input-data)))\n    (let [zloc-seq (nthnext zloc-seq (inc next-count))]\n      #_(prn \"get-zloc-seq-right: next-count:\" next-count\n             \"zloc-seq:\" (map zstring zloc-seq))\n      (dbg-pr \"get-zloc-seq-right:\" (map zstring zloc-seq))\n      zloc-seq)))\n\n\n;;\n;; # Indent-only support\n;;\n\n(defn at-newline?\n  \"Is this a newline or equivalent?  Comments and newlines are both\n  newlines for the purposed of this routine.\"\n  [zloc]\n  (let [this-tag (ztag zloc)] (or (= this-tag :comment) (= this-tag :newline))))\n\n(defn next-newline\n  \"Given a zloc that is down inside of a collection, presumably\n  a list, return a vector containing the number of printing elements\n  we had to traverse to get to it as well as the newline.\"\n  [zloc]\n  (loop [nloc zloc\n         index 0]\n    #_(prn \"next-newline:\" (zstring nloc) \"tag:\" (zprint.zutil/tag nloc))\n    (let [next-right (zprint.zutil/right* nloc)]\n      (if next-right\n        (if (at-newline? nloc)\n          [index nloc]\n          (recur (zprint.zutil/right* nloc)\n                 (if-not (zprint.zutil/whitespace? nloc) (inc index) index)))\n        [index nloc]))))\n\n(defn length-after-newline\n  \"Given a string, return the number of characters to the right\n  of any newlines in the string.  Will return nil if no newlines\n  in the string.\"\n  [s]\n  (let [nl-split (clojure.string/split (str s \" \") #\"\\n\")\n        nl-num (dec (count nl-split))]\n    (when-not (zero? nl-num) (dec (count (last nl-split))))))\n\n(defn tag-l-size\n  \"Given a tag into which you can go down from rewrite-clj, which must be\n  a collection of some kind, return the size the l-str.  All of the tag\n  values into which you can go down must be in this list for indent-before\n  to work correctly.  It uses these values when it steps up out of one of\n  these things to see how big the thing would have been if it showed up\n  as characters.\"\n  [t]\n  (case t\n    :list 1\n    :vector 1\n    :set 2\n    :map 1\n    :uneval 2\n    :reader-macro 1\n    :meta 1\n    :quote 1\n    :syntax-quote 1\n    :fn 2\n    :unquote 1\n    :deref 1\n    :namespaced-map 1\n    0))\n\n(defn left-or-up\n  \"Take a zloc and move left if possible, or move up if necessary.\n  Return a vector with [up-size new-zloc]\"\n  [zloc]\n  (loop [ploc zloc\n         total-up 0]\n    #_(prn \"left-or-up: ploc:\" (zstring ploc) \"total-up:\" total-up)\n    (let [next-left (zprint.zutil/left* ploc)]\n      (if next-left\n        [total-up next-left]\n        ; can't go left, what about up?\n        (let [moving-up (zprint.zutil/up* ploc)\n              up-tag (when moving-up (zprint.zutil/tag moving-up))\n              up-size (tag-l-size up-tag)]\n          #_(prn \"left-or-up: up-tag:\" up-tag)\n          (if-not moving-up\n            ; can't go up, ran out of expression\n            [total-up nil]\n            (recur moving-up (+ total-up up-size))))))))\n\n(defn length-before\n  \"Given a zloc, find the amount of printing space before it on its\n  current line.\"\n  [zloc]\n  (let [[up-size next-zloc] (left-or-up zloc)]\n    (loop [ploc next-zloc\n           indent-before up-size]\n      (if-not ploc\n        (do #_(prn \"length-before: if-not ploc:\" indent-before) indent-before)\n        ; we assume we have a ploc\n        (let [zstr (if ploc (zstring ploc) \"\")\n              length-right-of-newline (length-after-newline zstr)\n              [up-size next-zloc] (left-or-up ploc)]\n          #_(prn \"length-before: (nil? ploc):\" (nil? ploc)\n                 \"zstr:\" zstr\n                 \"up-size:\" up-size\n                 \"length-right-of-newline:\" length-right-of-newline\n                 \"(tag ploc):\" (zprint.zutil/tag ploc)\n                 \"ploc:\" (zstring ploc)\n                 \"next-zloc:\" (zstring next-zloc))\n          (if length-right-of-newline\n            ; hit a newline\n            (do #_(prn \"length-before: length-right-of-newline:\"\n                         length-right-of-newline\n                       \"indent-before:\" indent-before)\n                (+ length-right-of-newline indent-before))\n            (recur next-zloc (+ indent-before (count zstr) up-size))))))))\n\n(defn next-actual\n  \"Return the next actual element, ignoring comments and whitespace\n  and everything else but real elements.\"\n  [zloc]\n  #_(prn \"next-actual: zloc\" (zstring zloc))\n  (loop [nloc zloc]\n    (if-not nloc\n      nloc\n      (let [next-nloc (zprint.zutil/zrightnws nloc)\n            next-tag (zprint.zutil/tag next-nloc)]\n        #_(prn \"nloc:\" nloc\n               \"next-actual: next-nloc:\" (zstring next-nloc)\n               \"next-tag:\" next-tag)\n        (if-not (or (= next-tag :newline) (= next-tag :comment))\n          next-nloc\n          (recur next-nloc))))))\n\n(defn first-actual\n  \"Return the first actual element, ignoring comments and whitespace\n  and everything else but real elements.\"\n  [zloc]\n  (if (at-newline? zloc) (next-actual zloc) zloc))\n\n(defn hang-zloc?\n  \"Should we hang this zloc, or flow it.  We assume that we are at\n  the start of the collection (though this could be generalized to\n  deal with other starting locations easily enough).  Return true\n  if we should hang it based just on the information in the zloc\n  itself.  The criteria are: If there is a newline after the second\n  thing in the zloc, and the amount of space prior to the third thing\n  is the same as the amount of space prior to the second thing, then\n  the incoming zloc was hung and we should do the same. Of course, it\n  would also only be hung if the second thing was on the same line as\n  the first thing.\"\n  [zloc]\n  #_(prn \"hang-zloc: zloc:\" zloc \"at-newline?:\" (at-newline? zloc))\n  (let [zloc (first-actual zloc) ; skip comments/newlines at start\n        [count-prior-to-newline newline] (next-newline zloc)]\n    #_(prn \"at-newline?:\" (at-newline? zloc)\n           \"hang-zloc?: count-prior...:\" count-prior-to-newline\n           \"zloc:\" (zstring zloc))\n    ; Are the first two real things on the same line?\n    (if (< count-prior-to-newline 2)\n      ; no -- then it can't be a hang\n      false\n      (let [second-element (zprint.zutil/zrightnws\n                             (if (zprint.zutil/whitespace? zloc)\n                               (zprint.zutil/zrightnws zloc)\n                               zloc))\n            second-indent (length-before second-element)\n            third-element (next-actual second-element)\n            third-indent (length-before third-element)]\n        #_(prn \"hang-zloc?: second-element:\" (zstring second-element)\n               \"second-indent:\" second-indent\n               \"third-element:\" (zstring third-element)\n               \"third-tag:\" (zprint.zutil/tag third-element)\n               \"third-indent:\" third-indent)\n        (and second-element third-element (= second-indent third-indent))))))\n\n(defn indent-shift\n  \"Take a style-vec that was once output from indent-zmap, and fix\n  up all of the :indent elements in it by adding (- actual-ind ind)\n  to them.  If we find a multiple thing in here, call indent-shift\n  recursively with the ind and cur-ind that is approprite.  All of\n  the actual indents are correct already -- all we are doing is\n  setting up their base.  There is no attempt to determine if we\n  are exceeding any configured width.\"\n  [caller options ind actual-ind svec]\n  (let [shift-ind actual-ind]\n    (dbg-pr options\n            \"indent-shift: ind:\" ind\n            \"actual-ind:\" actual-ind\n            \"shift-ind:\" shift-ind\n            \"svec:\" svec)\n    (loop [cur-seq svec\n           cur-ind actual-ind\n           out []]\n      (if-not cur-seq\n        out\n        (let [this-seq (first cur-seq)\n              new-seq\n                (if (vector? (first this-seq))\n                  ; is this ind correct?\n                  (indent-shift caller options ind cur-ind this-seq)\n                  (let [[s color type] this-seq\n                        next-seq (first (next cur-seq))\n                        this-shift (if (and next-seq\n                                            (not (vector? (first next-seq)))\n                                            (= (nth next-seq 2) :indent))\n                                     0\n                                     shift-ind)]\n                    (cond (= type :indent) [(str s (blanks this-shift)) color\n                                            type 42]\n                          (= type :right) [s color type shift-ind]\n                          :else this-seq)))\n              _ (dbg-pr options\n                        \"indent-shift: cur-ind:\" cur-ind\n                        \"this-seq:\" this-seq\n                        \"new-seq:\" new-seq)\n              ; Shouldn't this be (inc cur-ind)?\n              [linecnt max-width lines] (style-lines options cur-ind [new-seq])\n              ; Figure out where we are\n              last-width (last lines)]\n          (dbg-pr options\n                  \"indent-shift: last-width:\" last-width\n                  \"new-seq:\" new-seq)\n          ; Should this be (inc last-width)?\n          (recur (next cur-seq) last-width (conj out new-seq)))))))\n\n(declare merge-fzprint-seq)\n\n(defn indent-zmap\n  \"Implement :indent-only?.  This routine is the central one through\n  which all :indent-only? processing flows, and replaces all of the\n  detailed logic in fzprint-list*, fzprint-vec*, and fzprint-map*.\n  This is called directly by fzprint-vec*, which handles both vectors\n  and sets, and through fzprint-indent by fzprint-list* and\n  fzprint-map*.  Thus, all of the data structures get their\n  :indent-only? processing handled by ident-zmap.  coll-print is\n  the output from fzprint-seq, which is a style-vec in the making\n  without spacing, but with extra [] around the elements.  Everything\n  is based off of ind, and we know nothing to the left of that.\n  ind must be the left end of everything, not the right of l-str!\n  The actual-ind is to the right of l-str.  When we get a newline,\n  replace any spaces after it with our own, and that would be to\n  bring it to ind + indent.  \"\n  ([caller\n    {:keys [width rightcnt], {:keys [wrap-after-multi?]} caller, :as options}\n    ind actual-ind coll-print indent first-indent-only?]\n   (let [coll-print (merge-fzprint-seq coll-print)\n         last-index (dec (count coll-print))\n         rightcnt (fix-rightcnt rightcnt)\n         actual-indent (+ ind indent)]\n     (dbg-pr options\n             \"indent-zmap: ind:\" ind\n             \"actual-ind:\" actual-ind\n             \"first-indent-only?\" first-indent-only?\n             \"indent:\" indent\n             \"actual-indent:\" actual-indent\n             \"coll-print:\" coll-print)\n     (loop [cur-seq coll-print\n            cur-ind actual-ind\n            index 0\n            beginning? true  ; beginning of line\n            ; transient here slowed things down, in a similar routine\n            l-str-indent? true\n            out []]\n       (if-not cur-seq\n         out\n         (let [this-seq (first cur-seq)]\n           (when this-seq\n             (let [multi? (> (count this-seq) 1)\n                   _ (log-lines options \"indent-zmap:\" ind this-seq)\n                   _ (dbg-pr options\n                             \"indent-zmap loop: cur-ind:\" cur-ind\n                             \"multi?\" multi?\n                             \"(count this-seq):\" (count this-seq)\n                             \"this-seq:\" this-seq\n                             \"out:\" out)\n                   this-seq\n                     (if multi?\n                       (indent-shift caller options actual-ind cur-ind this-seq)\n                       this-seq)\n                   [linecnt max-width lines]\n                     (style-lines options cur-ind this-seq)\n                   ; Figure out where we are\n                   last-width (last lines)\n                   ; How can this be right if there are multiple lines?\n                   ; Because we called indent-zmap to get the indents right,\n                   ; and they will be but for the first line, which style-lines\n                   ; fixed because it got the cur-ind..\n                   thetype (nth (last this-seq) 2)\n                   ; This is the total width of the current line\n                   ; relative to ind\n                   len (- last-width cur-ind)\n                   _ (dbg options\n                          \"linecnt:\" linecnt\n                          \"last-width:\" last-width\n                          \"len:\" len\n                          \"type:\" thetype)\n                   len (max 0 len)\n                   ; This isn't the only newline, actually.  Sometimes they\n                   ; are comment or comment-inline.  Later, for indent-shift,\n                   ; they are :indents.  Figure this out!\n                   newline? (= thetype :newline)\n                   comma? (= thetype :comma)\n                   isempty? (empty? (first (first this-seq)))\n                   comment? (or (= thetype :comment)\n                                (= thetype :comment-inline))\n                   ; Adjust for the rightcnt on the last element\n                   ;first-comment? (and comment? (= index 0))\n                   ;first-newline? (and newline? (= index 0))\n                   ;l-str-indent? (or first-comment? first-newline?)\n                   l-str-indent? (and l-str-indent? (or comment? newline?))\n                   actual-indent (if (and (> index 0) first-indent-only?)\n                                   ind\n                                   (+ ind indent))\n                   width (if (= index last-index) (- width rightcnt) width)\n                   ; need to check size, and if one line and fits, should fit\n                   ; ??? why does it fit if this is the first thing?  Because\n                   ; if it isn't, things won't get better?  Seems to me like\n                   ; if the first thing doesn't fit, we should return nil.\n                   ;\n                   ; But this is all about indent-only, not fitting.  But\n                   ; we will probably care about fitting someday.\n                   fit? (<= (+ cur-ind len) width)\n                   ; If we don't care about fit, then don't do this!!\n                   new-ind (cond newline? actual-indent\n                                 :else (+ cur-ind 1 len))]\n               (dbg-pr\n                 options\n                 \"------ this-seq:\" this-seq\n                 \"lines:\" lines\n                 \"linecnt:\" linecnt\n                 \"multi?\" multi?\n                 \"thetype:\" thetype\n                 \"newline?:\" newline?\n                 \"comment?:\" comment?\n                 \"comma?:\" comma?\n                 \"l-str-indent?:\" l-str-indent?\n                 \"first-indent-only?\" first-indent-only?\n                 \"actual-indent:\" actual-indent\n                 \"index:\" index\n                 \"beginning?:\" beginning?\n                 \"max-width:\" max-width\n                 \"last-width:\" last-width\n                 \"len:\" len\n                 \"cur-ind:\" cur-ind\n                 \"isempty?:\" isempty?\n                 \"new-ind:\" new-ind\n                 \"width:\" width\n                 \"fit?\" fit?)\n               (recur ; [cur-seq, cur-ind, index, beginning?, out]\n                 (next cur-seq)\n                 new-ind\n                 (inc index)\n                 ; beginning can happen because we created an indent\n                 ; or because a multi already had one.\n                 (or (and isempty? beginning?) newline? (= thetype :indent))\n                 ; l-str-indent\n                 l-str-indent?\n                 ; out\n                 (if isempty?\n                   out\n                   ; TODO: concat-no-nil fails here, why?\n                   (concat\n                     out\n                     (cond\n                       ; we don't want blanks if the next thing is a newline\n                       newline?\n                         [[(str\n                             \"\\n\"\n                             (let [next-seq (first (next cur-seq))\n                                   #_(prn \"next-seq:\" next-seq)\n                                   newline-next? (when next-seq\n                                                   (= (nth (first next-seq) 2)\n                                                      :newline))]\n                               (if newline-next?\n                                 \"\"\n                                 (blanks (if l-str-indent?\n                                           actual-ind\n                                           actual-indent))))) :none :indent 12]]\n                       ; Remove next line, unnecessary\n                       (zero? index) this-seq\n                       :else (if (or beginning? comma?)\n                               this-seq\n                               (concat-no-nil [[\" \" :none :whitespace 12]]\n                                              this-seq)))))))))))))\n  ([caller options ind actual-ind coll-print indent]\n   (indent-zmap caller options ind actual-ind coll-print indent nil)))\n\n; TODO: Fix these, they both need a lot of work\n; Do we really need both, or just figure out the hang\n; ones?\n\n(def hang-indent #{:hang :none :none-body})\n\n(def flow-indent\n  #{:binding :arg1 :arg1-body :hang :fn :noarg1-body :noarg1 :arg2 :arg2-fn\n    :arg1-force-nl :gt2-force-nl :gt3-force-nl :flow :flow-body :force-nl-body\n    :force-nl})\n\n(defn newline-seq?\n  \"Given a vector of vectors, decide if we should merge these individually\n  into the top level vector.\"\n  [newline-vec]\n  (let [starts-with-nl-vec (mapv #(clojure.string/starts-with? (first %) \"\\n\")\n                             newline-vec)\n        #_(println \"newline-seq? starts-with-nl-vec\" starts-with-nl-vec)\n        true-seq (distinct starts-with-nl-vec)]\n    (and (= (count true-seq) 1) (= (first true-seq) true))))\n\n(defn merge-fzprint-seq\n  \"Given the output from fzprint-seq, which is a seq of the\n  output of fzprint*, apply a function to each of them that has\n  more than one element (since less has no meaning) and when the\n  function returns true, merge the vector in as individual elements.\"\n  [fzprint-seq-vec]\n  (into []\n        (reduce #(if (newline-seq? %2)\n                   (into [] (concat %1 (mapv vector %2)))\n                   (conj %1 %2))\n          []\n          fzprint-seq-vec)))\n\n(defn fzprint-indent\n  \"This function assumes that :indent-only? was set for the caller\n  in the options (since anything else doesn't make sense).  It takes\n  a zloc and the ind, which is where we are on the line this point,\n  and will process the zloc to include any newlines.  Of course we\n  have to have all of the white space in the zloc too, since we\n  need to ask some questions about what we are starting with at\n  some point.  We don't add newlines and we let the newlines that\n  are in there do their thing.  We might add newlines if we move\n  beyond the right margin, but for now, we don't (and it isn't\n  entirely clear how or if that would work).  This routine has to\n  make decisions about the indent, that is whether to hang or flow\n  the expression. It does that based on what was done in the input\n  if the configuration allows.\"\n  ([caller l-str r-str options ind zloc fn-style arg-1-indent\n    first-indent-only?]\n   (let [flow-indent (:indent (caller options))\n         ; If it is a map, then an indent of (count l-str) (which is 1)\n         ; is all that makes sense.\n         flow-indent (if (= caller :map) (count l-str) flow-indent)\n         l-str-len (count l-str)\n         flow-indent (if (and (> flow-indent l-str-len) (= caller :list))\n                       ; If we don't think this could be a fn, indent minimally\n                       (if arg-1-indent flow-indent l-str-len)\n                       flow-indent)\n         actual-ind (+ ind l-str-len)\n         _ (dbg-pr options\n                   \"fzprint-indent: caller:\" caller\n                   \"l-str-len:\" l-str-len\n                   \"ind:\" ind\n                   \"fn-style:\" fn-style\n                   \"arg-1-indent:\" arg-1-indent\n                   \"flow-indent:\" flow-indent\n                   \"actual-ind:\" actual-ind\n                   \"comma?\" (:comma? (caller options)))\n         ; We could enable :comma? for lists, sets, vectors someday\n         zloc-seq (if (:comma? (caller options))\n                    (zmap-w-nl-comma identity zloc)\n                    (zmap-w-nl identity zloc))\n         coll-print (fzprint-seq options ind zloc-seq)\n         _ (dbg-pr options \"fzprint-indent: coll-print:\" coll-print)\n         indent-only-style (:indent-only-style (caller options))\n         ; If we have the possibility of :input-hang, then try if it is\n         ; configured.\n         already-hung? (when (and indent-only-style\n                                  (= indent-only-style :input-hang))\n                         (hang-zloc? (zprint.zutil/down* zloc)))\n         raw-indent (if (and arg-1-indent already-hung?)\n                      (- arg-1-indent ind)\n                      flow-indent)\n         indent raw-indent\n         coll-print-contains-nil? (contains-nil? coll-print)\n         _ (dbg-pr options\n                   \"fzprint-indent:\" (zstring zloc)\n                   \"ind:\" ind\n                   \"fn-style:\" fn-style\n                   \"indent-only-style:\" indent-only-style\n                   \"already-hung?:\" already-hung?\n                   \"arg-1-indent:\" arg-1-indent\n                   \"l-str-len:\" (count l-str)\n                   \"actual-ind:\" actual-ind\n                   \"raw-indent:\" raw-indent\n                   \"coll-print-contains-nil?:\" coll-print-contains-nil?\n                   \"indent:\" indent)\n         coll-print (when-not coll-print-contains-nil? coll-print)]\n     ; indent needs to adjust for the size of l-str-vec, since actual-ind\n     ; has l-str-vec in it so that indent-zmap knows where we are on the\n     ; line.  Just like fzprint-one-line needs one-line-ind, not ind.\n     (let [output (indent-zmap caller\n                               options\n                               ind\n                               actual-ind\n                               coll-print\n                               indent\n                               first-indent-only?)]\n       (dbg-pr options \"fzprint-indent: output:\" output)\n       output)))\n  ([caller l-str r-str options ind zloc fn-style arg-1-indent]\n   (fzprint-indent caller\n                   l-str\n                   r-str\n                   options\n                   ind\n                   zloc\n                   fn-style\n                   arg-1-indent\n                   nil)))\n\n(defn zfind-seq\n  \"Find the location, counting from zero, and counting every element \n  in the seq, of the first zthing?.  Return its index if it is found, \n  nil if not.\"\n  [zthing? zloc-seq]\n  (loop [nloc zloc-seq\n         i 0]\n    (when (not (nil? nloc))\n      (if (zthing? (first nloc)) i (recur (next nloc) (inc i))))))\n\n;;\n;; # Utilities to modify list printing in various ways\n;;\n\n;;\n;; Which fn-styles use :list {:indent n} instead of\n;; :list {:indent-arg n}\n;;\n\n(def body-set\n  #{:binding :arg1-> :arg2 :arg2-fn :arg2-pair :pair-fn :fn :arg1-body\n    :arg1-pair-body :none-body :noarg1-body :flow-body})\n\n(def body-map\n  {:arg1-body :arg1,\n   :arg1-pair-body :arg1-pair,\n   :none-body :none,\n   :flow-body :flow,\n   :noarg1-body :noarg1,\n   :force-nl-body :force-nl})\n\n;;\n;; If the noarg1? value is set, this is the mapping for functions\n;; immediately below\n;; \n\n(def noarg1-set #{:noarg1 :arg1->})\n\n(def noarg1-map\n  {:arg1 :none,\n   :arg1-pair :pair-fn,\n   :arg1-extend :extend,\n   :arg2 :arg1,\n   :arg2-pair :arg1-pair})\n\n(defn noarg1\n  \"Set noarg1 in the options if it is the right fn-type.\"\n  [options fn-type]\n  (if (noarg1-set fn-type) (assoc options :no-arg1? true) options))\n\n(def fn-style->caller\n  {:arg1-pair-body :pair,\n   :arg1-pair :pair,\n   :arg2-pair :pair,\n   :extend :extend,\n   :binding :binding,\n   :arg1-extend :extend,\n   :arg2-extend :extend,\n   :pair-fn :pair})\n\n(defn get-respect-indent\n  \"Given an options map, get the respect-nl?, respect-bl? and indent-only?\n  options from the caller's options, and if the caller doesn't define these,\n  use the values from the backup section of the options map. Return\n  [respect-nl? respect-bl? indent-only?]\"\n  ; Note that the routine make-caller exists, and see its use in fzprint*\n  ; That is a different way to solve this problem\n  ;\n  ; We just evaluate the things that need to be evaluated, since this is\n  ; called a *lot*!.\n  [options caller backup]\n  (let [caller-options (caller options)\n        respect-nl? (get caller-options :respect-nl? :undef)\n        respect-bl? (get caller-options :respect-bl? :undef)\n        indent-only? (get caller-options :indent-only? :undef)]\n    [(if (not= respect-nl? :undef) respect-nl? (:respect-nl? (backup options)))\n     (if (not= respect-bl? :undef) respect-bl? (:respect-bl? (backup options)))\n     (if (not= indent-only? :undef)\n       indent-only?\n       (:indent-only? (backup options)))]))\n\n(defn allow-one-line?\n  \"Should we allow this function to print on a single line?\"\n  [{:keys [fn-force-nl fn-gt2-force-nl fn-gt3-force-nl], :as options} len\n   fn-style]\n  (not (or (fn-force-nl fn-style)\n           (and (> len 3) (fn-gt2-force-nl fn-style))\n           (and (> len 4) (fn-gt3-force-nl fn-style))\n           (if-let [future-caller (fn-style->caller fn-style)]\n             (let [caller-map (future-caller options)]\n               (or (:flow? caller-map) (:force-nl? caller-map)))))))\n\n(defn modify-zloc\n  \"If the (caller options) has a value for :return-altered-zipper, then\n  examine the value.  It should be [<depth> <symbol> <fn>]. \n  If the <depth> is nil, any depth will do. If the\n  <symbol> is nil, any symbol will do.  If the <depth> and <symbol>\n  match, then the <fn> is called as (fn caller options zloc), and must\n  return a new zloc.\"\n  [caller options zloc]\n  (let [[depth trigger-symbol modify-fn :as return-altered-zipper-value]\n          (:return-altered-zipper (caller options))]\n    (dbg options\n         \"modify-zloc caller:\" caller\n         \"ztype\" (:ztype options)\n         \"return-altered-zipper-value:\" return-altered-zipper-value)\n    (if (or (not= (:ztype options) :zipper) (nil? return-altered-zipper-value))\n      zloc\n      (let [call-fn? (and (or (nil? depth) (= (:depth options) depth))\n                          (or (not trigger-symbol)\n                              (= trigger-symbol (zsexpr (zfirst zloc))))\n                          modify-fn)]\n        (dbg options \"modify-zloc: zloc\" (zstring zloc) \"call-fn?\" call-fn?)\n        (if call-fn?\n          (let [return (modify-fn caller options zloc)]\n            (dbg options \"modify-zloc return:\" (zstring return))\n            return)\n          zloc)))))\n\n(defn fzprint-list*\n  \"Print a list, which might be a list or an anon fn.  \n  Lots of work to make a list look good, as that is typically code. \n  Presently all of the callers of this are :list or :vector-fn.\"\n  [caller l-str r-str\n   ; The options map can get re-written down a bit below, so don't get\n   ; anything with destructuring that might change with a rewritten  options\n   ; map!\n   {:keys [fn-map user-fn-map one-line? fn-style no-arg1? fn-force-nl],\n    :as options} ind zloc]\n  ; We don't need to call get-respect-indent here, because all of the\n  ; callers of fzprint-list* define respect-nl?, respect-bl? and indent-only?\n  (let [max-length (get-max-length options)\n        zloc (modify-zloc caller options zloc)\n        ; zcount does (zmap identity zloc) which counts comments and the\n        ; newline after it, but no other newlines\n        len (zcount zloc)\n        zloc (if (> len max-length) (ztake-append max-length zloc '...) zloc)\n        len (zcount zloc)\n        l-str-len (count l-str)\n        indent (:indent (options caller))\n        ; NOTE WELL -- don't use arg-1-zloc (or arg-2-zloc, etc.) as\n        ; a condition, because it might well be legitimately nil when\n        ; formatting structures.\n        [pre-arg-1-style-vec arg-1-zloc arg-1-count zloc-seq :as first-data]\n          (fzprint-up-to-first-zloc caller options (+ ind l-str-len) zloc)\n        #_(prn \"fzprint-list* zloc-seq:\" (map zstring zloc-seq))\n        arg-1-coll? (not (or (zkeyword? arg-1-zloc) (zsymbol? arg-1-zloc)))\n        ; Use an alternative arg-1-indent if the fn-style is forced on input\n        ; and we don't actually have an arg-1 from which we can get an indent.\n        ; Now, we might want to allow arg-1-coll? to give us an arg-1-indent,\n        ; maybe, someday, so we could hang next to it.\n        ; But for now, this will do.\n        arg-1-indent-alt? (and arg-1-coll? fn-style)\n        fn-str (if-not arg-1-coll? (zstring arg-1-zloc))\n        fn-style (or fn-style (fn-map fn-str) (user-fn-map fn-str))\n        ; if we don't have a function style, let's see if we can get\n        ; one by removing the namespacing\n        fn-style (if (and (not fn-style) fn-str)\n                   (fn-map (last (clojure.string/split fn-str #\"/\")))\n                   fn-style)\n        ; If we have a fn-str and not a fn-style, see if we have a default\n        ; fn-style for every function which doesn't have one explicitly set\n        fn-style (if (= fn-style :none) nil fn-style)\n        fn-style (if (and fn-str (nil? fn-style)) (:default fn-map) fn-style)\n        ; Do we have a [fn-style options] vector?\n        ; **** NOTE: The options map can change here, and if it does,\n        ; some of the things found in it above would have to change too!\n        options\n          ; The config-and-validate allows us to use :style in the options\n          ; map associated with a function.  Don't think that we really needed\n          ; to validate (second fn-style), as that was already done.  But this\n          ; does allow us to use :style and other stuff.  Potential performance\n          ; improvement would be to build a config-and-validate that did the\n          ; same things and didn't validate.\n          ;\n          ; There could be two option maps in the fn-style vector:\n          ;   [:fn-style {:option :map}]\n          ;   [:fn-style {:zipper :option-map} {:structure :option-map}]\n          ;\n          ; If there is only one, it is used for both.  If there are two,\n          ; then we use the appropriate one.\n          (if (vector? fn-style)\n            (first (zprint.config/config-and-validate\n                     \"fn-style:\"\n                     nil\n                     options\n                     (if (= (count fn-style) 2)\n                       ; only one option map\n                       (second fn-style)\n                       (if (= :zipper (:ztype options))\n                         (second fn-style)\n                         (nth fn-style 2)))))\n            options)\n        ; If we messed with the options, then find new stuff.  This will\n        ; probably change only zloc-seq because of :respect-nl? or :indent-only?\n        [pre-arg-1-style-vec arg-1-zloc arg-1-count zloc-seq :as first-data]\n          (if (vector? fn-style)\n            (fzprint-up-to-first-zloc caller options (+ ind l-str-len) zloc)\n            first-data)\n        ; Don't do this too soon, as multiple things are driven off of\n        ; (vector? fn-style), above\n        fn-style (if (vector? fn-style) (first fn-style) fn-style)\n        ; Finish finding all of the interesting stuff in the first two\n        ; elements\n        [pre-arg-2-style-vec arg-2-zloc arg-2-count _ :as second-data]\n          ; The ind is wrong, need arg-1-indent, but we don't have it yet.\n          (fzprint-up-to-next-zloc caller\n                                   options\n                                   ;(+ ind l-str-len)\n                                   (+ ind indent)\n                                   first-data)\n        ; This len doesn't include newlines or other whitespace or\n        len (zcount-zloc-seq-nc-nws zloc-seq)\n        #_(prn \"fzprint-list* pre-arg-1-style-vec:\" pre-arg-1-style-vec\n               \"pre-arg-2-style-vec:\" pre-arg-2-style-vec\n               \"arg-1-zloc:\" (zstring arg-1-zloc)\n               \"arg-2-zloc:\" (zstring arg-2-zloc)\n               \"arg-1-count:\" arg-1-count\n               \"arg-2-count:\" arg-2-count\n               \"len:\" len)\n        ; If fn-style is :replace-w-string, then we have an interesting\n        ; set of things to do.\n        ;\n        [options arg-1-zloc l-str l-str-len r-str len zloc-seq]\n          (if (and (= fn-style :replace-w-string)\n                   (:replacement-string (options caller))\n                   (= len 2))\n            [(assoc (update-in options [caller] dissoc :replacement-string)\n               :rightcnt (dec (:rightcnt options))) arg-2-zloc\n             (:replacement-string (options caller))\n             (count (:replacement-string (options caller))) \"\" 1\n             (remove-one zloc-seq arg-1-count)]\n            [options arg-1-zloc l-str l-str-len r-str len zloc-seq])\n        #_(prn \"fzprint-list*: l-str:\" l-str\n               \"l-str-len:\" l-str-len\n               \"len:\" len\n               \"fn-style:\" fn-style)\n        ; Get indents which might have changed if the options map was\n        ; re-written by the function style being a vector.\n        indent (:indent (options caller))\n        indent-arg (:indent-arg (options caller))\n        indent-only? (:indent-only? (options caller))\n        ; set indent based on fn-style\n        indent (if (body-set fn-style) indent (or indent-arg indent))\n        indent (+ indent (dec l-str-len))\n        one-line-ok? (allow-one-line? options len fn-style)\n        one-line-ok? (when-not indent-only? one-line-ok?)\n        one-line-ok? (if (not= pre-arg-1-style-vec :noseq) nil one-line-ok?)\n        ; remove -body from fn-style if it was there\n        fn-style (or (body-map fn-style) fn-style)\n        ; All styles except :hang, :flow, and :flow-body and :binding need\n        ; three elements minimum. We could put this in the fn-map,\n        ; but until there are more than three (well four) exceptions, seems\n        ; like too much mechanism.\n        fn-style (if (#{:hang :flow :flow-body :binding :replace-w-string}\n                      fn-style)\n                   fn-style\n                   (if (< len 3) nil fn-style))\n        ;fn-style (if (= fn-style :hang) fn-style (if (< len 3) nil fn-style))\n        fn-style (if no-arg1? (or (noarg1-map fn-style) fn-style) fn-style)\n        ; no-arg? only affect one level down...\n        options (if no-arg1? (dissoc options :no-arg1?) options)\n        ; If l-str isn't one char, create an indent adjustment.  Largely\n        ; for anonymous functions, which otherwise would have their own\n        ; :anon config to parallel :list, which would be just too much\n        indent-adj (dec l-str-len)\n        ; The default indent is keyed off of whether or not the first thing\n        ; in the list is itself a list, since that list could evaluate to a\n        ; fn.  You can't replace the zlist? with arg-1-coll?, since if you do\n        ; multi-arity functions aren't done right, since the argument vector\n        ; is a coll?, and so arg-1-coll? is set, and then you get a two space\n        ; indent for multi-arity functions, which is wrong.\n        ; We could, conceivably, use zvector? here to specifically handle\n        ; multi-arity functions.  Or we could remember we are in a defn and\n        ; do something special there, or we could at least decide that we\n        ; were in code when we did this zlist? thing, since that is all about\n        ; code.  That wouldn't work if it was the top-level form, but would\n        ; otherwise.\n        default-indent (if (zlist? arg-1-zloc) indent l-str-len)\n        arg-1-indent (if-not arg-1-coll? (+ ind (inc l-str-len) (count fn-str)))\n        ; If we don't have an arg-1-indent, and we noticed that the inputs\n        ; justify using an alternative, then use the alternative.\n        arg-1-indent (or arg-1-indent (when arg-1-indent-alt? (+ indent ind)))\n        ; If we have anything in pre-arg-2-style-vec, then we aren't hanging\n        ; anything.  But an arg-1-indent of nil isn't good, so we will make it\n        ; like the flow indent so we flow.\n        arg-1-indent (if (= pre-arg-2-style-vec :noseq)\n                       arg-1-indent\n                       (when arg-1-indent (+ indent ind)))\n        ; Tell people inside that we are in code.\n        ; We don't catch places where the first thing in a list is\n        ; a collection or a seq which yields a function.\n        options (if (not arg-1-coll?) (assoc options :in-code? fn-str) options)\n        options (assoc options :pdepth (inc (long (or (:pdepth options) 0))))\n        _ (when (:dbg-hang options)\n            (println (dots (:pdepth options)) \"fzs\" fn-str))\n        new-ind (+ indent ind)\n        one-line-ind (+ l-str-len ind)\n        options (if fn-style (dissoc options :fn-style) options)\n        loptions (not-rightmost options)\n        roptions options\n        l-str-vec [[l-str (zcolor-map options l-str) :left]]\n        ; Fudge the ind a bit for r-str-vec for anon fns: #()\n        r-str-vec (rstr-vec options (+ ind (max 0 (dec l-str-len))) zloc r-str)\n        _ (dbg-pr\n            options\n            \"fzprint-list*:\" (zstring zloc)\n            \"fn-str\" fn-str\n            \"fn-style:\" fn-style\n            \"len:\" len\n            \"ind:\" ind\n            \"indent:\" indent\n            \"default-indent:\" default-indent\n            \"one-line-ok?\" one-line-ok?\n            \"arg-1-coll?\" arg-1-coll?\n            \"arg-1-indent:\" arg-1-indent\n            \"arg-1-zloc:\" (zstring arg-1-zloc)\n            \"pre-arg-1-style-vec:\" pre-arg-1-style-vec\n            \"l-str:\" (str \"'\" l-str \"'\")\n            \"l-str-len:\" l-str-len\n            \"r-str-vec:\" r-str-vec\n            \"indent-adj:\" indent-adj\n            \"one-line?:\" one-line?\n            \"indent-only?:\" indent-only?\n            \"rightcnt:\" (:rightcnt options)\n            \"replacement-string:\" (:replacement-string (caller options))\n            \":ztype:\" (:ztype options))\n        one-line (if (and (zero? len) (= pre-arg-1-style-vec :noseq))\n                   :empty\n                   (when one-line-ok?\n                     (fzprint-one-line options one-line-ind zloc-seq)))]\n    (cond\n      one-line (if (= one-line :empty)\n                 (concat-no-nil l-str-vec r-str-vec)\n                 (concat-no-nil l-str-vec one-line r-str-vec))\n      ; If we are in :one-line mode, and it didn't fit on one line,\n      ; we are done!  We don't see this debugging, below.  Suppose\n      ; we never get here?\n      one-line?\n        (dbg options \"fzprint-list*:\" fn-str \" one-line did not work!!!\")\n      (dbg options \"fzprint-list*: fn-style:\" fn-style) nil\n      (and (= len 0) (= pre-arg-1-style-vec :noseq)) (concat-no-nil l-str-vec\n                                                                    r-str-vec)\n      indent-only? (concat-no-nil l-str-vec\n                                  (fzprint-indent caller\n                                                  l-str\n                                                  r-str\n                                                  options\n                                                  ind\n                                                  zloc\n                                                  fn-style\n                                                  arg-1-indent)\n                                  r-str-vec)\n      (= len 1)\n        ; While len is one, don't assume that there is actually only one\n        ; thing to print and use fzprint*.  len only counts the non-comment\n        ; and non-nl elements, and there might be other things to print.\n        (concat-no-nil l-str-vec\n                       (fzprint-flow-seq roptions one-line-ind zloc-seq)\n                       r-str-vec)\n      ; In general, we don't have a fn-style if we have less than 3 elements.\n      ; However, :binding is allowed with any number up to this point, so we\n      ; have to check here.  :binding is actually allowed with at least two\n      ; elements, the third through n are optional.\n      (and (= fn-style :binding) (> len 1) (zvector? arg-2-zloc))\n        (let [[hang-or-flow binding-style-vec]\n                (fzprint-hang-unless-fail loptions\n                                          (or arg-1-indent (+ indent ind))\n                                          (+ indent ind)\n                                          fzprint-binding-vec\n                                          arg-2-zloc)\n              binding-style-vec (if (= hang-or-flow :hang)\n                                  (concat-no-nil [[\" \" :none :whitespace 14]]\n                                                 binding-style-vec)\n                                  binding-style-vec)]\n          (concat-no-nil l-str-vec\n                         pre-arg-1-style-vec\n                         ; TODO: get rid of inc ind\n                         (fzprint* loptions (inc ind) arg-1-zloc)\n                         pre-arg-2-style-vec\n                         binding-style-vec\n                         (concat-no-nil\n                           ; Here we use options, because fzprint-flow-seq\n                           ; will sort it out.  It will also handle an\n                           ; empty zloc-seq by returning :noseq, so we\n                           ; don't have to check for (> len 2) before\n                           ; we call it.\n                           (fzprint-flow-seq options\n                                             (+ indent ind)\n                                             (get-zloc-seq-right second-data)\n                                             :force-nl\n                                             :newline-first)\n                           r-str-vec)))\n      (= fn-style :pair-fn)\n        (let [zloc-seq-right-first (get-zloc-seq-right first-data)\n              zloc-count (count zloc-seq)]\n          (concat-no-nil l-str-vec\n                         pre-arg-1-style-vec\n                         (fzprint* loptions (inc ind) arg-1-zloc)\n                         (fzprint-hang (assoc-in options\n                                         [:pair :respect-nl?]\n                                         (:respect-nl? (caller options)))\n                                       :pair-fn\n                                       arg-1-indent\n                                       (+ indent ind)\n                                       fzprint-pairs\n                                       zloc-count\n                                       zloc-seq-right-first)\n                         r-str-vec))\n      (= fn-style :extend)\n        (let [zloc-seq-right-first (get-zloc-seq-right first-data)]\n          (concat-no-nil\n            l-str-vec\n            pre-arg-1-style-vec\n            (fzprint* loptions (inc ind) arg-1-zloc)\n            (prepend-nl\n              options\n              (+ indent ind)\n              ; I think fzprint-pairs will sort out which\n              ; is and isn't the rightmost because of\n              ; two-up\n              (fzprint-extend options (+ indent ind) zloc-seq-right-first))\n            r-str-vec))\n      ; needs (> len 2) but we already checked for that above in fn-style\n      (or (and (= fn-style :fn) (not (zlist? arg-2-zloc)))\n          (= fn-style :arg2)\n          (= fn-style :arg2-fn)\n          (= fn-style :arg2-pair)\n          (= fn-style :arg2-extend))\n        (let [[pre-arg-3-style-vec arg-3-zloc arg-3-count _ :as third-data]\n                ; The ind is wrong, need arg-1-indent, but we don't have it yet.\n                (fzprint-up-to-next-zloc caller\n                                         options\n                                         ; This is probably wrong\n                                         ; (+ ind l-str-len)\n                                         (+ ind indent)\n                                         second-data)\n              #_(prn \"pre-arg-1-style-vec:\" pre-arg-1-style-vec)\n              #_(prn \"pre-arg-2-style-vec:\" pre-arg-2-style-vec)\n              #_(prn \"pre-arg-3-style-vec:\" pre-arg-3-style-vec)\n              zloc-seq-right-third (get-zloc-seq-right third-data)\n              second-element (fzprint-hang-one\n                               caller\n                               (if (not arg-3-zloc) options loptions)\n                               ; This better not be nil\n                               arg-1-indent\n                               (+ indent ind)\n                               arg-2-zloc)\n              [line-count max-width]\n                ; arg-1-indent better not be nil here either\n                (style-lines loptions arg-1-indent second-element)\n              first-three\n                (when second-element\n                  (let [first-two-wo-pre-arg-1\n                          (concat-no-nil\n                            (fzprint* loptions (+ indent ind) arg-1-zloc)\n                            pre-arg-2-style-vec\n                            second-element\n                            pre-arg-3-style-vec)\n                        local-options\n                          (if (not zloc-seq-right-third) options loptions)\n                        first-two-one-line?\n                          (fzfit-one-line local-options\n                                          (style-lines local-options\n                                                       (+ ind indent)\n                                                       first-two-wo-pre-arg-1))\n                        ; Add pre-arg-1-style-vec back in, which might push\n                        ; it to two lines (or many lines), but that\n                        ; doesn't matter.\n                        first-two (concat-no-nil pre-arg-1-style-vec\n                                                 first-two-wo-pre-arg-1)]\n                    (when-not first-two-one-line?\n                      (dbg-pr options\n                              \"fzprint-list*: :arg2-* first two didn't fit:\"\n                              first-two))\n                    (concat-no-nil\n                      first-two\n                      (if (or (= fn-style :arg2)\n                              (= fn-style :arg2-pair)\n                              (= fn-style :arg2-fn)\n                              (= fn-style :arg2-extend)\n                              (and (zvector? arg-3-zloc) (= line-count 1)))\n                        (fzprint-hang-one\n                          caller\n                          (if (not zloc-seq-right-third) options loptions)\n                          (if (and (= pre-arg-3-style-vec :noseq)\n                                   first-two-one-line?)\n                            ; hang it if possible\n                            max-width\n                            ; flow it\n                            (+ indent ind))\n                          (+ indent ind)\n                          arg-3-zloc)\n                        (prepend-nl options\n                                    (+ indent ind)\n                                    (fzprint* (if (not zloc-seq-right-third)\n                                                options\n                                                loptions)\n                                              (+ indent ind)\n                                              arg-3-zloc))))))]\n          (when first-three\n            (if (not zloc-seq-right-third)\n              ; if nothing after the third thing, means just three things\n              (concat-no-nil l-str-vec first-three r-str-vec)\n              ; more than three things\n              (concat-no-nil\n                l-str-vec\n                first-three\n                (cond (= fn-style :arg2-pair)\n                        (prepend-nl options\n                                    (+ indent ind)\n                                    (fzprint-pairs options\n                                                   (+ indent ind)\n                                                   zloc-seq-right-third))\n                      (= fn-style :arg2-extend)\n                        (prepend-nl options\n                                    (+ indent ind)\n                                    (fzprint-extend options\n                                                    (+ indent ind)\n                                                    zloc-seq-right-third))\n                      :else (fzprint-hang-remaining caller\n                                                    ;options\n                                                    (if (= fn-style :arg2-fn)\n                                                      (assoc options\n                                                        :fn-style :fn)\n                                                      options)\n                                                    (+ indent ind)\n                                                    ; force flow\n                                                    (+ indent ind)\n                                                    zloc-seq-right-third\n                                                    fn-style))\n                r-str-vec))))\n      (and (= fn-style :arg1-mixin) (> len 3))\n        (let [[pre-arg-3-style-vec arg-3-zloc arg-3-count _ :as third-data]\n                (fzprint-up-to-next-zloc caller\n                                         options\n                                         (+ ind indent)\n                                         second-data)\n              [pre-arg-4-style-vec arg-4-zloc arg-4-count _ :as fourth-data]\n                (fzprint-up-to-next-zloc caller\n                                         options\n                                         (+ ind indent)\n                                         third-data)\n              arg-vec-index (or (zfind-seq #(or (zvector? %)\n                                                (when (zlist? %)\n                                                  (zvector? (zfirst %))))\n                                           zloc-seq)\n                                0)\n              doc-string? (string? (zsexpr arg-3-zloc))\n              mixin-start (if doc-string? arg-4-count arg-3-count)\n              mixin-length (- arg-vec-index mixin-start 1)\n              mixins? (pos? mixin-length)\n              doc-string (when doc-string?\n                           (fzprint-hang-one caller\n                                             loptions\n                                             (+ indent ind)\n                                             ; force flow\n                                             (+ indent ind)\n                                             arg-3-zloc))\n              #_(prn \":arg1-mixin: doc-string?\" doc-string?\n                     \"mixin-start:\" mixin-start\n                     \"mixin-length:\" mixin-length\n                     \"mixins?\" mixins?\n                     \"arg-vec-index:\" arg-vec-index\n                     \"doc-string\" doc-string\n                     \"arg-1-count:\" arg-1-count\n                     \"arg-1-zloc:\" (zstring arg-1-zloc)\n                     \"arg-2-count:\" arg-2-count\n                     \"arg-2-zloc:\" (zstring arg-2-zloc)\n                     \"arg-3-count:\" arg-3-count\n                     \"arg-3-zloc:\" (zstring arg-3-zloc)\n                     \"arg-4-count:\" arg-4-count\n                     \"arg-4-zloc:\" (zstring arg-4-zloc))\n              ; Have to deal with no arg-vec-index!!\n              mixins\n                (when mixins?\n                  (let [mixin-sentinal (fzprint-hang-one\n                                         caller\n                                         loptions\n                                         (+ indent ind)\n                                         ; force flow\n                                         (+ indent ind)\n                                         (if doc-string? arg-4-zloc arg-3-zloc))\n                        [line-count max-width]\n                          (style-lines loptions (+ indent ind) mixin-sentinal)]\n                    (concat-no-nil\n                      (if doc-string? pre-arg-4-style-vec pre-arg-3-style-vec)\n                      mixin-sentinal\n                      (fzprint-hang-remaining\n                        caller\n                        loptions\n                        ; Apparently hang-remaining gives\n                        ; you a\n                        ; space after the current thing,\n                        ; so we\n                        ; need to account for it now,\n                        ; since\n                        ; max-width is the end of the\n                        ; current\n                        ; thing\n                        (inc max-width)\n                        (dec (+ indent indent ind))\n                        (get-zloc-seq-right\n                          (if doc-string fourth-data third-data))\n                        fn-style\n                        mixin-length))))]\n          (concat-no-nil\n            l-str-vec\n            pre-arg-1-style-vec\n            (fzprint* loptions (inc ind) arg-1-zloc)\n            pre-arg-2-style-vec\n            (fzprint-hang-one caller\n                              (if (= len 2) options loptions)\n                              arg-1-indent\n                              (+ indent ind)\n                              arg-2-zloc)\n            (cond (and doc-string? mixins?) (concat-no-nil pre-arg-3-style-vec\n                                                           doc-string\n                                                           (remove-one-newline\n                                                             mixins))\n                  doc-string? (concat-no-nil pre-arg-3-style-vec doc-string)\n                  mixins? (remove-one-newline mixins)\n                  :else :noseq)\n            (fzprint-hang-remaining\n              caller\n              (noarg1 options fn-style)\n              (+ indent ind)\n              ; force flow\n              (+ indent ind)\n              (nthnext zloc-seq\n                       (if mixins?\n                         arg-vec-index\n                         (if doc-string? arg-4-count arg-3-count)))\n              fn-style)\n            r-str-vec))\n      (or (= fn-style :arg1-pair)\n          (= fn-style :arg1)\n          (= fn-style :arg1-force-nl)\n          (= fn-style :arg1->))\n        (concat-no-nil\n          l-str-vec\n          pre-arg-1-style-vec\n          (fzprint* loptions (inc ind) arg-1-zloc)\n          pre-arg-2-style-vec\n          (fzprint-hang-one caller\n                            (if (= len 2) options loptions)\n                            arg-1-indent\n                            (+ indent ind)\n                            arg-2-zloc)\n          ; then either pair or remaining-seq\n          ; we don't do a full hanging here.\n          ; We wouldn't be here if len < 3\n          (if (= fn-style :arg1-pair)\n            (prepend-nl options\n                        (+ indent ind)\n                        (fzprint-pairs options\n                                       (+ indent ind)\n                                       (get-zloc-seq-right second-data)))\n            (fzprint-hang-remaining caller\n                                    (noarg1 options fn-style)\n                                    (+ indent ind)\n                                    ; force flow\n                                    (+ indent ind)\n                                    (get-zloc-seq-right second-data)\n                                    fn-style))\n          r-str-vec)\n      ; we know that (> len 2) if fn-style not= nil\n      (= fn-style :arg1-extend)\n        (let [zloc-seq-right-second (get-zloc-seq-right second-data)]\n          (cond (zvector? arg-2-zloc)\n                  ; This will put the second argument (a vector) on a different\n                  ; line than the function name.  No known uses for this code\n                  ; as of 7/20/19.  It does work with :respect-nl and has tests.\n                  (concat-no-nil\n                    l-str-vec\n                    pre-arg-1-style-vec\n                    (fzprint* loptions (+ indent ind) arg-1-zloc)\n                    pre-arg-2-style-vec\n                    (prepend-nl options\n                                (+ indent ind)\n                                (fzprint* loptions (+ indent ind) arg-2-zloc))\n                    (prepend-nl options\n                                (+ indent ind)\n                                (fzprint-extend options\n                                                (+ indent ind)\n                                                zloc-seq-right-second))\n                    r-str-vec)\n                :else (concat-no-nil\n                        l-str-vec\n                        pre-arg-1-style-vec\n                        (fzprint* loptions (inc ind) arg-1-zloc)\n                        pre-arg-2-style-vec\n                        (fzprint-hang-one caller\n                                          (if (= len 2) options loptions)\n                                          arg-1-indent\n                                          (+ indent ind)\n                                          arg-2-zloc)\n                        (prepend-nl options\n                                    (+ indent ind)\n                                    (fzprint-extend options\n                                                    (+ indent ind)\n                                                    zloc-seq-right-second))\n                        r-str-vec)))\n      ; Unspecified seq, might be a fn, might not.\n      ; If (first zloc) is a seq, we won't have an\n      ; arg-1-indent.  In that case, just flow it\n      ; out with remaining seq.  Since we already\n      ; know that it won't fit on one line.  If it\n      ; might be a fn, try hanging and flow and do\n      ; what we like better.  Note that default-indent\n      ; might be 1 here, which means that we are pretty\n      ; sure that the (zfirst zloc) isn't a function\n      ; and we aren't doing code.\n      ;\n      :else (concat-no-nil\n              l-str-vec\n              pre-arg-1-style-vec\n              ; Can't use arg-1-zloc here as the if test, because when\n              ; formatting structures, arg-1-zloc might well be nil!\n              (if (not (zero? len))\n                (fzprint* loptions (+ l-str-len ind) arg-1-zloc)\n                :noseq)\n              ; Same here -- can't use arg-1-zloc as if test!!\n              (if (not (zero? len))\n                (let [zloc-seq-right-first (get-zloc-seq-right first-data)]\n                  (if zloc-seq-right-first\n                    ; We have something else to format after arg-1-zloc\n                    (if (and arg-1-indent (not= fn-style :flow))\n                      (let [result (fzprint-hang-remaining\n                                     caller\n                                     (noarg1 options fn-style)\n                                     arg-1-indent\n                                     (+ indent ind indent-adj)\n                                     ; Can't do this, because\n                                     ; hang-remaining\n                                     ; doesn't take a seq\n                                     zloc-seq-right-first\n                                     ;(znthnext zloc 0)\n                                     fn-style)]\n                        (dbg-pr options\n                                \"fzprint-list*: r-str-vec:\" r-str-vec\n                                \"result:\" result)\n                        result)\n                      ; This might be a collection as the first thing, or it\n                      ; might be a :flow type.  Do different indents for these.\n                      (let [local-indent (if (= fn-style :flow)\n                                           (+ indent ind)\n                                           (+ default-indent ind indent-adj))]\n                        (concat-no-nil ;[[(str \"\\n\" (blanks local-indent)) :none\n                                       ;:indent]]\n                          (fzprint-flow-seq (noarg1 options fn-style)\n                                            local-indent\n                                            ;(nthnext (zmap identity\n                                            ;zloc) 1)\n                                            zloc-seq-right-first\n                                            :force-nl\n                                            :newline-first))))\n                    ; Nothing else after arg-1-zloc\n                    :noseq))\n                :noseq)\n              r-str-vec))))\n\n(defn fzprint-list\n  \"Pretty print and focus style a :list element.\"\n  [options ind zloc]\n  (dbg-pr options \"fzprint-list\")\n  (fzprint-list* :list \"(\" \")\" (rightmost options) ind zloc))\n\n(defn fzprint-anon-fn\n  \"Pretty print and focus style a fn element.\"\n  [options ind zloc]\n  (dbg-pr options \"fzprint-anon-fn\")\n  (fzprint-list* :list \"#(\" \")\" (rightmost options) ind zloc))\n\n(defn any-zcoll?\n  \"Return true if there are any collections in the collection.\"\n  [options ind zloc]\n  (let [coll?-seq (zmap zcoll? zloc)] (reduce #(or %1 %2) nil coll?-seq)))\n\n;;\n;; # Put things on the same line\n;;\n\n(defn wrap-zmap\n  \"Given the output from fzprint-seq, which is a style-vec in\n  the making without spacing, but with extra [] around the elements,\n  wrap the elements to the right margin.\"\n  [caller\n   {:keys [width rightcnt],\n    {:keys [wrap-after-multi? respect-nl?]} caller,\n    :as options} ind coll-print]\n  #_(prn \"wrap-zmap:\" coll-print)\n  (let [last-index (dec (count coll-print))\n        rightcnt (fix-rightcnt rightcnt)]\n    (loop [cur-seq coll-print\n           cur-ind ind\n           index 0\n           previous-newline? false\n           ; transient here slows things down, interestingly enough\n           out []]\n      (if-not cur-seq\n        (do (dbg-pr options \"wrap-zmap: out:\" out) out)\n        (let [next-seq (first cur-seq)]\n          (when next-seq\n            (let [multi? (> (count (first cur-seq)) 1)\n                  this-seq (first cur-seq)\n                  _ (log-lines options \"wrap-zmap:\" ind this-seq)\n                  _ (dbg-pr options \"wrap-zmap: ind:\" ind \"this-seq:\" this-seq)\n                  [linecnt max-width lines] (style-lines options ind this-seq)\n                  last-width (last lines)\n                  len (- last-width ind)\n                  len (max 0 len)\n                  newline? (= (nth (first this-seq) 2) :newline)\n                  comment?\n                    (if respect-nl? nil (= (nth (first this-seq) 2) :comment))\n                  comment-inline? (if respect-nl?\n                                    nil\n                                    (= (nth (first this-seq) 2)\n                                       :comment-inline))\n                  width (if (= index last-index) (- width rightcnt) width)\n                  ; need to check size, and if one line and fits, should fit\n                  fit? (and (not newline?)\n                            (or (zero? index) (not comment?))\n                            (or (zero? index)\n                                (and (if multi? (= linecnt 1) true)\n                                     (<= (+ cur-ind len) width))))\n                  new-ind (cond\n                            ; Comments cause an overflow of the size\n                            (or comment? comment-inline?) (inc width)\n                            (and multi? (> linecnt 1) (not wrap-after-multi?))\n                              width\n                            fit? (+ cur-ind len 1)\n                            newline? ind\n                            :else (+ ind len 1))]\n              #_(prn \"------ this-seq:\" this-seq\n                     \"lines:\" lines\n                     \"linecnt:\" linecnt\n                     \"multi?\" multi?\n                     \"newline?:\" newline?\n                     \"previous-newline?:\" previous-newline?\n                     \"linecnt:\" linecnt\n                     \"max-width:\" max-width\n                     \"last-width:\" last-width\n                     \"len:\" len\n                     \"cur-ind:\" cur-ind\n                     \"new-ind:\" new-ind\n                     \"width:\" width\n                     \"fit?\" fit?)\n              ; need to figure out what to do with a comment,\n              ; want to force next line to not fit whether or not\n              ; this line fit.  Comments are already multi-line, and\n              ; it is really not clear what multi? does in this routine\n              (recur\n                (next cur-seq)\n                new-ind\n                (inc index)\n                newline?\n                ; TODO: concat-no-nil fails here, why?\n                (concat\n                  out\n                  (if fit?\n                    (if (not (zero? index))\n                      (concat-no-nil [[\" \" :none :whitespace 15]] this-seq)\n                      this-seq)\n                    (if newline?\n                      [[(str \"\\n\"\n                             ; Fix sets and vectors to have terminal right thing\n                             ; after a comment or newline be indented like other\n                             ; elements are.  Used to just be (blanks (dec\n                             ; new-ind))\n                             ; now the if checks to see if we are at the end,\n                             ; and does new-ind, which is like the other stuff.\n                             ; But wrong for the future of where we are going,\n                             ; as it happens.\n                             (blanks\n                               ; Figure out what the next thing is\n                               (let [this-seq-next (first (next cur-seq))\n                                     newline? (when this-seq-next\n                                                (= (nth (first this-seq-next) 2)\n                                                   :newline))]\n                                 ; If it is a newline, don't put any blanks on\n                                 ; this line\n                                 (if newline? 0 (dec new-ind))))) :none :indent\n                        21]]\n                      ; Unclear if a prepend-nl would be useful here...\n                      (if previous-newline?\n                        (concat-no-nil [[\" \" :none :whitespace 16]] this-seq)\n                        (prepend-nl options ind this-seq)))))))))))))\n\n(defn remove-nl\n  \"Remove any [_ _ :newline] from the seq.\"\n  [coll]\n  (remove #(= (nth (first %) 2) :newline) coll))\n\n(defn internal-validate\n  \"Validate an options map that was returned from some internal configuration\n  expression or configuration.  Either returns the options map or throws\n  an error.\"\n  [options error-str]\n  (let [errors (validate-options options)\n        errors (when errors\n                 (str \"Options resulting from \" error-str\n                      \" had these errors: \" errors))]\n    (if (not (empty? errors))\n      (throw (#?(:clj Exception.\n                 :cljs js/Error.)\n              errors))\n      options)))\n\n(defn lazy-sexpr-seq\n  [nws-seq]\n  (if (seq nws-seq)\n    (lazy-cat [(zsexpr (first nws-seq))] (lazy-sexpr-seq (rest nws-seq)))\n    []))\n\n(defn comment-in-zloc-seq?\n  \"If there are any comments at the top level of the zloc-seq, return true,\n  else nil.\"\n  [zloc-seq]\n  (reduce #(when (= (ztag %2) :comment) (reduced true)) false zloc-seq))\n\n(defn fzprint-vec*\n  \"Print basic stuff like a vector or a set or an array.  Several options \n  for how to print them.\"\n  [caller l-str r-str\n   {:keys [rightcnt in-code?],\n    {:keys [wrap-coll? wrap? binding? option-fn-first option-fn sort?\n            sort-in-code? fn-format indent]}\n      caller,\n    :as options} ind zloc]\n  (dbg options \"fzprint-vec* ind:\" ind \"indent:\" indent \"caller:\" caller)\n  (if (and binding? (= (:depth options) 1))\n    (fzprint-binding-vec options ind zloc)\n    (let [[respect-nl? respect-bl? indent-only?]\n            (get-respect-indent options caller :vector)\n          l-str-len (count l-str)\n          l-str-vec [[l-str (zcolor-map options l-str) :left]]\n          r-str-vec\n            (rstr-vec options (+ ind (max 0 (dec l-str-len))) zloc r-str)\n          len (zcount zloc)\n          new-options (when option-fn-first\n                        (let [first-sexpr (zsexpr (zfirst-no-comment zloc))]\n                          (internal-validate\n                            (option-fn-first options first-sexpr)\n                            (str \":vector :option-fn-first called with \"\n                                 first-sexpr))))\n          _ (when option-fn-first\n              (dbg-pr options\n                      \"fzprint-vec* option-fn-first new options\"\n                      new-options))\n          options (merge-deep options new-options)\n          new-options\n            (when option-fn\n              (let [nws-seq (remove zwhitespaceorcomment? (zseqnws zloc))\n                    nws-count (count nws-seq)\n                    sexpr-seq (lazy-sexpr-seq nws-seq)]\n                (internal-validate\n                  (option-fn options nws-count sexpr-seq)\n                  (str \":vector :option-fn called with sexpr count \"\n                       nws-count))))\n          _ (when option-fn\n              (dbg-pr options \"fzprint-vec* option-fn new options\" new-options))\n          {{:keys [wrap-coll? wrap? binding? respect-bl? respect-nl? sort?\n                   fn-format sort-in-code? indent indent-only?]}\n             caller,\n           :as options}\n            (merge-deep options new-options)]\n      (if fn-format\n        ; If we have fn-format, move immediately to fzprint-list* and\n        ; let :vector-fn configuration drive what we do (e.g., indent-only,\n        ; or whatever).  That is to say that :indent-only? in :vector doesn't\n        ; override option-fn-first or option-fn\n        (fzprint-list* :vector-fn\n                       \"[\"\n                       \"]\"\n                       (assoc options :fn-style fn-format)\n                       ind\n                       zloc)\n        (let [; If sort? is true, then respect-nl? and respect-bl? make\n              ; no sense.  And vice versa.\n              ; If respect-nl? or respect-bl?, then no sort.\n              ; If we have comments, then no sort, because we'll lose the\n              ; comment context.\n              indent (or indent (count l-str))\n              new-ind (if indent-only? ind (+ indent ind))\n              _ (dbg-pr options\n                        \"fzprint-vec*:\" (zstring zloc)\n                        \"new-ind:\" new-ind)\n              zloc-seq (cond (or respect-nl? indent-only?) (zmap-w-nl identity\n                                                                      zloc)\n                             respect-bl? (zmap-w-bl identity zloc)\n                             :else (zmap identity zloc))\n              zloc-seq (if (and sort?\n                                (if in-code? sort-in-code? true)\n                                (not (comment-in-zloc-seq? zloc-seq))\n                                (not respect-nl?)\n                                (not respect-bl?)\n                                (not indent-only?))\n                         (order-out caller options identity zloc-seq)\n                         zloc-seq)\n              coll-print (if (zero? len)\n                           [[[\"\" :none :whitespace 17]]]\n                           (fzprint-seq options new-ind zloc-seq))\n              _ (dbg-pr options \"fzprint-vec*: coll-print:\" coll-print)\n              ; If we got any nils from fzprint-seq and we were in :one-line\n              ; mode\n              ; then give up -- it didn't fit on one line.\n              coll-print (if-not (contains-nil? coll-print) coll-print)\n              one-line (when coll-print\n                         ; should not be necessary with contains-nil? above\n                         (apply concat-no-nil\n                           (interpose [[\" \" :none :whitespace 18]]\n                             ; This causes single line things to also respect-nl\n                             ; when it is enabled.  Could be separately\n                             ; controlled\n                             ; instead of with :respect-nl? if desired.\n                             (if (or respect-nl? :respect-bl? indent-only?)\n                               coll-print\n                               (remove-nl coll-print)))))\n              _ (log-lines options \"fzprint-vec*:\" new-ind one-line)\n              _ (dbg-pr options\n                        \"fzprint-vec*: new-ind:\" new-ind\n                        \"one-line:\" one-line)\n              one-line-lines (style-lines options new-ind one-line)]\n          (if (zero? len)\n            (concat-no-nil l-str-vec r-str-vec)\n            (when one-line-lines\n              (if (fzfit-one-line options one-line-lines)\n                (concat-no-nil l-str-vec one-line r-str-vec)\n                (if indent-only?\n                  ; Indent Only\n                  (concat-no-nil l-str-vec\n                                 (indent-zmap caller\n                                              options\n                                              ind\n                                              ; actual-ind\n                                              (+ ind l-str-len)\n                                              coll-print\n                                              indent)\n                                 r-str-vec)\n                  ; Regular Pprocessing\n                  (if (or (and (not wrap-coll?)\n                               (any-zcoll? options new-ind zloc))\n                          (not wrap?))\n                    (concat-no-nil\n                      l-str-vec\n                      (apply concat-no-nil\n                        (precede-w-nl options new-ind coll-print :no-nl-first))\n                      r-str-vec)\n                    ; Since there are either no collections in this vector or\n                    ; set\n                    ; or\n                    ; whatever, or if there are, it is ok to wrap them, print it\n                    ; wrapped on the same line as much as possible:\n                    ;           [a b c d e f\n                    ;            g h i j]\n                    (concat-no-nil\n                      l-str-vec\n                      (do (dbg-pr options\n                                  \"fzprint-vec*: wrap coll-print:\"\n                                  coll-print)\n                          (wrap-zmap caller options new-ind coll-print))\n                      r-str-vec)))))))))))\n\n(defn fzprint-vec\n  [options ind zloc]\n  (fzprint-vec* :vector \"[\" \"]\" (rightmost options) ind zloc))\n\n(defn fzprint-array\n  [options ind zloc]\n  (fzprint-vec* :array \"[\" \"]\" (rightmost options) ind zloc))\n\n(defn fzprint-set\n  \"Pretty print and focus style a :set element.\"\n  [options ind zloc]\n  (fzprint-vec* :set \"#{\" \"}\" (rightmost options) ind zloc))\n\n; not clear transient helps here\n(defn interpose-either\n  \"Do the same as interpose, but different seps depending on pred?.\n  If sep-nil is nil, then when pred? is false we don't interpose\n  anything!\"\n  [sep-true sep-nil pred? coll]\n  (loop [coll coll\n         out (transient [])\n         interpose? nil]\n    (if (empty? coll)\n      (persistent! out)\n      (recur (next coll)\n             (if interpose?\n               (conj-it! out sep-true (first coll))\n               (if (or (zero? (count out)) (nil? sep-nil))\n                 (conj! out (first coll))\n                 (conj-it! out sep-nil (first coll))))\n             (pred? (first coll))))))\n\n(defn precede-w-nl\n  \"Move through a sequence of style vecs and ensure that at least\n  one newline (actually an indent) appears before each element.  If\n  a newline in the style-vecs is where we wanted one, well and good.\n  Comments are now not recognized as different, increasing our\n  appreciation of diversity.  If not-first? is truthy, then don't\n  put a newline before the first element.\"\n  [options ind coll not-first?]\n  (dbg-pr options\n          \"precede-w-nl: (count coll)\" (count coll)\n          \"not-first?\" not-first?)\n  (loop [coll coll\n         ind-seq (if (coll? ind) ind (vector ind))\n         out (transient [])\n         added-nl? not-first?]\n    (if (empty? coll)\n      (let [result (persistent! out)\n            _ (dbg-pr options \"precede-w-nl: exit:\" result)\n            ; If the thing before the last was a comment, then remove the\n            ; last thing (which must be a newline, though we didn't put\n            ; it there)\n            previous-element-index (- (count result) 2)\n            previous-type (when (not (neg? previous-element-index))\n                            (nth (first (nth result previous-element-index))\n                                 2))]\n        result)\n      (let [[[s color what] :as element] (first coll)\n            ; This element may have many things in it, or sometimes\n            ; just one.\n            ;\n            ; I believe that if the first thing is a newline then they\n            ; must all be newlines.  We could check the last, or all of\n            ; them here, I suppose.  But these have to come from\n            ; fzprint-newline, to the best of my knowledge, and that is\n            ; how it works.\n            indent (first ind-seq)\n            newline? (= what :newline)\n            ; Let's make sure about the last\n            last-what (nth (last element) 2)]\n        (dbg-pr options \"precede-w-nl: element:\" element \"added-nl?:\" added-nl?)\n        (recur (next coll)\n               ; Move along ind-seq until we reach the last one, then just\n               ; keep using the last one.\n               (if-let [next-ind (next ind-seq)]\n                 next-ind\n                 ind-seq)\n               (if newline?\n                 ; It is a :newline, so just use it as it is.\n                 ; Except if the next thing out is also a newline, we'll have\n                 ; trailing spaces after this newline, which is unlovely.\n                 (let [next-coll (next coll)]\n                   (if (empty? next-coll)\n                     (conj! out element)\n                     (let [[[_ _ next-what]] (first next-coll)]\n                       (if (= next-what :newline)\n                         ; don't put out a newline with spaces before another\n                         ; newline\n                         (conj! out [[\"\\n\" color what]])\n                         (conj! out element)))))\n                 ; It is not a :newline, so we want to make sure we have a\n                 ; newline in front of it, unless we already have one..\n                 (if added-nl?\n                   ; We already have a newline in front of it\n                   (conj! out element)\n                   ; We need both a newline and the element\n                   (conj-it! out\n                             [[(str \"\\n\" (blanks indent)) :none :indent 28]]\n                             element)))\n               ; Is there a newline as the last thing we just did?\n               ; Two ways for that to happen.\n               newline?)))))\n\n(defn count-newline-types\n  \"Analyze a style-vec which contains only newlines, the count of newlines\n  in the style vec.  We assume that each :newline style-vec contains one\n  newline (i.e., it was generated by fzprint-newlines).\"\n  [newline-style-vec]\n  ; TODO: Take this out if we don't get any exceptions while testing.\n  (let [count-of-types (count (distinct (map #(nth % 2) newline-style-vec)))]\n    (when (or (not= count-of-types 1)\n              (not= (nth (first newline-style-vec) 2) :newline))\n      (throw\n        (#?(:clj Exception.\n            :cljs js/Error.)\n         (str \"count-newline-types: more than one type or wrong type! count:\"\n                count-of-types\n              \" style-vec:\" newline-style-vec))))\n    (count newline-style-vec)))\n\n(defn count-right-blanks\n  \"Count the number of blanks at the right end of a string.\"\n  [s]\n  (loop [i (count s)]\n    (if (neg? i)\n      (count s)\n      (if (clojure.string/ends-with? (subs s 0 i) \" \")\n        (recur (dec i))\n        (- (count s) i)))))\n\n(defn trimr-blanks\n  \"Trim only blanks off the right end of a string.\"\n  [s]\n  (loop [i (count s)]\n    (if (neg? i)\n      \"\"\n      (if (clojure.string/ends-with? (subs s 0 i) \" \")\n        (recur (dec i))\n        (subs s 0 i)))))\n\n(defn repeat-style-vec-nl\n  \"Given a count n, and style vec that ends with a newline and an associated\n  indent of some number of spaces, return a sequence of n of those style vecs\n  but remove spaces from all but the last of them.\"\n  [n style-vec]\n  (let [no-space-n (max (dec n) 0)]\n    (if (zero? no-space-n)\n      style-vec\n      (let [[s color what] (last style-vec)\n            no-space-element [(trimr-blanks s) color what]\n            no-space-style-vec\n              (into [] (concat (butlast style-vec) no-space-element))]\n        (into [] (concat (repeat no-space-n no-space-style-vec) style-vec))))))\n\n(defn trimr-blanks-element\n  \"Given an element, trim the blanks out of the string.\"\n  [[s color what]]\n  [(trimr-blanks s) color what])\n\n(defn trimr-blanks-style-vec\n  \"Given a style-vec, trim the blanks out of each element.\"\n  [style-vec]\n  (mapv trimr-blanks-element style-vec))\n\n(defn repeat-element-nl\n  \"Given a count n, and single element from a style-vec which\n  contains a newline and an indent of some number of spaces, return\n  a sequence of n of those style vecs but remove spaces from all\n  but the last of them.\"\n  [n element]\n  #_(prn \"repeat-element-nl: n:\" n \"element:\" element)\n  (let [no-space-n (max (dec n) 0)]\n    (if (zero? no-space-n)\n      [element]\n      (let [[s color what] element\n            no-space-element [(trimr-blanks s) color what]\n            result\n              (into [] (concat (repeat no-space-n no-space-element) [element]))]\n        #_(prn \"repeat-element-nl: result:\" result)\n        result))))\n\n(defn next-non-comment-nl\n  \"Given a coll of [hangflow style-vec] pairs, return the \n  [hangflow style-vec] pair where the style-vec is not a \n  :comment, :comment-inline, :newline or :indent.\"\n  [coll]\n  (loop [coll coll]\n    (if (empty? coll)\n      nil\n      (let [[_ style-vec] (first coll)\n            [_ _ what] (first style-vec)]\n        (if (or (= what :comment)\n                (= what :comment-inline)\n                (= what :indent)\n                (= what :newline))\n          (recur (next coll))\n          (first coll))))))\n\n; transient helped a lot here\n\n(defn interpose-either-nl-hf\n  \"Do very specialized interpose, but different seps depending on pred-fn\n  return and nl-separator?. This assumes that sep-* does one line, and\n  sep-*-nl does two lines.\"\n  [sep-comma sep-comma-nl sep sep-nl\n   {:keys [nl-separator? nl-separator-flow?], :as suboptions} ;nl-separator?\n   comma? coll]\n  #_(prn \"ienf: sep:\" sep \"comma?\" comma? \"coll:\" coll)\n  (loop [coll coll\n         out (transient [])\n         previous-needs-comma? nil\n         add-nl? nil\n         first? true\n         newline-count 0]\n    (if (empty? coll)\n      (apply concat-no-nil\n        (persistent!\n          (if (zero? newline-count)\n            out\n            (conj-it! out (repeat-element-nl newline-count (first sep))))))\n      (let [[hangflow style-vec] (first coll)\n            [_ _ what] (first style-vec)]\n        #_(prn \"====>>>>>>>> interpose-either-nl-hf: style-vec:\" style-vec)\n        (cond\n          (= what :newline)\n            ; We have a one or more newlines.  We are going to keep\n            ; track of what we've seen and will actually output things\n            ; later, when we know what we actually have.\n            ; For now, just increase the count and don't do anything\n            ; else.\n            (recur (next coll)\n                   out\n                   previous-needs-comma?\n                   add-nl?\n                   first?\n                   (+ newline-count (count-newline-types style-vec)))\n          :else\n            ; We have a normal style-vec that we will process.  This one\n            ; has no newlines.  But we might have seen plenty of newlines\n            ; before this -- or not.\n            (let [[interpose-style-vec interpose-count]\n                    (if previous-needs-comma?\n                      (if add-nl? [sep-comma-nl 2] [sep-comma 1])\n                      (if add-nl? [sep-nl 2] [sep 1]))\n                  ; if first? we assume that we get one newline from caller\n                  interpose-count (if first? 1 interpose-count)\n                  addtl-nl-needed (max (- newline-count interpose-count) 0)]\n              ; Here is where we need to figure out if two newlines are\n              ; coming out in order, and ensure that the first ones don't\n              ; have any spaces after them.\n              #_(prn \"ienf: interpose-style-vec:\" interpose-style-vec)\n              (recur\n                (next coll)\n                (if first?\n                  (if (zero? addtl-nl-needed)\n                    (conj! out style-vec)\n                    (conj-it! out\n                              (repeat-element-nl addtl-nl-needed (first sep))\n                              style-vec))\n                  (if (zero? addtl-nl-needed)\n                    (conj-it! out interpose-style-vec style-vec)\n                    (conj-it! out\n                              (trimr-blanks-style-vec interpose-style-vec)\n                              (repeat-element-nl addtl-nl-needed (first sep))\n                              style-vec)))\n                (and comma?\n                     ; We got rid of newlines above\n                     (not= what :comment)\n                     (not= what :comment-inline)\n                     ; Is there a non comment or non newline/indent\n                     ; element\n                     ; left in coll, or is this the last one?\n                     ; This returns the [hangflow style-vec], but we\n                     ; are not\n                     ; using the data, just the existence of the thing\n                     ; here\n                     ; Fix for Issue #137.\n                     (next-non-comment-nl (next coll)))\n                ; should we put an extra new-line before the next\n                ; element?\n                ; Two styles here:\n                ;  o  always put one if the previous pair contained a\n                ;  new-line\n                ;     which could be (but is not) the default\n                ;     To do this you would do:\n                ;       (and nl-separator? (not (single-line?\n                ;       style-vec)))\n                ;  o  put one only if the previous right hand part of\n                ;  the\n                ;     pair did a flow (which is the current default)\n                ;     To do this, you look for whether or not the\n                ;     return\n                ;     from fzprint-map-two-up said it was a flow\n                (and nl-separator? (= hangflow :flow))\n                nil ;first?\n                0 ;newline-count\n              )))))))\n\n(defn interpose-nl-hf\n  \"Put a single or double line between pairs returned from\n  fzprint-map-two-up.  The second argument is the map resulting\n  from (:map options) or (:pair options) or whatever.  It should\n  have :nl-separator? and :nl-separator-flow? in it.\"\n  [suboptions ind coll]\n  (interpose-either-nl-hf nil\n                          nil\n                          [[(str \"\\n\" (blanks ind)) :none :indent 29]]\n                          [[(str \"\\n\") :none :indent 30]\n                           [(str \"\\n\" (blanks ind)) :none :indent 31]]\n                          suboptions\n                          nil ; comma?\n                          coll))\n\n(defn fzprint-map*\n  [caller l-str r-str\n   {:keys [one-line? ztype map-depth in-code?],\n    {:keys [comma? key-ignore key-ignore-silent nl-separator? force-nl? lift-ns?\n            lift-ns-in-code? indent],\n     :as map-options}\n      caller,\n    :as options} ind zloc ns]\n  (let [[respect-nl? respect-bl? indent-only?]\n          (get-respect-indent options caller :map)]\n    (dbg-pr options \"fzprint-map* caller:\" caller)\n    (if indent-only?\n      (let [options (assoc options :map-depth (inc map-depth))\n            l-str-vec [[l-str (zcolor-map options l-str) :left]]\n            r-str-vec (rstr-vec options ind zloc r-str)]\n        (if (zero? (zcount zloc))\n          (concat-no-nil l-str-vec r-str-vec)\n          (concat-no-nil l-str-vec\n                         (fzprint-indent caller\n                                         l-str\n                                         r-str\n                                         options\n                                         ind\n                                         zloc\n                                         nil ;fn-style\n                                         nil) ;arg-1-indent, will prevent hang\n                         r-str-vec)))\n      (let [options (assoc options :map-depth (inc map-depth))\n            zloc (if (and (= ztype :sexpr) (or key-ignore key-ignore-silent))\n                   (map-ignore caller options zloc)\n                   zloc)\n            [no-sort? pair-seq] (partition-all-2-nc\n                                  (no-max-length options)\n                                  (cond respect-nl? (zseqnws-w-nl zloc)\n                                        respect-bl? (zseqnws-w-bl zloc)\n                                        :else (zseqnws zloc)))\n            #_(dbg-pr \"fzprint-map* pair-seq:\"\n                      (map (comp zstring first) pair-seq))\n            ; don't sort if we are doing respect-nl?\n            no-sort? (or no-sort? respect-nl? respect-bl?)\n            [ns lift-pair-seq]\n              (zlift-ns (assoc map-options :in-code? in-code?) pair-seq ns)\n            _ (dbg-pr options \"fzprint-map* zlift-ns ns:\" ns)\n            l-str (if ns (str \"#\" ns l-str) l-str)\n            pair-seq (or lift-pair-seq pair-seq)\n            pair-seq\n              (if no-sort? pair-seq (order-out caller options first pair-seq))\n            ; This is where you might put max-length\n            max-length (get-max-length options)\n            pair-count (count pair-seq)\n            pair-seq (if (> pair-count max-length)\n                       (concat (take max-length pair-seq)\n                               (list (list (zdotdotdot))))\n                       pair-seq)\n            indent (count l-str)\n            l-str-vec [[l-str (zcolor-map options l-str) :left]]\n            r-str-vec (rstr-vec options ind zloc r-str)]\n        (if (empty? pair-seq)\n          (concat-no-nil l-str-vec r-str-vec)\n          (let [_ (dbg-pr options\n                          \"fzprint-map*:\" (zstring zloc)\n                          \"ind:\" ind\n                          \"comma?\" comma?\n                          \"rightcnt:\" (:rightcnt options))\n                ; A possible one line representation of this map, but this is\n                ; optimistic and needs to be validated.\n                pair-print-one-line\n                  (fzprint-map-two-up\n                    caller\n                    (if one-line? options (assoc options :one-line? true))\n                    (+ indent ind)\n                    comma?\n                    pair-seq)\n                pair-print-one-line (remove-hangflow pair-print-one-line)\n                ; Does it fit on line line?\n                pair-print-one-line (when (fzfit-one-line\n                                            options\n                                            (style-lines options\n                                                         (+ indent ind)\n                                                         pair-print-one-line))\n                                      pair-print-one-line)\n                one-line (when pair-print-one-line\n                           (apply concat-no-nil\n                             (interpose-either [[\",\" (zcolor-map options :comma)\n                                                 :whitespace 19]\n                                                [\" \" :none :whitespace 23]]\n                                               [[\" \" :none :whitespace 20]]\n                                               (constantly comma?)\n                                               pair-print-one-line)))\n                one-line-lines (style-lines options (+ indent ind) one-line)\n                one-line (when (fzfit-one-line options one-line-lines)\n                           one-line)]\n            (if one-line\n              (concat-no-nil l-str-vec one-line r-str-vec)\n              ; It didn't fit on one line.\n              (when (not one-line?)\n                ; We weren't required to fit it on one line\n                (let [pair-print (fzprint-map-two-up caller\n                                                     options\n                                                     (+ indent ind)\n                                                     comma?\n                                                     pair-seq)]\n                  (concat-no-nil\n                    l-str-vec\n                    (interpose-either-nl-hf\n                      ; comma? true\n                      [[\",\" (zcolor-map options :comma) :whitespace 21]\n                       [(str \"\\n\" (blanks (inc ind))) :none :indent 32]]\n                      [[\",\" (zcolor-map options :comma) :whitespace 22]\n                       ; Fix issue #59 -- don't\n                       ; put blanks to indent before the next \\n\n                       [\"\\n\" :none :indent 33]\n                       [(str \"\\n\" (blanks (inc ind))) :none :indent 34]]\n                      ; comma? nil\n                      [[(str \"\\n\" (blanks (inc ind))) :none :indent 35]]\n                      [[\"\\n\" :none :indent 36]\n                       [(str \"\\n\" (blanks (inc ind))) :none :indent 37]]\n                      (:map options) ;nl-separator?\n                      comma?\n                      pair-print)\n                    r-str-vec))))))))))\n\n(defn fzprint-map\n  \"Format a real map.\"\n  [options ind zloc]\n  (let [[ns lifted-map]\n          (when (znamespacedmap? zloc)\n            ; Only true when operating on zippers\n            (let [zloc-seq (zmap identity zloc)]\n              (dbg-pr options \"fzprint-map: zloc-seq\" (map zstring zloc-seq))\n              [(zstring (first zloc-seq)) (second zloc-seq)]))]\n    (dbg-pr options\n            \"fzprint-map: ns:\" ns\n            \"indent:\" (:indent (:map options))\n            \"map-options:\" (:map options))\n    (if ns\n      (fzprint-map* :map\n                    \"{\"\n                    #_(str \"#\" ns \"{\")\n                    \"}\"\n                    (rightmost options)\n                    ind\n                    lifted-map\n                    ns)\n      (fzprint-map* :map \"{\" \"}\" (rightmost options) ind zloc nil))))\n\n(defn object-str?\n  \"Return true if the string starts with #object[\"\n  [s]\n  (re-find #\"^#object\\[\" s))\n\n(defn fzprint-object\n  \"Print something that looks like #object[...] in a way\n  that will acknowledge the structure inside of the [...]\"\n  ([options ind zloc zloc-value]\n   (fzprint-vec* :object\n                 \"#object[\"\n                 \"]\"\n                 options\n                 ind\n                 (zobj-to-vec zloc zloc-value)))\n  ([options ind zloc]\n   (fzprint-vec* :object \"#object[\" \"]\" options ind (zobj-to-vec zloc))))\n\n(defn hash-identity-str\n  \"Find the hash-code identity for an object.\"\n  [obj]\n  #?(:clj (Integer/toHexString (System/identityHashCode obj))\n     :cljs (str (hash obj))))\n\n; (with-out-str\n;    (printf \"%08x\" (System/identityHashCode obj))))\n\n(defn fzprint-atom\n  [{{:keys [object?]} :atom, :as options} ind zloc]\n  (if (and object? (object-str? (zstring zloc)))\n    (fzprint-object options ind zloc (zderef zloc))\n    (let [l-str \"#<\"\n          r-str \">\"\n          indent (count l-str)\n          l-str-vec [[l-str (zcolor-map options l-str) :left]]\n          r-str-vec (rstr-vec options ind zloc r-str)\n          arg-1 (str \"Atom@\" (hash-identity-str zloc))\n          arg-1-indent (+ ind indent 1 (count arg-1))]\n      (dbg-pr options\n              \"fzprint-atom: arg-1:\" arg-1\n              \"zstring arg-1:\" (zstring zloc))\n      (concat-no-nil l-str-vec\n                     [[arg-1 (zcolor-map options :none) :element]]\n                     (fzprint-hang-one :unknown\n                                       (rightmost options)\n                                       arg-1-indent\n                                       (+ indent ind)\n                                       (zderef zloc))\n                     r-str-vec))))\n\n(defn fzprint-future-promise-delay-agent\n  \"Print out a future or a promise or a delay.  These can only be \n  sexpressions, since they don't exist in a textual representation \n  of code (or data for that matter).  That means that we can use \n  regular sexpression operations on zloc.\"\n  [options ind zloc]\n  (let [zloc-type (cond (zfuture? zloc) :future\n                        (zpromise? zloc) :promise\n                        (zdelay? zloc) :delay\n                        (zagent? zloc) :agent\n                        :else (throw (#?(:clj Exception.\n                                         :cljs js/Error.)\n                                      \"Not a future, promise, or delay:\"\n                                      (zstring zloc))))]\n    (if (and (:object? (options zloc-type)) (object-str? (zstring zloc)))\n      (if (or (= zloc-type :agent) (realized? zloc))\n        (fzprint-object options ind zloc (zderef zloc))\n        (fzprint-object options ind zloc))\n      (let [l-str \"#<\"\n            r-str \">\"\n            indent (count l-str)\n            l-str-vec [[l-str (zcolor-map options l-str) :left]]\n            r-str-vec (rstr-vec options ind zloc r-str)\n            type-str (case zloc-type\n                       :future \"Future@\"\n                       :promise \"Promise@\"\n                       :delay \"Delay@\"\n                       :agent \"Agent@\")\n            arg-1 (str type-str (hash-identity-str zloc))\n            #?@(:clj [arg-1\n                      (if (and (= zloc-type :agent) (agent-error zloc))\n                        (str arg-1 \" FAILED\")\n                        arg-1)])\n              arg-1-indent\n            (+ ind indent 1 (count arg-1)) zloc-realized?\n            (if (= zloc-type :agent) true (realized? zloc)) value\n            (if zloc-realized?\n              (zderef zloc)\n              (case zloc-type\n                :future \"pending\"\n                :promise \"not-delivered\"\n                :delay \"pending\"))\n              options\n            (if zloc-realized? options (assoc options :string-str? true))]\n        (dbg-pr options\n                \"fzprint-fpda: arg-1:\" arg-1\n                \"zstring arg-1:\" (zstring zloc))\n        (concat-no-nil l-str-vec\n                       [[arg-1 (zcolor-map options :none) :element]]\n                       (fzprint-hang-one :unknown\n                                         (rightmost options)\n                                         arg-1-indent\n                                         (+ indent ind)\n                                         value)\n                       r-str-vec)))))\n\n(defn fzprint-fn-obj\n  \"Print a function object, what you get when you put a function in\n  a collection, for instance.  This doesn't do macros, you will notice.\n  It also can't be invoked when zloc is a zipper.\"\n  [{{:keys [object?]} :fn-obj, :as options} ind zloc]\n  (if (and object? (object-str? (zstring zloc)))\n    (fzprint-object options ind zloc)\n    (let [l-str \"#<\"\n          r-str \">\"\n          indent (count l-str)\n          l-str-vec [[l-str (zcolor-map options :fn) :left]]\n          r-str-vec (rstr-vec options ind zloc r-str :fn)\n          arg-1-left \"Fn@\"\n          arg-1-right (hash-identity-str zloc)\n          arg-1-indent (+ ind indent 1 (count arg-1-left) (count arg-1-right))\n          class-str (pr-str #?(:clj (class zloc)\n                               :cljs (type zloc)))\n          #?@(:clj [[class-name & more]\n                    (s/split (s/replace-first class-str #\"\\$\" \"/\") #\"\\$\") color\n                    (if (re-find #\"clojure\" class-name)\n                      (zcolor-map options :fn)\n                      :none) arg-2 (str class-name (when more \"[fn]\"))]\n              :cljs [name-js (str (.-name zloc)) color\n                     (if (or (re-find #\"^clojure\" name-js)\n                             (re-find #\"^cljs\" name-js))\n                       (zcolor-map options :fn)\n                       :none) name-split (clojure.string/split name-js #\"\\$\")\n                     arg-2\n                     (str (apply str (interpose \".\" (butlast name-split)))\n                          \"/\"\n                          (last name-split))])]\n      (dbg-pr options\n              \"fzprint-fn-obj: arg-1:\"\n              arg-1-left\n              arg-1-right\n              \"zstring arg-1:\"\n              (zstring zloc))\n      (concat-no-nil l-str-vec\n                     [[arg-1-left (zcolor-map options :fn) :element]]\n                     [[arg-1-right (zcolor-map options :none) :element]]\n                     (fzprint-hang-one :unknown\n                                       (rightmost (assoc options\n                                                    :string-str? true\n                                                    :string-color color))\n                                       arg-1-indent\n                                       (+ indent ind)\n                                       arg-2)\n                     r-str-vec))))\n\n(defn fzprint-ns\n  [options ind zloc]\n  (let [l-str \"#<\"\n        r-str \">\"\n        indent (count l-str)\n        l-str-vec [[l-str (zcolor-map options l-str) :left]]\n        r-str-vec (rstr-vec options ind zloc r-str)\n        arg-1 \"Namespace\"\n        arg-1-indent (+ ind indent 1 (count arg-1))]\n    (dbg-pr options \"fzprint-ns: arg-1:\" arg-1 \"zstring arg-1:\" (zstring zloc))\n    (concat-no-nil l-str-vec\n                   [[arg-1 (zcolor-map options :none) :element]]\n                   (fzprint-hang-one :unknown\n                                     (rightmost options)\n                                     arg-1-indent\n                                     (+ indent ind)\n                                     (ns-name zloc))\n                   r-str-vec)))\n\n(defn dec-depth\n  \"Given an options map, decrement the :depth value and return the result.\"\n  [options]\n  (when options (assoc options :depth (dec (or (:depth options) 1)))))\n\n(defn fzprint-record\n  [{{:keys [record-type? to-string?]} :record, :as options} ind zloc]\n  (if to-string?\n    (fzprint* options ind (. zloc toString))\n    (if-not record-type?\n      ; if not printing as record-type, turn it into map\n      (fzprint* options ind (into {} zloc))\n      (let [l-str \"#\"\n            r-str \"\"\n            indent (count l-str)\n            l-str-vec [[l-str (zcolor-map options l-str) :left]]\n            r-str-vec (rstr-vec options ind zloc r-str)\n            arg-1 #?(:clj (pr-str (class zloc))\n                     :cljs\n                       (clojure.string/replace (pr-str (type zloc)) \"/\" \".\"))\n            arg-1 (let [tokens (clojure.string/split arg-1 #\"\\.\")]\n                    (apply str (into [] (interpose \".\" tokens))))\n            arg-1-indent (+ ind indent 1 (count arg-1))]\n        (dbg-pr options\n                \"fzprint-record: arg-1:\" arg-1\n                \"zstring zloc:\" (zstring zloc))\n        (concat-no-nil l-str-vec\n                       [[arg-1 (zcolor-map options :none) :element]]\n                       (fzprint-hang-one :record\n                                         (dec-depth options)\n                                         ;(rightmost options)\n                                         arg-1-indent\n                                         (+ indent ind)\n                                         ; this only works because\n                                         ; we never actually get here\n                                         ; with a zipper, just an sexpr\n                                         (into {} zloc))\n                       r-str-vec)))))\n\n(defn fzprint-meta\n  \"Print the two items in a meta node.  Different because it doesn't print\n  a single collection, so it doesn't do any indent or rightmost.  It also\n  uses a different approach to calling fzprint-flow-seq with the\n  results zmap, so that it prints all of the seq, not just the rightmost.\"\n  [options ind zloc]\n  (let [l-str \"^\"\n        r-str \"\"\n        l-str-vec [[l-str (zcolor-map options l-str) :left]]\n        r-str-vec (rstr-vec options ind zloc r-str)]\n    (dbg-pr options \"fzprint-meta: zloc:\" (zstring zloc))\n    (concat-no-nil\n      l-str-vec\n      (if (:indent-only? (:list options))\n        ; Since l-str isn't a \"pair\" and shouldn't be considered in the\n        ; indent, we don't tell fzprint-indent abouit.\n        (fzprint-indent :vector\n                        l-str\n                        \"\"\n                        options\n                        ind\n                        zloc\n                        nil\n                        nil\n                        :first-indent-only?)\n        (fzprint-flow-seq\n          ; No rightmost, because this isn't a collection.\n          ; This is essentially two separate things.\n          options\n          ; no indent for second line, as the leading ^ is\n          ; not a normal collection beginning\n          ; TODO: change this to (+ (count l-str) ind)\n          (apply vector (+ (count l-str) ind) (repeat (dec (zcount zloc)) ind))\n          ;[(inc ind) ind]\n          (fzprint-get-zloc-seq :list options zloc)))\n      r-str-vec)))\n\n(defn fzprint-reader-macro\n  \"Print a reader-macro, often a reader-conditional. Adapted for differences\n  in parsing #?@ between rewrite-clj and rewrite-cljs.  Also adapted for\n  the rewrite-clj not parsing namespaced maps in the version presently\n  used.\"\n  [options ind zloc]\n  (let [zstr (zstring (zfirst zloc))\n        ; rewrite-cljs parses #?@ differently from rewrite-clj.  In\n        ; rewrite-cljs zfirst is ?@, not ?, so deal with that.\n        ; Not clear which is correct, I could see it go either way.\n        alt-at? (and (= (count zstr) 2) (= (subs zstr 1 2) \"@\"))\n        reader-cond? (= (subs zstr 0 1) \"?\")\n        ; are we dealing with a namespaced map?\n        ; 5/30/19 I don't know if we ever encounter this anymore...\n        ; Was unable to get namespaced? to be true despite running all 616\n        ; tests and some repl testing as well.\n        namespaced? (= (subs zstr 0 1) \":\")\n        at? (or (= (ztag (zsecond zloc)) :deref) alt-at?)\n        ; If :reader-cond doesn't have these things, then let :map govern\n        [respect-nl? respect-bl? indent-only?]\n          (get-respect-indent options :reader-cond :map)\n        l-str (cond (and reader-cond? at?) \"#?@\"\n                    (and reader-cond? (zcoll? (zsecond zloc))) \"#?\"\n                    reader-cond?\n                      (throw (#?(:clj Exception.\n                                 :cljs js/Error.)\n                              (str \"Unknown reader macro: '\" (zstring zloc)\n                                   \"' zfirst zloc: \" (zstring (zfirst zloc)))))\n                    namespaced? (str \"#\" zstr)\n                    :else \"#\")\n        r-str \"\"\n        ; Error to debug zpst\n        _ (when (:dbg-bug? options)\n            #?(:clj (+ \"a\" \"b\")\n               :cljs nil))\n        indent (count l-str)\n        ; we may want to color this based on something other than\n        ; its actual character string\n        l-str-vec [[l-str (zcolor-map options l-str) :left]]\n        r-str-vec (rstr-vec options ind zloc r-str)\n        floc\n          (if (and at? (not alt-at?)) (zfirst (zsecond zloc)) (zsecond zloc))]\n    (dbg-pr options\n            \"fzprint-reader-macro: zloc:\" (zstring zloc)\n            \"floc:\" (zstring floc)\n            \"l-str:\" l-str)\n    ; This isn't really all that correct, but does yield the right output.\n    ; Question about whether or not it does the right stuff for focus.\n    ; Maybe there is some way to call fzprint-indent with just the\n    ; #? and \"\", and let it deal with the underlying list. I don't know\n    ; if that would be possible, though maybe if we carefully positioned\n    ; the floc for that case.  But could we hack in the [\"\" :none :element]\n    ; in that case? At present documented that focus and :indent-only\n    ; don't work together..\n    (if indent-only?\n      (let [l-str-io (if reader-cond? (str l-str \"(\") l-str)\n            r-str-io (if reader-cond? \")\" \"\")\n            l-str-vec-io [[l-str-io (zcolor-map options l-str-io) :left]]\n            r-str-vec-io (rstr-vec options ind zloc r-str-io)]\n        (concat-no-nil\n          l-str-vec-io\n          (if reader-cond?\n            (fzprint-indent :map\n                            l-str-io\n                            r-str-io\n                            (rightmost options)\n                            ind\n                            floc\n                            nil ;fn-style\n                            nil) ;arg-1-indent, will prevent hang\n            (fzprint-indent :map\n                            l-str-io\n                            r-str-io\n                            (rightmost options)\n                            ind\n                            (if namespaced? (znextnws-w-nl zloc) zloc)\n                            nil ; fn-style\n                            nil) ;arg-1-indent\n          )\n          r-str-vec-io))\n      (concat-no-nil\n        l-str-vec\n        ; Because there is a token here in the zipper, we need something to\n        ; make the focus positioning come out right.\n        [[\"\" :none :element]]\n        (if reader-cond?\n          ; yes rightmost, this is a collection\n          (fzprint-map* :reader-cond\n                        \"(\"\n                        \")\"\n                        (rightmost options)\n                        (+ indent ind)\n                        floc\n                        nil)\n          ; not reader-cond?\n          (fzprint-flow-seq options\n                            (+ indent ind)\n                            (let [zloc-seq\n                                    (cond respect-nl? (zmap-w-nl identity zloc)\n                                          respect-bl? (zmap-w-bl identity zloc)\n                                          :else (zmap identity zloc))]\n                              (if namespaced? (next zloc-seq) zloc-seq))))\n        r-str-vec))))\n\n(defn fzprint-newline\n  \"Given an element which contains newlines, split it up into individual\n  newline elements.\"\n  [options ind zloc]\n  (let [zstr (zstring zloc)\n        [newline-count _] (newline-vec zstr)]\n    (dbg-pr options\n            \"fzprint-newline: zloc:\" (zstring zloc)\n            \"newline-count:\" newline-count\n            \"ind:\" ind)\n    (into []\n          (repeat newline-count [(str \"\\n\" (blanks ind)) :none :newline 2]))))\n\n(def prefix-tags\n  {:quote \"'\",\n   :syntax-quote \"`\",\n   :unquote \"~\",\n   :unquote-splicing \"~@\",\n   :deref \"@\",\n   :var \"#'\",\n   :uneval \"#_\"})\n\n(defn prefix-options\n  \"Change options as necessary based on prefix tag.\"\n  [options prefix-tag]\n  (cond (= prefix-tag :uneval) (assoc options\n                                 :color-map (:color-map (:uneval options)))\n        (= prefix-tag :syntax-quote)\n          (-> options\n              (assoc-in [:color-map :paren]\n                        (:syntax-quote-paren (:color-map options)))\n              (assoc-in [:color-map :hash-paren]\n                        (:syntax-quote-paren (:color-map options))))\n        :else options))\n\n(defn make-caller\n  \"Sometime we need to give a caller to a routine, and there isn't\n  a specific caller in the configuration.  So, we will use the configuration\n  from some other caller and make up a new one just for this situation.\n  The key-seq is the series of keys to both look up and create.  The\n  caller is the new caller, and the existing-caller is the one from which\n  we we will extract the information. This returns a new options map with\n  the new-caller in it.\"\n  [options new-caller existing-caller key-seq]\n  (update-in options\n             (concat [new-caller] key-seq)\n             #(do % (get-in options (concat [existing-caller] key-seq)))))\n\n(declare inlinecomment?)\n\n;; Fix fzprint* to look at cursor to see if there is one, and\n;; fzprint to set cursor with binding.  If this works, might pass\n;; it around.  Maybe pass ctx to everyone and they can look at it\n;; or something.  But for testing, let's just do this.\n\n;;\n;; # The center of the zprint universe\n;;\n;; Looked into alternative ways to dispatch this, but at the end of\n;; the day, this looked like the best.\n;;\n\n(defn fzprint*\n  \"The pretty print part of fzprint.\"\n  [{:keys [width rightcnt fn-map hex? shift-seq dbg? dbg-print? in-hang?\n           one-line? string-str? string-color depth max-depth trim-comments?\n           in-code? max-hang-depth max-hang-span max-hang-count next-inner],\n    :as options} indent zloc]\n  (let [avail (- width indent)\n        ; note that depth affects how comments are printed, toward the end\n        options (assoc options :depth (inc depth))\n        options (if next-inner\n                  (dissoc\n                    (first (zprint.config/config-and-validate \"next-inner:\"\n                                                              nil\n                                                              options\n                                                              next-inner))\n                    :next-inner)\n                  options)\n        options (if (or dbg? dbg-print?)\n                  (assoc options\n                    :dbg-indent (str (get options :dbg-indent \"\")\n                                     (cond one-line? \"o\"\n                                           in-hang? \"h\"\n                                           :else \".\")))\n                  options)\n        _ (dbg options\n               \"fzprint* **** rightcnt:\"\n               rightcnt\n               \"depth:\"\n               depth\n               \"in-hang?:\"\n               in-hang?\n               (pr-str (zstring zloc)))\n        dbg-data @fzprint-dbg\n        dbg-focus? (and dbg? (= dbg-data (second (zfind-path zloc))))\n        options (if dbg-focus? (assoc options :dbg :on) options)\n        _ (if dbg-focus? (println \"fzprint dbg-data:\" dbg-data))]\n    #_(def zlocx zloc)\n    ; We don't check depth if it is not a collection.  We might have\n    ; just not incremented depth if it wasn't a collection, but this\n    ; may be equivalent.\n    (cond\n      (and (zcoll? zloc)\n           (or (>= depth max-depth) (zero? (get-max-length options))))\n        (if (= zloc (zdotdotdot))\n          [[\"...\" (zcolor-map options :none) :element]]\n          [[(:max-depth-string options) (zcolor-map options :keyword)\n            :element]])\n      ; Try to fix up runaway exponential time increases with very deep\n      ; strucures.  Note this is typically only affects maps, but it would\n      ; affect lists that were not code.\n      (and in-hang?\n           (not one-line?)\n           (not in-code?)\n           ;(> (/ indent width) 0.3)\n           (or (> (- depth in-hang?) max-hang-span)\n               (and (not one-line?)\n                    (> (zcount zloc) max-hang-count)\n                    (> depth max-hang-depth))))\n        nil\n      (zrecord? zloc) (fzprint-record options indent zloc)\n      (zlist? zloc) (fzprint-list options indent zloc)\n      (zvector? zloc) (fzprint-vec options indent zloc)\n      (or (zmap? zloc) (znamespacedmap? zloc)) (fzprint-map options indent zloc)\n      (zset? zloc) (fzprint-set options indent zloc)\n      (zanonfn? zloc) (fzprint-anon-fn options indent zloc)\n      (zfn-obj? zloc) (fzprint-fn-obj options indent zloc)\n      (zarray? zloc)\n        (if (:object? (:array options))\n          (fzprint-object options indent zloc)\n          (fzprint-array #?(:clj (if (:hex? (:array options))\n                                   (assoc options\n                                     :hex? (:hex? (:array options))\n                                     :shift-seq (zarray-to-shift-seq zloc))\n                                   options)\n                            :cljs options)\n                         indent\n                         (zexpandarray zloc)))\n      (zatom? zloc) (fzprint-atom options indent zloc)\n      (zmeta? zloc) (fzprint-meta options indent zloc)\n      (prefix-tags (ztag zloc))\n        (fzprint-vec* :prefix-tags\n                      (prefix-tags (ztag zloc))\n                      \"\"\n                      ; Pick up the :indent-only?, :respect-nl?, and\n                      ; respect-bl? config from :list\n                      ; Note that the routine get-respect-indent exists,\n                      ; and its use in fzprint-vec* and fzprint-map* also\n                      ; solves a similar problem\n                      (-> (prefix-options options (ztag zloc))\n                          (make-caller :prefix-tags :list [:indent-only?])\n                          (make-caller :prefix-tags :list [:respect-nl?])\n                          (make-caller :prefix-tags :list [:respect-bl?]))\n                      indent\n                      zloc)\n      (zns? zloc) (fzprint-ns options indent zloc)\n      (or (zpromise? zloc) (zfuture? zloc) (zdelay? zloc) (zagent? zloc))\n        (fzprint-future-promise-delay-agent options indent zloc)\n      (zreader-macro? zloc) (fzprint-reader-macro options indent zloc)\n      ; This is needed to not be there for newlines in parse-string-all,\n      ; but is needed for respect-nl? support.\n      ;(and (= (ztag zloc) :newline) (> depth 0)) [[\"\\n\" :none :newline]]\n      (and (= (ztag zloc) :newline) (> depth 0))\n        (fzprint-newline options indent zloc)\n      :else\n        (let [zstr (zstring zloc)\n              overflow-in-hang? (and in-hang?\n                                     (> (+ (count zstr) indent (or rightcnt 0))\n                                        width))]\n          (cond\n            (and (zcomment? zloc)\n                 #_(not (clojure.string/starts-with? \";\" zstr))\n                 (not (some #{\\;} zstr)))\n              ; We should remvoe them when we get zutil fixed.\n              (fzprint-newline options indent zloc)\n            (zcomment? zloc)\n              (let [zcomment\n                      ; trim-comments? is true for parse-string-all\n                      (if (and (zero? depth) (not trim-comments?))\n                        zstr\n                        ; Remove trailing newlines and spaces\n                        (clojure.string/trimr zstr))\n                    ; Only check for inline comments if we are doing them\n                    ; otherwise we get left with :comment-inline element\n                    ; types that don't go away\n                    inline-comment-vec (when (:inline? (:comment options))\n                                         (inlinecomment? zloc))]\n                (dbg options\n                     \"fzprint* trim-comments?:\" trim-comments?\n                     \"inline-comment-vec:\" inline-comment-vec)\n                (if (and (:count? (:comment options)) overflow-in-hang?)\n                  (do (dbg options \"fzprint*: overflow comment ========\") nil)\n                  (if inline-comment-vec\n                    [[zcomment (zcolor-map options :comment) :comment-inline\n                      (first inline-comment-vec) (second inline-comment-vec)]]\n                    [[zcomment (zcolor-map options :comment) :comment]])))\n            (= (ztag zloc) :comma) [[zstr (zcolor-map options :comma) :comma]]\n            #?@(:cljs [(and (= (ztag zloc) :whitespace)\n                            (clojure.string/includes? zstr \",\"))\n                       [[\",\" (zcolor-map options :comma) :comma]]])\n              ; Really just testing for whitespace, comments filtered above\n              (zwhitespaceorcomment? zloc)\n            [[zstr :none :whitespace 24]]\n              ; At this point, having filtered out whitespace and\n              ; comments above, now we expect zsexpr will work for all of\n              ; the remaining things.\n              ;\n              ; If we are going to overflow, and we are doing a hang, let's\n              ; stop now!\n              overflow-in-hang?\n            (do (dbg options \"fzprint*: overflow <<<<<<<<<<\") nil) (zkeyword?\n                                                                     zloc)\n            [[zstr (zcolor-map options :keyword) :element]] :else\n            (let [zloc-sexpr (zsexpr zloc)]\n              (cond\n                (string? zloc-sexpr)\n                  [[(if string-str?\n                      (str (zsexpr zloc))\n                      ; zstr\n                      (zstring zloc))\n                    (if string-color string-color (zcolor-map options :string))\n                    :element]]\n                (showfn? fn-map (zsexpr zloc)) [[zstr (zcolor-map options :fn)\n                                                 :element]]\n                (show-user-fn? options (zsexpr zloc))\n                  [[zstr (zcolor-map options :user-fn) :element]]\n                (number? (zsexpr zloc))\n                  [[(if hex? (znumstr zloc hex? shift-seq) zstr)\n                    (zcolor-map options :number) :element]]\n                (symbol? (zsexpr zloc)) [[zstr (zcolor-map options :symbol)\n                                          :element]]\n                (nil? (zsexpr zloc)) [[zstr (zcolor-map options :nil) :element]]\n                (true? (zsexpr zloc)) [[zstr (zcolor-map options :true)\n                                        :element]]\n                (false? (zsexpr zloc)) [[zstr (zcolor-map options :false)\n                                         :element]]\n                (char? (zsexpr zloc)) [[zstr (zcolor-map options :char)\n                                        :element]]\n                (or (instance? #?(:clj java.util.regex.Pattern\n                                  :cljs (type #\"regex\"))\n                               (zsexpr zloc))\n                    (re-find #\"^#\\\".*\\\"$\" zstr))\n                  [[zstr (zcolor-map options :regex) :element]]\n                :else [[zstr (zcolor-map options :none) :element]])))))))\n\n;;\n;; # Comment Wrap Support\n;;\n\n(defn inlinecomment?\n  \"If this is an inline comment, returns a vector with the amount\n  of space that was between this and the previous element and the\n  starting column of this inline comment.  That means that if we\n  go left, we get something other than whitespace before a newline.\n  If we get only whitespace before a newline, then this is considered\n  an inline comment if the comment at the end of the previous line\n  was an inline comment and we were aligned with that comment.\n  Assumes zloc is a comment.\"\n  [zloc]\n  #_(prn \"inlinecomment? zloc:\" (zstring zloc))\n  (loop [nloc (zprint.zutil/left* zloc)\n         spaces 0\n         passed-nl? false]\n    (let\n      #?(:clj [tnloc (ztag nloc)]\n         :cljs [[tnloc spaces]\n                (let [tnloc (ztag nloc)]\n                  (if (= tnloc :whitespace)\n                    ; might be whitespace with an embedded comma in cljs\n                    (let [nstr (zstring nloc)\n                          trim-nstr (clojure.string/trimr nstr)]\n                      (if (pos? (count trim-nstr))\n                        ; it had something besides spaces in it\n                        ; we will assume a comma\n                        ;  correct things\n                        [:comma (+ spaces (- (count nstr) (count trim-nstr)))]\n                        ; it was all whitespace -- don't correct\n                        [:whitespace spaces]))\n                    [tnloc spaces]))])\n      #_(prn \"inlinecomment? tnloc:\" tnloc\n             \"spaces:\" spaces\n             \"nloc:\" (zstring nloc))\n      (cond\n        (nil? tnloc) nil  ; the start of the zloc\n        (= tnloc :newline) (recur (zprint.zutil/left* nloc) spaces true)\n        (or (= tnloc :comment) (= tnloc :comment-inline))\n          ; Two comments in a row don't have a newline showing between\n          ; them, it is captured by the first comment.  Sigh.\n          ; Except now it isn't, as we split the newlines out.\n          (do #_(prn \"inlinecomment? found previous comment!\")\n              ; is it an inline comment?\n              (when (inlinecomment? nloc)\n                ; figure the total alignment from the newline\n                (let [nloc-length-before (length-before nloc)\n                      zloc-length-before (length-before zloc)]\n                  #_(prn \"inlinecomment?:\"\n                         \"nloc-length-before:\" nloc-length-before\n                         \"zloc-length-before:\" zloc-length-before\n                         \"spaces:\" spaces)\n                  (if (= nloc-length-before zloc-length-before)\n                    ; we have a lineup\n                    [spaces zloc-length-before]\n                    nil))))\n        (not= tnloc :whitespace)\n          (if passed-nl? nil [spaces (length-before zloc)])\n        :else (recur (zprint.zutil/left* nloc)\n                     ^long (+ ^long (zprint.zutil/length nloc) spaces)\n                     passed-nl?)))))\n\n(defn last-space\n  \"Take a string and an index, and look for the last space prior to the\n  index. If we wanted to tie ourselves to 1.8, we could use \n  clojure.string/last-index-of, but we don't.  However, we use similar\n  conventions, i.e., if no space is found, return nil, and if the index\n  is a space return that value, and accept any from-index, including one\n  larger than the length of the string.\"\n  [s from-index]\n  (let [from-index (min (dec (count s)) from-index)\n        rev-seq (reverse (take (inc from-index) s))\n        seq-after-space (take-while #(not= % \\space) rev-seq)\n        space-index (- from-index (count seq-after-space))]\n    (if (neg? space-index) nil space-index)))\n\n(defn next-space\n  \"Take a string and an index, and look for the next space *after* the\n  index. If no space is found, return nil. Accept any from-index, \n  including one larger than the length of the string.\"\n  [s from-index]\n  (let [from-index (inc from-index)]\n    (when (< from-index (count s))\n      (let [seq-after-space (take-while #(not= % \\space)\n                                        (drop from-index (seq s)))\n            space-index (+ from-index (count seq-after-space))]\n        (if (>= space-index (count s)) nil space-index)))))\n\n; transient may have made this worse\n(defn wrap-comment\n  \"If this is a comment, and it is too long, word wrap it to the right width.\n  Note that top level comments may well end with a newline, so remove it\n  and reapply it at the end if that is the case.\"\n  [width [s color stype :as element] start]\n  (if-not (or (= stype :comment) (= stype :comment-inline))\n    element\n    (let [comment-width (- width start)\n          semi-str (re-find #\";*\" s)\n          rest-str (subs s (count semi-str))\n          space-str (re-find #\" *\" rest-str)\n          rest-str (subs rest-str (count space-str))\n          newline? (re-find #\"\\n$\" s)\n          comment-width (- comment-width (count semi-str) (count space-str))\n          #_(println \"\\ncomment-width:\" comment-width\n                     \"semi-str:\" semi-str\n                     \"space-str:\" space-str\n                     \"rest-str:\" rest-str)]\n      (loop [comment-str rest-str\n             out (transient [])]\n        #_(prn \"comment-str:\" comment-str)\n        (if (empty? comment-str)\n          (if (zero? (count out))\n            (if newline?\n              [[semi-str color stype] [\"\\n\" :none :indent 38]]\n              [[semi-str color stype]])\n            (persistent! (if newline? (conj! out [\"\\n\" :none :indent 39]) out)))\n          (let [last-space-index (if (<= (count comment-str) comment-width)\n                                   (dec (count comment-str))\n                                   (if (<= comment-width 0)\n                                     (or (next-space comment-str 0)\n                                         (dec (count comment-str)))\n                                     (or (last-space comment-str comment-width)\n                                         (next-space comment-str comment-width)\n                                         (dec (count comment-str)))))\n                next-comment (clojure.string/trimr\n                               (subs comment-str 0 (inc last-space-index)))]\n            #_(prn \"last-space-index:\" last-space-index\n                   \"next-comment:\" next-comment)\n            (recur\n              (subs comment-str (inc last-space-index))\n              (if (zero? (count out))\n                ;(empty? out)\n                (conj! out [(str semi-str space-str next-comment) color stype])\n                (conj! (conj! out [(str \"\\n\" (blanks start)) :none :indent 40])\n                       [(str semi-str space-str next-comment) color\n                        :comment-wrap])))))))))\n\n(defn loc-vec\n  \"Takes the start of this vector and the vector itself.\"\n  [start [s]]\n  (let [split (split-lf s)]\n    (if (= (count split) 1) (+ start (count s)) (count (last split)))))\n\n(defn style-loc-vec\n  \"Take a style-vec and produce a style-loc-vec with the starting column\n  of each element in the style-vec. Accepts a beginning indent.\"\n  [indent style-vec]\n  (butlast (reductions loc-vec indent style-vec)))\n\n; Transient didn't help here, rather it hurt a bit.\n\n(defn lift-vec\n  \"Take a transient output vector and a vector and lift any style-vec elements\n  out of the input vector.\"\n  [out-vec element]\n  (if (string? (first element))\n    (conj out-vec element)\n    (loop [element-vec element\n           out out-vec]\n      (if-not element-vec\n        out\n        (recur (next element-vec) (conj out (first element-vec)))))))\n\n(defn lift-style-vec\n  \"Take a style-vec [[s color type] [s color type] [[s color type]\n  [s color type]] [s color type] ...] and lift out the inner vectors.\"\n  [style-vec]\n  (reduce lift-vec [] style-vec))\n\n(defn fzprint-wrap-comments\n  \"Take the final output style-vec, and wrap any comments which run over\n  the width. Looking for \"\n  [{:keys [width], :as options} style-vec]\n  (dbg options \"fzprint-wrap-comments: indent:\" (:indent options))\n  #_(def wcsv style-vec)\n  (let [start-col (style-loc-vec (or (:indent options) 0) style-vec)\n        #_(def stc start-col)\n        _ (dbg options \"fzprint-wrap-comments: style-vec:\" (pr-str style-vec))\n        _ (dbg options \"fzprint-wrap-comments: start-col:\" start-col)\n        wrap-style-vec (mapv (partial wrap-comment width) style-vec start-col)\n        #_(def wsv wrap-style-vec)\n        _ (dbg options \"fzprint-wrap-comments: wrap:\" (pr-str style-vec))\n        out-style-vec (lift-style-vec wrap-style-vec)]\n    out-style-vec))\n\n(defn find-element-from-end\n  \"Find a the first element of this type working from the end of a \n  style-vec.  Return the index of the element.\"\n  [element-pred? style-vec]\n  (loop [index (dec (count style-vec))]\n    (if (neg? index)\n      nil\n      (let [[_ _ e] (nth style-vec index)]\n        (if (element-pred? e) index (recur (dec index)))))))\n\n(defn line-size\n  \"Given a style-vec, how big is it in actual characters.  This doesn't\n  handle newlines.\"\n  [style-vec]\n  (apply + (map (partial loc-vec 0) style-vec)))\n\n(defn space-before-comment\n  \"Given a style-vec, whose last element in a comment, find the amount\n  of space before that comment on the line.\"\n  [style-vec]\n  (let [indent-index (find-element-from-end #(or (= % :indent) (= % :newline))\n                                            style-vec)\n        this-line-vec\n          (if indent-index (nthnext style-vec indent-index) style-vec)]\n    (line-size (butlast this-line-vec))))\n\n(defn fzprint-inline-comments\n  \"Try to bring inline comments back onto the line on which they belong.\"\n  [{:keys [width], :as options} style-vec]\n  #_(def fic style-vec)\n  (dbg-pr options \"fzprint-inline-comments:\" style-vec)\n  (loop [cvec style-vec\n         last-out [\"\" nil nil]\n         out []]\n    (if-not cvec\n      (do #_(def fico out) out)\n      (let [[s c e :as element] (first cvec)\n            [_ _ ne nn :as next-element] (second cvec)\n            [_ _ le] last-out\n            new-element\n              (cond (and (or (= e :indent) (= e :newline))\n                         (= ne :comment-inline))\n                      (if-not (or (= le :comment) (= le :comment-inline))\n                        ; Regular line to get the inline comment\n                        [(blanks nn) c :whitespace 25]\n                        ; Last element was a comment...\n                        ; Can't put a comment on a comment, but\n                        ; we want to indent it like the last\n                        ; comment.\n                        ; How much space before the last comment?\n                        (do #_(prn \"inline:\" (space-before-comment out))\n                            [(str \"\\n\" (blanks (space-before-comment out))) c\n                             :indent 41]\n                            #_element))\n                    :else element)]\n        (recur (next cvec) new-element (conj out new-element))))))\n\n;;\n;; ## Align inline comments\n;;\n\n(def max-aligned-inline-comment-distance 5)\n\n(defn find-aligned-inline-comments\n  \"Given a style-vec, find previously aligned inline comments and\n  output the as a sequence of vectors of comments. The previously\n  aligned comments do not have to be consecutive, but they can't\n  be separated by more than max-aligned-inline-comment-distance.\n  Each comment itself is a vector: [indent-index inline-comment-index],\n  yielding a [[[indent-index inline-comment-index] [indent-index\n  inline-comment-index] ...] ...].  The indexes are into the\n  style-vec.\"\n  [style-vec]\n  #_(def fcic style-vec)\n  (loop [cvec style-vec\n         index 0\n         last-indent 0\n         current-seq []\n         current-column 0\n         distance 0\n         out []]\n    (if-not cvec\n      (let [out (if (> (count current-seq) 1) (conj out current-seq) out)]\n        #_(def fcico out)\n        out)\n      (let [[s c e spaces start-column :as element] (first cvec)]\n        (cond\n          (= e :comment-inline)\n            (if (= start-column current-column)\n              ; include this inline comment in the current-seq, since\n              ; it has the same starting column\n              (recur (next cvec)\n                     (inc index)\n                     nil\n                     (if last-indent\n                       (conj current-seq [last-indent index])\n                       (do (throw\n                             (#?(:clj Exception.\n                                 :cljs js/Error.)\n                              (str \"find-aligned-inline-comments a:\" index)))\n                           []))\n                     current-column\n                     ; distance from last inline comment is zero\n                     0\n                     out)\n              ; start a new current-seq, since this comment's starting\n              ; column doesn't match the current-column of the current-seq\n              (recur (next cvec)\n                     (inc index)\n                     nil\n                     (if last-indent\n                       [[last-indent index]]\n                       (do (throw\n                             (#?(:clj Exception.\n                                 :cljs js/Error.)\n                              (str \"find-aligned-inline-comments b:\" index)))\n                           []))\n                     ; new starting column\n                     start-column\n                     ; distance from the last inline comment is zero\n                     0\n                     ; if we have more than one current inline comments,\n                     ; add them to the out vector\n                     (if (> (count current-seq) 1) (conj out current-seq) out)))\n          (or (= e :indent) (= e :newline))\n            (if (>= distance max-aligned-inline-comment-distance)\n              ; We have gone too far\n              (recur (next cvec)\n                     (inc index)\n                     ; last-indent is this index\n                     index\n                     []\n                     ; current-column\n                     0\n                     ; distance\n                     0\n                     (if (> (count current-seq) 1) (conj out current-seq) out))\n              ; We have not gone too far\n              (recur (next cvec)\n                     (inc index)\n                     ; last-indent is this index\n                     index\n                     current-seq\n                     current-column\n                     ; we've passed another line\n                     (inc distance)\n                     out))\n          :else (recur (next cvec)\n                       (inc index)\n                       last-indent\n                       current-seq\n                       current-column\n                       distance\n                       out))))))\n\n(defn find-consecutive-inline-comments\n  \"Given a style-vec, find consecutive inline comments and output\n  the as a sequence of vectors of comments.  Each comment itself\n  is a vector: [indent-index inline-comment-index], yielding a\n  [[[indent-index inline-comment-index] [indent-index inline-comment-index]\n  ...] ...]\"\n  [style-vec]\n  #_(def fcic style-vec)\n  (loop [cvec style-vec\n         index 0\n         last-indent 0\n         current-seq []\n         out []]\n    (if-not cvec\n      (do #_(def fcico out) out)\n      (let [[s c e :as element] (first cvec)]\n        (cond\n          (= e :comment-inline)\n            (recur (next cvec)\n                   (inc index)\n                   nil\n                   (if last-indent\n                     (conj current-seq [last-indent index])\n                     (do (throw\n                           (#?(:clj Exception.\n                               :cljs js/Error.)\n                            (str \"find-consecutive-inline-comments:\" index)))\n                         []))\n                   out)\n          (or (= e :indent) (= e :newline))\n            (recur (next cvec)\n                   (inc index)\n                   index\n                   (if last-indent\n                     ; if we have a last-indent, then we didn't\n                     ; just have a comment\n                     []\n                     ; if we don't have a last-indent, then we\n                     ; did just have a comment previously, so keep\n                     ; collecting comments\n                     current-seq)\n                   (if last-indent\n                     ; if we have a last-indent, then we didn't\n                     ; just have a comment.  But if we have more\n                     ; than one comment vector in current-seq,\n                     ; make sure we keep track of that\n                     (if (> (count current-seq) 1) (conj out current-seq) out)\n                     ; if we didn't have last-indent, then we\n                     ; just had a comment, so keep collecting\n                     ; them\n                     out))\n          :else (recur (next cvec) (inc index) last-indent current-seq out))))))\n\n(defn comment-column\n  \"Takes a single vector of [indent-index comment-index] and will show the\n  column on the line in which the comment starts.\"\n  [[indent-index comment-index] style-vec]\n  (when-not (vector? style-vec)\n    (throw (#?(:clj Exception.\n               :cljs js/Error.)\n            (str \"comment-column: style-vec not a vector!! \" style-vec))))\n  (loop [index indent-index\n         column 0]\n    (if (= index comment-index)\n      column\n      (recur (inc index) (loc-vec column (nth style-vec index))))))\n\n(defn comment-vec-column\n  \"Take a single inline comment vector:\n  [indent-index inline-comment-index] \n  and replace it with [inline-comment-index start-column spaces-before].\"\n  [style-vec [indent-index inline-comment-index :as comment-vec]]\n  (let [start-column (comment-column comment-vec style-vec)\n        spaces-before (loc-vec 0 (nth style-vec (dec inline-comment-index)))]\n    [inline-comment-index start-column spaces-before]))\n\n(defn comment-vec-seq-column\n  \"Take a single vector of inline comments\n  [[indent-index inline-comment-index] [indent-index inline-comment-index]\n   ...] and replace it with [[inline-comment-index start-column spaces-before]\n   [inline-comment-index start-column spaces-before] ...]\"\n  [style-vec comment-vec-seq]\n  (map (partial comment-vec-column style-vec) comment-vec-seq))\n\n(defn comment-vec-all-column\n  \"Take a seq of all of the comments as produced by \n  find-consecutive-inline-comments, and turn it into:\n  [[[inline-comment-index start-column spaces-before] [inline-comment-index\n  start-column spaces-before]\n  ...] ...]\"\n  [style-vec comment-vec-all]\n  (map (partial comment-vec-seq-column style-vec) comment-vec-all))\n\n(defn minimum-column\n  \"Given a set of inline comments:\n  [[inline-comment-index start-column spaces-before]\n   [inline-comment-index start-column spaces-before] ...], determine\n   the minimum column at which they could be aligned.\"\n  [comment-vec]\n  (let [minimum-vec (map #(inc (- (second %) (nth % 2))) comment-vec)\n        minimum-col (apply max minimum-vec)]\n    minimum-col))\n\n(defn change-start-column\n  \"Given a new start-column, and a vector \n  [[inline-comment-index start-column spaces-before]\n  and a style-vec, return a new style-vec with the inline-comment starting\n  at a new column.\"\n  [new-start-column style-vec\n   [inline-comment-index start-column spaces-before :as comment-vec]]\n  (let [delta-spaces (- new-start-column start-column)\n        new-spaces (+ spaces-before delta-spaces)\n        previous-element-index (dec inline-comment-index)\n        #_(prn \"change-start-column:\"\n               \"spaces-before:\" spaces-before\n               \"delta-spaces:\" delta-spaces\n               \"new-spaces:\" new-spaces)\n        [s c e :as previous-element] (nth style-vec previous-element-index)\n        new-previous-element\n          (cond (= e :indent) [(str \"\\n\" (blanks new-spaces)) c e]\n                (= e :whitespace) [(str (blanks new-spaces)) c e 26]\n                :else (throw\n                        (#?(:clj Exception.\n                            :cljs js/Error.)\n                         (str \"change-start-column: comment preceded by neither\"\n                              \" an :indent nor :whitespace!\"\n                              e))))]\n    (assoc style-vec previous-element-index new-previous-element)))\n\n(defn align-comment-vec\n  \"Given one set of inline comments: \n  [[inline-comment-index start-column spaces-before]\n   [inline-comment-index start-column spaces-before] ...], align them \n   as best as possible, and return the modified style-vec.\"\n  [style-vec comment-vec]\n  (let [minimum-col (minimum-column comment-vec)]\n    (reduce (partial change-start-column minimum-col) style-vec comment-vec)))\n\n(defn fzprint-align-inline-comments\n  \"Given the current style-vec, align all consecutive inline comments.\"\n  [options style-vec]\n  (dbg-pr options \"fzprint-align-inline-comments: style-vec:\" style-vec)\n  (let [style (:inline-align-style (:comment options))]\n    (if (= style :none)\n      style-vec\n      (let [comment-vec (cond (= style :aligned) (find-aligned-inline-comments\n                                                   style-vec)\n                              (= style :consecutive)\n                                (find-consecutive-inline-comments style-vec))\n            comment-vec-column (comment-vec-all-column style-vec comment-vec)]\n        (reduce align-comment-vec style-vec comment-vec-column)))))\n\n;;\n;; # External interface to all fzprint functions\n;;\n\n(defn fzprint\n  \"The pretty print part of fzprint.\"\n  [options indent zloc]\n  #_(def opt options)\n  (dbg options \"fzprint: indent:\" indent \"(:indent options)\" (:indent options))\n  ; if we are doing specs, find the docstring and modify it with\n  ; the spec output.\n  #_(println \"fn-name:\" (:fn-name options))\n  #_(println \"spec:\" (:value (:spec options)))\n  (let [zloc (if-not (and (= (:ztype options) :zipper) (:value (:spec options)))\n               zloc\n               (add-spec-to-docstring zloc (:value (:spec options))))\n        style-vec (fzprint* (assoc options\n                              :depth 0\n                              :map-depth 0)\n                            indent\n                            zloc)]\n    #_(def fsv style-vec)\n    style-vec))\n\n;    (if (= (:ztype options) :sexpr)\n;      style-vec\n;      (if (:wrap? (:comment options))\n;        (fzprint-wrap-comments options style-vec)\n;        style-vec))))\n\n;;\n;; # Basic functions for testing results -- used only for tests\n;;\n\n(defn line-count \"Count lines in a string.\" [s] (inc (count (re-seq #\"\\n\" s))))\n\n(defn line-widths\n  \"Return a vector the lengths of lines.\"\n  [s]\n  (map count (clojure.string/split s #\"\\n\")))\n\n(defn max-width\n  \"Split a string into lines, and figure the max width.\"\n  [s]\n  (reduce max (line-widths s)))\n\n;;\n;; # Tab Expansion\n;;\n\n(defn expand-tabs\n  \"Takes a string, and expands tabs inside of the string based\n  on a tab-size argument.\"\n  ([tab-size s]\n   (apply str\n     (loop [char-seq (seq s)\n            cur-len (long 0)\n            out (transient [])]\n       (if (empty? char-seq)\n         (persistent! out)\n         (let [this-char (first char-seq)\n               tab-expansion (if (= this-char \\tab)\n                               (- tab-size (mod cur-len tab-size))\n                               nil)]\n           (recur (rest char-seq)\n                  (if (= this-char \\newline)\n                    0\n                    (+ cur-len (long (or tab-expansion 1))))\n                  (if tab-expansion\n                    (apply conj-it! out (seq (blanks tab-expansion)))\n                    (conj! out this-char))))))))\n  ([s] (expand-tabs 8 s)))\n\n;;\n;; # Needed for expectations testing\n;;\n;; Seems defrecord doesn't work in test environment, which is pretty odd.\n;;\n\n(defrecord r [left right])\n(defn make-record [left right] (new r left right))\n\n;;\n;; End of testing functions\n;;\n","~:reader-features",["^S",["~:cljs"]],"~:cljc",true,"~:source-map-compact",["^ ","mappings","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","names",["zprint.zprint/blanks","n","cljs.core.apply","cljs.core/str","cljs.core.repeat","zprint.zprint/dots","var_args","args__4824__auto__","len__4818__auto__","i__4819__auto__","argseq__4825__auto__","cljs.core/IndexedSeq","zprint.zprint/conj-it!","seq45285","self__4806__auto__","cljs.core/seq","rest","out","cljs.core/first","more","cljs.core/next","cljs.core.conj_BANG_","zprint.zprint/split-lf","s","input","cljs.core/not","next-lf","clojure.string.index_of","chunk","cljs.core.subs","cljs.core.conj","zprint.zprint/split-lf-2","temp__5751__auto__","G__45301","zprint.zprint/zpmap","js/Error","options","f","coll","cljs.core.map","coll1","coll2","zprint.zprint/zat","value","zprint.zprint/fzprint-dbg","cljs.core.atom","p__45305","map__45306","cljs.core/--destructure-map","cljs.core.get","zprint.zprint/log-lines","dbg-print?","dbg-indent","in-hang?","dbg-output","ind","style-vec","cljs.core.println","cljs.core.prn","zprint.zprint/showfn?","fn-map","f-str","or__4212__auto__","cljs.core/re-find","cljs.core/Symbol","e45307","cljs.core/meta","G__45308","cljs.core/name","e","zprint.zprint/show-user-fn?","user-fn-map","e45309","cljs.core/empty?","zprint.zprint/right-separator-map","p__45310","p__45311","p__45312","map__45313","map__45314","map__45315","vec__45316","cljs.core.nth","vec__45319","zprint.zprint/good-enough?","caller","width","rightcnt","dbg?","hang-flow","hang-type-flow","hang-flow-limit","general-hang-adjust","hang-if-equal-flow?","hang-expand","hang-diff","hang-size","hang-adjust","fn-style","p-count","indent-diff","p-lines","p-maxwidth","p-length-seq","p-what","b-lines","b-maxwidth","_","b-what","p-last-maxwidth","cljs.core/last","cljs.core.assoc","result","and__4210__auto__","zprint.zprint/fix-rightcnt","cljs.core._EQ_","factor","zprint.zprint/in-hang","zprint.zprint/contains-nil?","p1__45322#","cljs.core/some","cljs.core/coll?","zprint.zprint/concat-no-nil-alt","seq45323","cljs.core/transient","c","cljs.core/persistent!","zprint.zprint/concat-no-nil-pre-noseq","seq45328","cljs.core.reduce","v","o","cljs.core/reduced","cljs.core/conj!","zprint.zprint/concat-no-nil","seq45330","cljs.core/count","vec__45335","what","right-ind","last-element","cljs.core/peek","vec__45338","previous-index","color","previous-what","zprint.zprint/count-right-blanks","new-previous","zprint.zprint/trimr-blanks","zprint.zprint/concat-no-nil-pre-right","seq45342","zprint.zprint/remove-one","index","cljs.core.concat","cljs.core.take","cljs.core.drop","zprint.zprint/force-vector","cljs.core/vector?","cljs.core.into","zprint.zprint/keyword-fn?","vec__45343","left","right","clojure.string.split","fexpr__45346","p__45347","map__45348","zprint.zprint/get-max-length","max-length","depth","x__4298__auto__","y__4299__auto__","zprint.zprint/no-max-length","p__45349","vec__45350","zprint.zprint/accumulate-ll","count-comment?","cur-len","just-eol?","just-comment?","in","tag","eol?","comment?","count-s","p__45354","p__45355","vec__45356","vec__45359","zprint.zprint/generate-ll","element","vec__45362","l","r","cljs.core/List","zprint.zprint/line-lengths-iter","cljs.core.pr_str","next-vec","current-string","line-length","previous-comment?","vec__45376","vec__45379","advance?","next-string","force-newline?","new-line-length","zprint.zprint/line-lengths","length-vec","vec__45384","cljs.core.partial","zprint.zprint/single-line?","p1__45387#","p2__45388#","p1__45389#","clojure.string/includes?","zprint.zprint/find-what","s-vec","vec__45402","this","zprint.zprint/first-nl?","vec__45405","zprint.zprint/prepend-nl","zprint.zprint.concat_no_nil","zprint.zprint/style-lines","lengths","count-lengths","cljs.core/max","dbg-ge","p__45408","p__45409","map__45410","vec__45411","zprint.zprint/fzfit","line-count","max-width","style-lines-return","zprint.zprint/fzfit-one-line","lines","zprint.zprint/rightmost","zprint.zprint/not-rightmost","cljs.core.dissoc","zprint.zprint/c-r-pair","commas?","rightmost-pair?","rightmost?","zprint.zprint/str->key","p__45414","map__45415","zprint.zprint/zcolor-map","color-map","key-or-str","G__45420","cljs.core/Keyword","zprint.zprint/hangflow","hangflow?","hang-or-flow","zprint.zprint/fzprint-hang-unless-fail","hindent","findent","fzfn","zloc","G__45424","zprint.zfns/zstring","zprint.zfns/zfirst","hanging","cljs.core.not_EQ_","G__45428","G__45429","G__45430","value__45260__auto__","zprint.zprint/replace-color","local-color","vec__45441","vec__45444","string","p__45447","map__45448","map__45449","zprint.zprint/use-hang?","hang-accept","ha-depth-factor","ha-width-factor","hang-count","hanging-line-count","p__45457","p__45458","map__45460","map__45461","vec__45462","zprint.zprint/fzprint-two-up","one-line?","do-in-hang?","map-depth","hang?","dbg-local?","dbg-cnt?","indent","indent-arg","flow?","key-color","key-depth-color","key-value-color","justify-width","lloc","rloc","xloc","pair","zprint.zfns/ztag","vec__45465","vec__45468","local-hang?","local-options","loptions","roptions","local-roptions","value-color-map","G__45471","zprint.zfns/zsexpr","zprint.config.merge_deep","modifier-set","modifier?","G__45472","zprint.zprint/middle-element?","G__45473","arg-1","zprint.zprint/fzprint*","arg-1-newline?","zprint.zfns/znewline?","arg-1-line-count","arg-1-max-width","arg-1-lines","combined-arg-1","G__45474","G__45475","G__45476","arg-1-fit-oneline?","arg-1-fit?","arg-1-width","hanging-width","hanging-spaces","hanging-indent","flow-indent","zprint.zfns/zvector?","vec__45480","zprint.zprint/fzprint-binding-vec","G__45483","G__45484","G__45485","zprint.zfns/zcount","hanging-lines","fit?","flow-it?","flow","flow-lines","G__45486","G__45487","G__45488","G__45489","G__45490","zprint.zprint/fzprint-flow-seq","cljs.core/nnext","p__45499","map__45500","map__45501","zprint.zprint/fzprint-justify-width","justify?","firsts","cljs.core.remove","cljs.core/nil?","p1__45491#","G__45502","G__45503","G__45504","style-seq","each-one-line?","p1__45492#","p2__45493#","p1__45494#","p2__45495#","x__4295__auto__","y__4296__auto__","cljs.core/second","G__45506","zprint.zprint/fit-within?","size","zprint.zprint.fit_within_QMARK_","remaining","zprint.zprint/remove-hangflow","hf-style-vec","p__45518","map__45519","map__45520","zprint.zprint/fzprint-map-two-up","force-nl?","parallel?","caller-map","len","caller-options","justify-options","beginning-coll","cljs.core/butlast","beginning-remaining","beginning","zprint.zprint.zpmap","end-coll","end-remaining","end","temp__5753__auto__","end-result","zprint.zprint/compare-keys","x","y","cljs.core/compare","zprint.zprint/compare-ordered-keys","key-value","zdotdotdot","p__45527","map__45532","map__45533","zprint.zprint/order-out","sort?","sort-in-code?","key-order","in-code?","access","p1__45525#","p2__45526#","cljs.core.sort","zprint.zfns/zdotdotdot","G__45535","G__45536","zprint.zprint/pair-element?","zprint.zfns/zcomment?","zprint.zfns/zuneval?","p__45538","map__45539","zprint.zprint/remove-key-seq","m","ks","this-key","next-key","removed-map","G__45544","G__45545","zprint.zprint/ignore-key-seq-silent","cljs.core.get_in","zprint.zprint/ignore-key-seq","cljs.core/assoc-in","p__45546","map__45547","map__45548","zprint.zprint/map-ignore","key-ignore","key-ignore-silent","ignored-silent","ignored","zprint.zprint/partition-all-2-nc","no-sort?","G__45561","G__45562","vec__45563","new-remaining","pair-vec","new-no-sort?","vec__45566","comment-seq","rest-seq","p1__45549#","cljs.core/split-with","G__45573","G__45574","G__45575","zprint.zprint/cleave-end","G__45577","zprint.zfns/zsymbol?","G__45578","zprint.zfns/zreader-cond-w-symbol?","vec__45579","rev-seq","cljs.core/reverse","split-non-coll","p1__45576#","zprint.zfns/zcoll?","zprint.zfns/zreader-cond-w-coll?","cljs.core/list","remainder","zprint.zprint/partition-all-sym","part-sym","p1__45582#","cljs.core.partition_by","zprint.zfns/znil?","cljs.core.mapcat","vec__45595","next-remaining","new-out","G__45598","cljs.core/ffirst","G__45599","G__45600","G__45601","G__45602","G__45603","cljs.core/nthnext","G__45604","G__45605","cljs.core/cons","G__45608","zprint.zprint/rstr-vec","r-str","r-type","zprint.zprint.rstr_vec","p__45609","map__45610","map__45611","nl-separator?","G__45612","l-str","l-str-vec","r-str-vec","G__45613","G__45614","G__45615","zprint.zprint/interpose-nl-hf","zprint.zprint/fzprint-get-zloc-seq","p__45616","map__45618","zprint.zprint/fzprint-hang","force-eol-blanks?","zloc-count","fexpr__45647","G__45648","G__45649","G__45650","G__45651","hr-lines","fd-lines","hr-good?","p__45672","map__45673","map__45674","zprint.zprint/fzprint-pairs","respect-nl?","zloc-seq","G__45675","G__45676","G__45677","G__45678","vec__45679","part","cljs.core.comp","p__45686","map__45687","map__45688","zprint.zprint/fzprint-extend","G__45689","G__45690","G__45691","G__45692","p1__45683#","zprint.zprint/concatv!","seq45693","G__45694","self__4805__auto__","cols","col","zprint.zprint/fzprint-one-line","seq-right","last-index","gt-1?","new-ind","cljs.core/long","vec__45709","vec__45712","next-zloc","sep","next-options","next-out","next-lines","zprint.zprint.concatv_BANG_","zprint.zprint/fzprint-seq","p1__45717#","p2__45718#","G__45719","G__45720","G__45721","G__45722","G__45723","G__45724","G__45726","nl-first?","coll-print","one-line","cljs.core.interpose","one-line-lines","G__45728","G__45729","G__45730","G__45731","zprint.zprint/precede-w-nl","zprint.zprint.fzprint_flow_seq","p__45732","map__45733","map__45734","zprint.zprint/fzprint-hang-one","hang-avoid","G__45735","G__45736","G__45737","G__45738","zprint.zprint/count-constant-pairs","zloc-seq-rev","element-count","paired-element-count","constant-required?","pair-size","actual-pair-size","comment-or-newline?","zprint.zprint/zcomment-or-newline?","zprint.zfns/zconstant?","p__45740","map__45741","map__45742","zprint.zprint/constant-pair","constant-pair?","constant-pair-min","vec__45743","paired-item-count","actual-paired-items","non-paired-item-count","pair-seq","zprint.zprint/ensure-start-w-nl","element-type","zprint.zprint/ensure-end-w-nl","G__45747","zprint.zprint/fzprint-hang-remaining","p__45748","map__45749","map__45750","G__45751","G__45752","vec__45753","vec__45756","vec__45759","vec__45762","hang-result","flow-result","zprint.zprint.fzprint_hang_remaining","zprint.zfns/zmap-w-nl","cljs.core/identity","zprint.zfns/zmap-w-bl","zprint.zfns/zmap","zprint.zprint/newline-or-comment?","zloc-tag","zprint.zprint/remove-last-newline","ssv","last-style-vec","last-len","total-len","remove-one","cljs.core/PersistentVector","zprint.zprint/remove-one-newline","zprint.zprint/add-newline-to-comment","fzprint*-return","the-type","zprint.zprint/gather-up-to-next-zloc","nloc-seq","next-count","p__45766","vec__45767","zprint.zprint/fzprint-up-to-next-zloc","current-count","next-data","starting-count","vec__45770","pre-next-zloc-seq","cljs.core.mapv","cljs.core/vector","coll-out","first-type","zprint.zprint/fzprint-up-to-first-zloc","p__45773","vec__45774","zprint.zprint/get-zloc-seq-right","input-data","zprint.zprint/at-newline?","this-tag","zprint.zprint/next-newline","nloc","next-right","zprint.zutil/right*","zprint.zutil/whitespace?","zprint.zprint/length-after-newline","nl-split","nl-num","zprint.zprint/tag-l-size","t","G__45777","zprint.zprint/left-or-up","ploc","total-up","next-left","zprint.zutil/left*","moving-up","zprint.zutil/up*","up-tag","zprint.zutil/tag","up-size","zprint.zprint/length-before","vec__45778","indent-before","vec__45784","zstr","length-right-of-newline","zprint.zprint/next-actual","next-nloc","zprint.zutil/zrightnws","next-tag","zprint.zprint/first-actual","zprint.zprint/hang-zloc?","vec__45787","count-prior-to-newline","newline","second-element","second-indent","third-element","third-indent","zprint.zprint/indent-shift","actual-ind","svec","shift-ind","cur-seq","cur-ind","vec__45796","this-seq","new-seq","vec__45799","type","next-seq","this-shift","linecnt","last-width","G__45803","zprint.zprint/indent-zmap","p__45804","map__45805","map__45806","wrap-after-multi?","first-indent-only?","zprint.zprint/merge-fzprint-seq","actual-indent","beginning?","l-str-indent?","vec__45818","multi?","thetype","newline?","comma?","isempty?","newline-next?","zprint.zprint.indent_zmap","zprint.zprint/hang-indent","zprint.zprint/flow-indent","zprint.zprint/newline-seq?","newline-vec","starts-with-nl-vec","p1__45822#","clojure.string/starts-with?","true-seq","cljs.core.distinct","fzprint-seq-vec","p1__45824#","p2__45823#","G__45827","zprint.zprint/fzprint-indent","arg-1-indent","l-str-len","zprint.zfns/zmap-w-nl-comma","indent-only-style","already-hung?","zprint.zutil/down*","raw-indent","coll-print-contains-nil?","output","zprint.zprint.fzprint_indent","zprint.zprint/zfind-seq","zthing?","i","G__45834","zprint.zprint/body-set","zprint.zprint/body-map","zprint.zprint/noarg1-set","zprint.zprint/noarg1-map","zprint.zprint/noarg1","fn-type","zprint.zprint/fn-style->caller","zprint.zprint/get-respect-indent","backup","respect-bl?","indent-only?","p__45837","map__45838","zprint.zprint/allow-one-line?","fn-force-nl","fn-gt2-force-nl","fn-gt3-force-nl","future-caller","zprint.zprint/modify-zloc","vec__45846","trigger-symbol","modify-fn","return-altered-zipper-value","call-fn?","G__45849","return","p__45853","map__45854","zprint.zprint/fzprint-list*","no-arg1?","vec__45856","vec__45859","vec__45862","vec__45865","G__45869","G__45870","G__45871","zprint.zfns/ztake-append","pre-arg-1-style-vec","arg-1-zloc","arg-1-count","first-data","arg-1-coll?","zprint.zfns/zkeyword?","arg-1-indent-alt?","fn-str","G__45874","zprint.config/config-and-validate","pre-arg-2-style-vec","arg-2-zloc","arg-2-count","second-data","zprint.zfns/zcount-zloc-seq-nc-nws","cljs.core.update_in","cljs.core/dissoc","one-line-ok?","fexpr__45880","indent-adj","default-indent","zprint.zfns/zlist?","one-line-ind","vec__45894","binding-style-vec","G__45900","G__45901","G__45902","zloc-seq-right-first","G__45903","G__45904","G__45905","G__45906","G__45907","G__45908","vec__45909","vec__45912","pre-arg-3-style-vec","arg-3-zloc","arg-3-count","third-data","zloc-seq-right-third","first-three","first-two-wo-pre-arg-1","G__45915","G__45916","G__45917","first-two-one-line?","first-two","G__45918","G__45919","G__45920","vec__45921","vec__45924","pre-arg-4-style-vec","arg-4-zloc","arg-4-count","fourth-data","arg-vec-index","p1__45850#","G__45927","doc-string?","mixin-start","mixin-length","mixins?","doc-string","mixins","vec__45928","mixin-sentinal","G__45931","G__45932","G__45933","G__45934","G__45935","G__45936","zloc-seq-right-second","G__45937","G__45938","G__45939","G__45940","G__45941","G__45942","G__45943","G__45944","G__45945","G__45946","G__45947","G__45948","local-indent","zprint.zprint/fzprint-list","zprint.zprint/fzprint-anon-fn","zprint.zprint/any-zcoll?","coll?-seq","p1__45949#","p2__45950#","p__45951","map__45952","map__45953","zprint.zprint/wrap-zmap","previous-newline?","vec__45957","comment-inline?","this-seq-next","zprint.zprint/remove-nl","p1__45960#","zprint.zprint/internal-validate","error-str","errors","zprint.config.validate_options","zprint.zprint/lazy-sexpr-seq","nws-seq","cljs.core/LazySeq","G__45961","G__45962","cljs.core/rest","zprint.zprint/comment-in-zloc-seq?","p1__45964#","p2__45963#","p__45965","map__45966","map__45967","zprint.zprint/fzprint-vec*","wrap-coll?","wrap?","binding?","option-fn-first","option-fn","fn-format","vec__45968","map__45971","map__45972","new-options","first-sexpr","G__45973","zprint.zfns/zfirst-no-comment","zprint.zfns/zwhitespaceorcomment?","zprint.zfns/zseqnws","nws-count","sexpr-seq","zprint.zprint/fzprint-vec","zprint.zprint/fzprint-array","zprint.zprint/fzprint-set","zprint.zprint/interpose-either","sep-true","sep-nil","pred?","interpose?","zprint.zprint.conj_it_BANG_","G__45975","not-first?","ind-seq","added-nl?","previous-element-index","previous-type","vec__45988","vec__45991","last-what","next-ind","next-coll","vec__45994","vec__45997","next-what","zprint.zprint/count-newline-types","newline-style-vec","count-of-types","p1__46000#","clojure.string/ends-with?","zprint.zprint/repeat-style-vec-nl","no-space-n","vec__46001","no-space-element","no-space-style-vec","p__46004","vec__46005","zprint.zprint/trimr-blanks-element","zprint.zprint/trimr-blanks-style-vec","zprint.zprint/repeat-element-nl","vec__46008","zprint.zprint/next-non-comment-nl","vec__46011","vec__46014","p__46017","map__46018","zprint.zprint/interpose-either-nl-hf","sep-comma","sep-comma-nl","sep-nl","nl-separator-flow?","suboptions","previous-needs-comma?","add-nl?","first?","newline-count","vec__46028","vec__46031","hangflow","vec__46034","interpose-style-vec","interpose-count","addtl-nl-needed","p__46037","map__46038","map__46039","zprint.zprint/fzprint-map*","ztype","lift-ns?","lift-ns-in-code?","map-options","ns","vec__46040","vec__46043","vec__46046","zprint.zfns/zseqnws-w-nl","zprint.zfns/zseqnws-w-bl","lift-pair-seq","G__46049","G__46050","G__46051","zprint.zfns/zlift-ns","pair-count","pair-print-one-line","cljs.core/constantly","pair-print","zprint.zprint/fzprint-map","vec__46052","lifted-map","zprint.zfns/znamespacedmap?","G__46055","zprint.zprint/object-str?","G__46057","zprint.zprint/fzprint-object","zloc-value","zprint.zfns/zobj-to-vec","zprint.zprint/hash-identity-str","obj","cljs.core/hash","p__46058","map__46059","map__46060","zprint.zprint/fzprint-atom","object?","zprint.zprint.fzprint_object","zprint.zfns/zderef","zprint.zprint/fzprint-future-promise-delay-agent","zloc-type","zprint.zfns/zfuture?","zprint.zfns/zpromise?","zprint.zfns/zdelay?","zprint.zfns/zagent?","cljs.core/realized?","type-str","G__46061","zloc-realized?","G__46062","p__46063","map__46064","map__46065","zprint.zprint/fzprint-fn-obj","arg-1-left","arg-1-right","class-str","cljs.core/type","name-js","name-split","arg-2","zprint.zprint/fzprint-ns","cljs.core/ns-name","zprint.zprint/dec-depth","p__46066","map__46067","map__46068","zprint.zprint/fzprint-record","record-type?","to-string?","G__46069","G__46070","G__46071","G__46072","G__46073","G__46074","clojure.string/replace","tokens","zprint.zprint/fzprint-meta","zprint.zprint/fzprint-reader-macro","vec__46075","G__46078","alt-at?","reader-cond?","namespaced?","at?","G__46079","zprint.zfns/zsecond","G__46080","G__46082","floc","G__46083","l-str-io","r-str-io","l-str-vec-io","r-str-vec-io","zprint.zfns/znextnws-w-nl","zprint.zprint/fzprint-newline","vec__46084","zprint.finish/newline-vec","zprint.zprint/prefix-tags","zprint.zprint/prefix-options","prefix-tag","zprint.zprint/make-caller","new-caller","existing-caller","key-seq","p1__46087#","p__46088","map__46089","hex?","shift-seq","string-str?","string-color","max-depth","trim-comments?","max-hang-depth","max-hang-span","max-hang-count","next-inner","cljs.core/deref","avail","dbg-data","dbg-focus?","zprint.zfns/zfind-path","zprint.zfns/zrecord?","zprint.zfns/zmap?","zprint.zfns/zset?","zprint.zfns/zanonfn?","zprint.zfns/zfn-obj?","zprint.zfns/zarray?","zprint.zfns/zexpandarray","zprint.zfns/zatom?","zprint.zfns/zmeta?","G__46090","G__46091","zprint.zfns/zns?","zprint.zfns/zreader-macro?","overflow-in-hang?","zcomment","clojure.string/trimr","inline-comment-vec","zprint.zprint/inlinecomment?","zloc-sexpr","zprint.zfns/znumstr","cljs.core/char?","c__4243__auto__","x__4244__auto__","spaces","passed-nl?","vec__46095","tnloc","nstr","trim-nstr","nloc-length-before","zloc-length-before","zprint.zutil/length","zprint.zprint/last-space","from-index","seq-after-space","p1__46098#","cljs.core.take_while","space-index","zprint.zprint/next-space","p1__46099#","p__46100","vec__46101","zprint.zprint/wrap-comment","stype","start","comment-width","semi-str","rest-str","space-str","comment-str","last-space-index","next-comment","p__46104","vec__46105","zprint.zprint/loc-vec","split","zprint.zprint/style-loc-vec","cljs.core.reductions","zprint.zprint/lift-vec","out-vec","element-vec","zprint.zprint/lift-style-vec","p__46108","map__46109","zprint.zprint/fzprint-wrap-comments","start-col","wrap-style-vec","out-style-vec","zprint.zprint/find-element-from-end","element-pred?","vec__46110","zprint.zprint/line-size","cljs.core/+","zprint.zprint/space-before-comment","indent-index","p1__46113#","this-line-vec","p__46114","map__46115","zprint.zprint/fzprint-inline-comments","cvec","last-out","vec__46125","vec__46128","vec__46131","ne","nn","next-element","le","new-element","zprint.zprint/max-aligned-inline-comment-distance","zprint.zprint/find-aligned-inline-comments","last-indent","current-seq","current-column","distance","vec__46137","start-column","zprint.zprint/find-consecutive-inline-comments","vec__46143","p__46146","vec__46147","zprint.zprint/comment-column","comment-index","column","p__46150","vec__46151","zprint.zprint/comment-vec-column","inline-comment-index","comment-vec","spaces-before","zprint.zprint/comment-vec-seq-column","comment-vec-seq","zprint.zprint/comment-vec-all-column","comment-vec-all","zprint.zprint/minimum-column","minimum-vec","p1__46154#","minimum-col","p__46155","vec__46156","zprint.zprint/change-start-column","new-start-column","vec__46159","delta-spaces","new-spaces","previous-element","new-previous-element","zprint.zprint/align-comment-vec","zprint.zprint/fzprint-align-inline-comments","style","comment-vec-column","zprint.zprint/fzprint","zprint.zutil/add-spec-to-docstring","zprint.zprint/line-count","cljs.core/re-seq","zprint.zprint/line-widths","zprint.zprint/max-width","G__46163","zprint.zprint/expand-tabs","tab-size","char-seq","this-char","tab-expansion","cljs.core/mod","zprint.zprint.expand_tabs","this__4461__auto__","k__4462__auto__","this__4463__auto__","k46165","else__4464__auto__","G__46169","__extmap","this__4481__auto__","f__4482__auto__","init__4483__auto__","ret__4484__auto__","p__46170","vec__46171","k__4485__auto__","v__4486__auto__","this__4476__auto__","writer__4477__auto__","opts__4478__auto__","pr-pair__4479__auto__","keyval__4480__auto__","cljs.core/pr-sequential-writer","G__46164","cljs.core/RecordIter","cljs.core/-iterator","cljs.core/nil-iter","this__4459__auto__","__meta","this__4456__auto__","__hash","this__4465__auto__","this__4457__auto__","h__4319__auto__","coll__4458__auto__","cljs.core/hash-unordered-coll","this46166","other46167","this__4471__auto__","k__4472__auto__","cljs.core/contains?","cljs.core/-with-meta","cljs.core/not-empty","this__4468__auto__","G__46174","this__4469__auto__","k__4470__auto__","pred__46175","cljs.core/keyword-identical?","expr__46176","this__4474__auto__","cljs.core/MapEntry","this__4460__auto__","this__4466__auto__","entry__4467__auto__","cljs.core/-nth","cljs.core/-conj","zprint.zprint/r","this__4505__auto__","writer__4506__auto__","cljs.core/-write","G__46168","extmap__4501__auto__","G__46178","cljs.core/record?","zprint.zprint/->r","zprint.zprint/map->r","zprint.zprint/make-record"]],"~:used-vars",["^S",["~$zprint.zfns/zdotdotdot","~$zprint.zprint/object-str?","~$zprint.config/config-and-validate","~$zprint.zprint/cleave-end","~$cljs.core/mapcat","~$cljs.core/--destructure-map","~$zprint.zprint/fzprint-set","~$zprint.zprint/hash-identity-str","~$zprint.zfns/zseqnws","~$zprint.zfns/zset?","~$cljs.core/comp","~$cljs.core/rest","~$zprint.zfns/zlift-ns","~$zprint.zutil/tag","~$zprint.zprint/count-newline-types","~$zprint.zprint/find-consecutive-inline-comments","~$zprint.zprint/fzprint-dbg","~$zprint.zprint/fzprint-array","~$cljs.core/str","~$cljs.core/char?","~$zprint.zprint/fzfit","~$cljs.core/re-seq","~$zprint.zprint/minimum-column","~$zprint.zprint/precede-w-nl","~$zprint.zfns/zmeta?","~$zprint.zprint/fn-style->caller","~$zprint.zprint/get-max-length","~$clojure.string/starts-with?","~$zprint.zutil/right*","~$zprint.zfns/zsexpr","~$zprint.zprint/style-loc-vec","~$zprint.zprint/indent-zmap","~$zprint.zprint/fzprint-up-to-first-zloc","~$zprint.zprint/use-hang?","~$zprint.zfns/zobj-to-vec","~$zprint.zprint/remove-one-newline","~$zprint.zprint/remove-last-newline","~$cljs.core/pr-sequential-writer","~$zprint.zprint/trimr-blanks-style-vec","~$clojure.string/split","~$zprint.zprint/left-or-up","~$zprint.zprint/prepend-nl","~$zprint.zprint/count-constant-pairs","~$cljs.core/vector?","~$zprint.zfns/zcount","~$cljs.core/=","~$zprint.zprint/line-lengths-iter","~$zprint.zprint/hangflow","~$zprint.zprint/hang-zloc?","~$zprint.zprint/inlinecomment?","~$zprint.zprint/fzprint-meta","~$zprint.zprint/trimr-blanks","~$zprint.zprint/first-actual","~$zprint.zprint/fzprint-reader-macro","~$zprint.zprint/next-non-comment-nl","~$cljs.core/-assoc","~$zprint.zprint/ensure-start-w-nl","~$zprint.zprint/fzprint-record","~$zprint.zprint/flow-indent","~$cljs.core/partial","~$cljs.core/take-while","~$cljs.core/-write","~$zprint.zprint/fzprint-binding-vec","~$zprint.zfns/zseqnws-w-bl","~$zprint.zprint/comment-column","~$cljs.core/IndexedSeq","~$zprint.zprint/not-rightmost","~$clojure.string/index-of","~$zprint.zutil/whitespace?","~$zprint.zprint/at-newline?","~$cljs.core/-iterator","~$cljs.core/hash","~$zprint.zprint/in-hang","~$zprint.zfns/zstring","~$zprint.zprint/line-lengths","~$zprint.zprint/line-size","~$cljs.core/count","~$cljs.core/deref","~$zprint.zprint/zpmap","~$zprint.zprint/remove-key-seq","~$zprint.zprint/find-aligned-inline-comments","~$zprint.zprint/change-start-column","~$cljs.core/reduce","~$cljs.core/seq","~$cljs.core/apply","~$zprint.zprint/showfn?","~$zprint.zfns/zmap-w-bl","~$cljs.core/identity","~$cljs.core/Keyword","~$cljs.core/prn","~$cljs.core/take","~$zprint.zprint/pair-element?","~$zprint.zfns/znextnws-w-nl","~$zprint.zprint/body-map","~$zprint.zfns/zfuture?","~$cljs.core/last","~$zprint.zfns/zmap-w-nl","~$cljs.core/mapv","~$zprint.zprint/compare-ordered-keys","~$cljs.core/not=","~$zprint.zprint/modify-zloc","~$zprint.zprint/fzprint-one-line","~$cljs.core/MapEntry","~$cljs.core/distinct","~$cljs.core/dissoc","~$zprint.zprint/interpose-nl-hf","~$cljs.core/keyword-identical?","~$zprint.zfns/zns?","~$zprint.zprint/force-vector","~$cljs.core/LazySeq","~$cljs.core/atom","~$zprint.zprint/compare-keys","~$zprint.zprint/max-width","~$zprint.zprint/fzprint-newline","~$cljs.core/-with-meta","~$zprint.zprint/ensure-end-w-nl","~$cljs.core/concat","~$zprint.zprint/any-zcoll?","~$zprint.zprint/fzprint-vec","~$cljs.core/pr-str","~$zprint.zprint/merge-fzprint-seq","~$cljs.core/ns-name","~$zprint.zprint/ignore-key-seq","~$clojure.string/ends-with?","~$zprint.zprint/remove-one","~$zprint.config/merge-deep","~$zprint.zprint/map->r","~$zprint.zprint/align-comment-vec","~$zprint.zfns/znumstr","~$clojure.string/includes?","~$zprint.zprint/first-nl?","~$zprint.zprint/fzprint-pairs","~$zprint.zprint/remove-hangflow","~$zprint.zfns/zexpandarray","~$zprint.zprint/fzprint","~$zprint.zprint/internal-validate","~$zprint.zprint/fit-within?","~$zprint.zfns/zreader-cond-w-symbol?","~$cljs.core/empty?","~$zprint.zfns/zwhitespaceorcomment?","~$zprint.zutil/left*","~$zprint.zutil/add-spec-to-docstring","~$cljs.core/contains?","~$zprint.zprint/dots","~$cljs.core/into","~$zprint.zprint/split-lf","~$zprint.zprint/fzprint*","~$zprint.zprint/make-record","~$cljs.core/conj","~$zprint.zprint/ignore-key-seq-silent","~$zprint.zprint/next-space","~$zprint.zprint/replace-color","~$zprint.zprint/prefix-options","~$zprint.zfns/zcoll?","~$zprint.zprint/right-separator-map","~$cljs.core/sort","~$cljs.core/-conj","~$zprint.zprint/show-user-fn?","~$zprint.zprint/contains-nil?","~$zprint.finish/newline-vec","~$zprint.zprint/->r","~$zprint.zprint/fzprint-get-zloc-seq","~$cljs.core/peek","~$cljs.core/map","~$zprint.zprint/get-respect-indent","~$zprint.zprint/fzprint-hang-remaining","~$zprint.zfns/ztag","~$zprint.zprint/fzprint-align-inline-comments","~$zprint.zprint/get-zloc-seq-right","~$zprint.zprint/generate-ll","~$zprint.zprint/add-newline-to-comment","~$zprint.config/validate-options","~$zprint.zfns/zmap","~$zprint.zprint/space-before-comment","~$zprint.zprint/find-element-from-end","~$zprint.zprint/comment-in-zloc-seq?","~$zprint.zfns/znil?","~$zprint.zprint/fzprint-wrap-comments","~$zprint.zprint/concat-no-nil-alt","~$cljs.core/PersistentVector","~$zprint.zprint/make-caller","~$cljs.core/get-in","~$zprint.zprint/fzprint-map*","~$zprint.zutil/zrightnws","~$cljs.core/List","~$zprint.zprint/hang-indent","~$zprint.zprint/trimr-blanks-element","~$zprint.zfns/zdelay?","~$cljs.core/nthnext","~$zprint.zfns/zfind-path","~$zprint.zfns/zsymbol?","~$cljs.core/long","~$zprint.zprint/concat-no-nil-pre-noseq","~$cljs.core/get","~$zprint.zprint/fzfit-one-line","~$cljs.core/constantly","~$zprint.zprint/concat-no-nil","~$zprint.zprint/fzprint-inline-comments","~$zprint.zprint/indent-shift","~$zprint.zprint/repeat-element-nl","~$zprint.zprint/line-count","~$zprint.zprint/tag-l-size","~$clojure.string/trimr","~$zprint.zprint/body-set","~$cljs.core/partition-by","~$cljs.core/-nth","~$cljs.core/remove","~$zprint.zfns/zuneval?","~$zprint.zprint/allow-one-line?","~$zprint.zfns/zfirst","~$zprint.zprint/fzprint-future-promise-delay-agent","~$zprint.zprint/length-after-newline","~$cljs.core/not-empty","~$zprint.zprint/fzprint-justify-width","~$zprint.zprint/blanks","~$zprint.zprint/middle-element?","~$zprint.zprint/max-aligned-inline-comment-distance","~$zprint.zprint/count-right-blanks","~$zprint.zprint/order-out","~$zprint.zprint/concat-no-nil-pre-right","~$cljs.core/mod","~$cljs.core/conj!","~$zprint.zfns/znewline?","~$zprint.zprint/fzprint-map","~$zprint.zutil/down*","~$cljs.core/record?","~$cljs.core/re-find","~$zprint.zprint/constant-pair","~$zprint.zfns/zlist?","~$zprint.zfns/zcount-zloc-seq-nc-nws","~$zprint.zfns/zarray?","~$zprint.zprint/partition-all-sym","~$cljs.core/nnext","~$cljs.core/persistent!","~$zprint.zprint/zcomment-or-newline?","~$zprint.zprint/noarg1-map","~$zprint.zprint/zat","~$cljs.core/-lookup","~$cljs.core/reduced","~$zprint.zprint/fzprint-flow-seq","~$zprint.zprint/gather-up-to-next-zloc","~$cljs.core/nil?","~$cljs.core/nth","~$zprint.zprint/prefix-tags","~$cljs.core/meta","~$zprint.zprint/lazy-sexpr-seq","~$zprint.zprint/fzprint-hang-one","~$zprint.zfns/zcomment?","~$zprint.zutil/up*","~$cljs.core/max","~$zprint.zfns/zmap-w-nl-comma","~$cljs.core/second","~$zprint.zfns/zatom?","~$cljs.core/nil-iter","~$zprint.zprint/conj-it!","~$cljs.core/println","~$clojure.string/replace","~$zprint.zprint/loc-vec","~$zprint.zprint/rightmost","~$zprint.zprint/fzprint-list","~$zprint.zprint/c-r-pair","~$zprint.zprint/remove-nl","~$zprint.zfns/zfirst-no-comment","~$zprint.zfns/zanonfn?","~$cljs.core/split-with","~$zprint.zprint/split-lf-2","~$zprint.zprint/single-line?","~$zprint.zfns/zkeyword?","~$cljs.core/next","~$zprint.zprint/expand-tabs","~$cljs.core/ffirst","~$cljs.core/reductions","~$zprint.zprint/partition-all-2-nc","~$zprint.zprint/fzprint-fn-obj","~$zprint.zfns/zseqnws-w-nl","~$zprint.zprint/comment-vec-column","~$zprint.zfns/znamespacedmap?","~$zprint.zprint/fzprint-object","~$cljs.core/RecordIter","~$zprint.zfns/zderef","~$cljs.core/transient","~$zprint.zprint/comment-vec-seq-column","~$zprint.zprint/fzprint-two-up","~$cljs.core/realized?","~$zprint.zprint/newline-or-comment?","~$zprint.zprint/wrap-comment","~$cljs.core/not","~$cljs.core/compare","~$zprint.zprint/last-space","~$zprint.zfns/zpromise?","~$zprint.zprint/newline-seq?","~$zprint.zprint/interpose-either","~$zprint.zfns/zsecond","~$zprint.zfns/zfn-obj?","~$cljs.core/cons","~$zprint.zprint/fzprint-anon-fn","~$zprint.zfns/zreader-cond-w-coll?","~$cljs.core/assoc","~$zprint.zprint/rstr-vec","~$cljs.core/interpose","~$zprint.zprint/lift-style-vec","~$cljs.core/assoc-in","~$cljs.core/reverse","~$zprint.zfns/zconstant?","~$zprint.zprint/fzprint-extend","~$cljs.core/Symbol","~$zprint.zprint/zcolor-map","~$zprint.zfns/zrecord?","~$zprint.zprint/fzprint-ns","~$cljs.core/coll?","~$zprint.zfns/zagent?","~$cljs.core/repeat","~$cljs.core/hash-unordered-coll","~$zprint.zprint/find-what","~$zprint.zprint/fzprint-atom","~$zprint.zprint/fzprint-seq","~$zprint.zprint/fzprint-indent","~$zprint.zprint/length-before","~$zprint.zprint/fix-rightcnt","~$zprint.zprint/concatv!","~$zprint.zprint/log-lines","~$zprint.zprint/line-widths","~$zprint.zprint/no-max-length","~$cljs.core/first","~$cljs.core/butlast","~$zprint.zprint/noarg1-set","~$zprint.zfns/ztake-append","~$zprint.zprint/fzprint-up-to-next-zloc","~$zprint.zprint/fzprint-vec*","~$zprint.zprint/repeat-style-vec-nl","~$zprint.zfns/zreader-macro?","~$zprint.zfns/zmap?","~$cljs.core/list","~$zprint.zprint/noarg1","~$zprint.zprint/map-ignore","~$cljs.core/name","~$zprint.zprint/fzprint-list*","~$cljs.core/subs","~$cljs.core/+","~$zprint.zprint/accumulate-ll","~$zprint.zprint/fzprint-map-two-up","~$zprint.zfns/zvector?","~$cljs.core/update-in","~$zprint.zprint/fzprint-hang-unless-fail","~$zprint.zprint/str->key","~$zprint.zprint/keyword-fn?","~$zprint.zprint/lift-vec","~$zprint.zutil/length","~$zprint.zprint/interpose-either-nl-hf","~$zprint.zprint/fzprint-hang","~$js/Error","~$cljs.core/vector","~$zprint.zprint/wrap-zmap","~$zprint.zprint/comment-vec-all-column","~$zprint.zprint/style-lines","~$zprint.zprint/good-enough?","~$cljs.core/type","~$zprint.zprint/next-actual","~$cljs.core/some","~$zprint.zprint/zfind-seq","~$zprint.zprint/next-newline","~$cljs.core/drop","~$zprint.zprint/r","~$zprint.zprint/dec-depth"]]],"~:cache-keys",["~#cmap",[["^31","goog/dom/tagname.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","~:shadow.build.compiler/resolve",["^ ","~:require-id",null,"~:deps-ids",["^S",[]],"~:deps-syms",["^13","~$goog.dom.HtmlElement"]]],["^31","rewrite_clj/node/token.cljs"],["c35be115c39dadc71a4de3f584aa8ca295e11257","^;K",["^ ","^;L",null,"^;M",["^S",[]],"^;N",["^13","^11","~$rewrite-clj.node.protocols"]]],["^31","cljs/spec/gen/alpha.cljs"],["528fbd795675bc73c189ce8a8429415f03165a3b","^;K",["^ ","^;L",null,"^;M",["^S",[]],"^;N",["^13","^11","~$goog.Uri"]]],["^31","cljs/tools/reader/impl/utils.cljs"],["927809dcb44fa726e4969d993e3e733636d95ebb","^;K",["^ ","^;L",null,"^;M",["^S",[]],"^;N",["^13","^11","^16","~$goog.string"]]],["^31","goog/math/math.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^;K",["^ ","^;L",null,"^;M",["^S",[]],"^;N",["^13","~$goog.array","~$goog.asserts"]]],["^31","rewrite_clj/parser/core.cljs"],["c35be115c39dadc71a4de3f584aa8ca295e11257","^;K",["^ ","^;L",null,"^;M",["^S",[]],"^;N",["^13","^11","~$rewrite-clj.node","~$rewrite-clj.reader","~$rewrite-clj.parser.keyword","~$rewrite-clj.parser.string","~$rewrite-clj.parser.token","~$rewrite-clj.parser.whitespace","~$cljs.tools.reader.reader-types"]]],["^31","rewrite_clj/parser/string.cljs"],["c35be115c39dadc71a4de3f584aa8ca295e11257","^;K",["^ ","^;L",null,"^;M",["^S",[]],"^;N",["^13","^11","^;U","^;V","^;R","^16"]]],["^31","goog/html/trustedtypes.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^;K",["^ ","^;L",null,"^;M",["^S",[]],"^;N",["^13"]]],["^31","goog/labs/useragent/browser.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^;K",["^ ","^;L",null,"^;M",["^S",[]],"^;N",["^13","^;S","~$goog.labs.userAgent.util","~$goog.object","~$goog.string.internal"]]],["^31","goog/html/safeurl.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^;K",["^ ","^;L",null,"^;M",["^S",[]],"^;N",["^13","^;T","~$goog.fs.url","~$goog.html.TrustedResourceUrl","~$goog.i18n.bidi.Dir","~$goog.i18n.bidi.DirectionalString","~$goog.string.Const","~$goog.string.TypedString","^<2"]]],["^31","goog/array/array.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^;K",["^ ","^;L",null,"^;M",["^S",[]],"^;N",["^13","^;T"]]],["^31","rewrite_clj/zip/seqz.cljs"],["c35be115c39dadc71a4de3f584aa8ca295e11257","^;K",["^ ","^;L",null,"^;M",["^S",[]],"^;N",["^13","^11","~$rewrite-clj.zip.base","~$rewrite-clj.zip.editz","~$rewrite-clj.zip.findz","~$rewrite-clj.zip.insert","~$rewrite-clj.zip.move","~$clojure.zip"]]],["^31","rewrite_clj/zip/move.cljs"],["c35be115c39dadc71a4de3f584aa8ca295e11257","^;K",["^ ","^;L",null,"^;M",["^S",[]],"^;N",["^13","^11","~$rewrite-clj.zip.whitespace","^<>"]]],["^31","goog/debug/error.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^;K",["^ ","^;L",null,"^;M",["^S",[]],"^;N",["^13"]]],["^31","rewrite_clj/zip.cljs"],["c35be115c39dadc71a4de3f584aa8ca295e11257","^;K",["^ ","^;L",null,"^;M",["^S",[]],"^;N",["^13","^11","^<9","^Z","^<=","^<;","^<:","^<<","~$rewrite-clj.zip.removez","~$rewrite-clj.zip.seqz","^<>"]]],["^31","rewrite_clj/zip/editz.cljs"],["c35be115c39dadc71a4de3f584aa8ca295e11257","^;K",["^ ","^;L",null,"^;M",["^S",[]],"^;N",["^13","^11","^<9","^<=","^<@","~$rewrite-clj.zip.utils","^<?","^;U","^<>"]]],["^31","cljs/tools/reader/edn.cljs"],["927809dcb44fa726e4969d993e3e733636d95ebb","^;K",["^ ","^;L",null,"^;M",["^S",[]],"^;N",["^13","^11","~$cljs.tools.reader.impl.errors","^;[","~$cljs.tools.reader.impl.utils","~$cljs.tools.reader.impl.commons","~$cljs.tools.reader","^;R","~$goog.string.StringBuffer"]]],["^31","zprint/rewrite.cljc"],["bcaedc2ca968ebbb39028e5b7a25467410a0b7a6","^;K",["^ ","^;L",null,"^;M",["^S",[]],"^;N",["^13","^11","^16","^17","^Z","^;U","^10","^<9","^<?","^<=","^<@","^<:","^<>"]]],["^31","goog/dom/nodetype.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^;K",["^ ","^;L",null,"^;M",["^S",[]],"^;N",["^13"]]],["^31","cljs/tools/reader/impl/inspect.cljs"],["927809dcb44fa726e4969d993e3e733636d95ebb","^;K",["^ ","^;L",null,"^;M",["^S",[]],"^;N",["^13","^11"]]],["^31","zprint/config.cljc"],["bcaedc2ca968ebbb39028e5b7a25467410a0b7a6","^;K",["^ ","^;L",null,"^;M",["^S",[]],"^;N",["^13","^11","^16","~$clojure.set","~$clojure.data","~$zprint.spec","~$zprint.rewrite","~$cljs.reader"]]],["^31","cljs/tools/reader.cljs"],["927809dcb44fa726e4969d993e3e733636d95ebb","^;K",["^ ","^;L",null,"^;M",["^S",[]],"^;N",["^13","^11","^;[","^<D","^<E","^<C","^;S","^;R","^<G"]]],["^31","rewrite_clj/node/forms.cljs"],["c35be115c39dadc71a4de3f584aa8ca295e11257","^;K",["^ ","^;L",null,"^;M",["^S",[]],"^;N",["^13","^11","^;P"]]],["^31","rewrite_clj/zip/insert.cljs"],["c35be115c39dadc71a4de3f584aa8ca295e11257","^;K",["^ ","^;L",null,"^;M",["^S",[]],"^;N",["^13","^11","^<9","^<?","^;U","^<>"]]],["^31","goog/string/typedstring.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^;K",["^ ","^;L",null,"^;M",["^S",[]],"^;N",["^13"]]],["^31","rewrite_clj/zip/utils.cljs"],["c35be115c39dadc71a4de3f584aa8ca295e11257","^;K",["^ ","^;L",null,"^;M",["^S",[]],"^;N",["^13","^11","^<>"]]],["^31","goog/object/object.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^;K",["^ ","^;L",null,"^;M",["^S",[]],"^;N",["^13"]]],["^31","goog/dom/asserts.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^;K",["^ ","^;L",null,"^;M",["^S",[]],"^;N",["^13","^;T"]]],"~:SHADOW-TIMESTAMP",[1628015068000,1628015068000,1628015038000],["^31","goog/math/long.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^;K",["^ ","^;L",null,"^;M",["^S",[]],"^;N",["^13","^;T","~$goog.reflect"]]],["^31","rewrite_clj/node/reader_macro.cljs"],["c35be115c39dadc71a4de3f584aa8ca295e11257","^;K",["^ ","^;L",null,"^;M",["^S",[]],"^;N",["^13","^11","^;P","~$rewrite-clj.node.whitespace"]]],["^31","goog/html/trustedresourceurl.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^;K",["^ ","^;L",null,"^;M",["^S",[]],"^;N",["^13","^;T","~$goog.fs.blob","^<3","~$goog.html.SafeScript","~$goog.html.trustedtypes","^<5","^<6","^<7","^<8"]]],["^31","goog/string/internal.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^;K",["^ ","^;L",null,"^;M",["^S",[]],"^;N",["^13"]]],["^31","goog/functions/functions.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^;K",["^ ","^;L",null,"^;M",["^S",[]],"^;N",["^13"]]],["^31","rewrite_clj/zip/findz.cljs"],["c35be115c39dadc71a4de3f584aa8ca295e11257","^;K",["^ ","^;L",null,"^;M",["^S",[]],"^;N",["^13","^11","^<9","^<=","^;U","^<?","^<>"]]],["^31","goog/html/safestyle.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^;K",["^ ","^;L",null,"^;M",["^S",[]],"^;N",["^13","^;S","^;T","~$goog.html.SafeUrl","^<7","^<8","^<2"]]],["^31","goog/dom/safe.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^;K",["^ ","^;L",null,"^;M",["^S",[]],"^;N",["^13","^;T","~$goog.dom.asserts","~$goog.functions","~$goog.html.SafeHtml","^<Q","~$goog.html.SafeStyle","^<S","^<4","~$goog.html.uncheckedconversions","^<7","^<2"]]],["^31","clojure/walk.cljs"],["528fbd795675bc73c189ce8a8429415f03165a3b","^;K",["^ ","^;L",null,"^;M",["^S",[]],"^;N",["^13","^11"]]],["^31","goog/structs/map.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^;K",["^ ","^;L",null,"^;M",["^S",[]],"^;N",["^13","~$goog.iter.Iterator","~$goog.iter.StopIteration"]]],["^31","rewrite_clj/node/meta.cljs"],["c35be115c39dadc71a4de3f584aa8ca295e11257","^;K",["^ ","^;L",null,"^;M",["^S",[]],"^;N",["^13","^11","^;P","^<O"]]],["^31","goog/html/safehtml.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^;K",["^ ","^;L",null,"^;M",["^S",[]],"^;N",["^13","^;S","^;T","~$goog.dom.TagName","~$goog.dom.tags","^<Q","^<W","~$goog.html.SafeStyleSheet","^<S","^<4","^<R","^<5","^<6","~$goog.labs.userAgent.browser","^<1","^<7","^<8","^<2"]]],["^31","goog/dom/tags.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^;K",["^ ","^;L",null,"^;M",["^S",[]],"^;N",["^13","^<1"]]],["^31","rewrite_clj/node/stringz.cljs"],["c35be115c39dadc71a4de3f584aa8ca295e11257","^;K",["^ ","^;L",null,"^;M",["^S",[]],"^;N",["^13","^11","^;P","^<F","^16"]]],["^31","rewrite_clj/node/comment.cljs"],["c35be115c39dadc71a4de3f584aa8ca295e11257","^;K",["^ ","^;L",null,"^;M",["^S",[]],"^;N",["^13","^11","^;P"]]],["^31","goog/fs/blob.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^;K",["^ ","^;L",null,"^;M",["^S",[]],"^;N",["^13","^;S"]]],["^31","rewrite_clj/node/keyword.cljs"],["c35be115c39dadc71a4de3f584aa8ca295e11257","^;K",["^ ","^;L",null,"^;M",["^S",[]],"^;N",["^13","^11","^;P"]]],["^31","cljs/reader.cljs"],["528fbd795675bc73c189ce8a8429415f03165a3b","^;K",["^ ","^;L",null,"^;M",["^S",[]],"^;N",["^13","^11","^<1","^<F","~$cljs.tools.reader.edn","^<G"]]],["^31","goog/asserts/asserts.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^;K",["^ ","^;L",null,"^;M",["^S",[]],"^;N",["^13","~$goog.debug.Error","~$goog.dom.NodeType"]]],["^31","zprint/zutil.cljc"],["bcaedc2ca968ebbb39028e5b7a25467410a0b7a6","^;K",["^ ","^;L",null,"^;M",["^S",[]],"^;N",["^13","^11","^16","^14","^Z","^;U","^10","^<9","^<?","^<=","^<@","^<:","^<>"]]],["^31","zprint/finish.cljc"],["bcaedc2ca968ebbb39028e5b7a25467410a0b7a6","^;K",["^ ","^;L",null,"^;M",["^S",[]],"^;N",["^13","^11","^16","^15","~$zprint.focus"]]],["^31","goog/uri/uri.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^;K",["^ ","^;L",null,"^;M",["^S",[]],"^;N",["^13","^;S","^;T","^;R","~$goog.structs","~$goog.structs.Map","~$goog.uri.utils","~$goog.uri.utils.ComponentIndex","~$goog.uri.utils.StandardQueryParam"]]],["^31","zprint/focus.cljc"],["bcaedc2ca968ebbb39028e5b7a25467410a0b7a6","^;K",["^ ","^;L",null,"^;M",["^S",[]],"^;N",["^13","^11","^16","^15"]]],["^31","goog/i18n/bidi.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^;K",["^ ","^;L",null,"^;M",["^S",[]],"^;N",["^13"]]],["^31","rewrite_clj/node/protocols.cljs"],["c35be115c39dadc71a4de3f584aa8ca295e11257","^;K",["^ ","^;L",null,"^;M",["^S",[]],"^;N",["^13","^11","^16"]]],["^31","rewrite_clj/node/seq.cljs"],["c35be115c39dadc71a4de3f584aa8ca295e11257","^;K",["^ ","^;L",null,"^;M",["^S",[]],"^;N",["^13","^11","^;P"]]],["^31","rewrite_clj/node/uneval.cljs"],["c35be115c39dadc71a4de3f584aa8ca295e11257","^;K",["^ ","^;L",null,"^;M",["^S",[]],"^;N",["^13","^11","^;P"]]],["^31","cljs/spec/alpha.cljs"],["528fbd795675bc73c189ce8a8429415f03165a3b","^;K",["^ ","^;L",null,"^;M",["^S",[]],"^;N",["^13","^11","^<1","~$clojure.walk","~$cljs.spec.gen.alpha","^16"]]],["^31","goog/fs/url.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^;K",["^ ","^;L",null,"^;M",["^S",[]],"^;N",["^13"]]],["^31","goog/base.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^;K",["^ ","^;L",null,"^;M",["^S",[]],"^;N",[]]],["^31","goog/structs/structs.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^;K",["^ ","^;L",null,"^;M",["^S",[]],"^;N",["^13","^;S","^<1"]]],["^31","cljs/tools/reader/impl/errors.cljs"],["927809dcb44fa726e4969d993e3e733636d95ebb","^;K",["^ ","^;L",null,"^;M",["^S",[]],"^;N",["^13","^11","^;[","^16","~$cljs.tools.reader.impl.inspect"]]],["^31","rewrite_clj/node/whitespace.cljs"],["c35be115c39dadc71a4de3f584aa8ca295e11257","^;K",["^ ","^;L",null,"^;M",["^S",[]],"^;N",["^13","^11","^;P"]]],["^31","rewrite_clj/node/coercer.cljs"],["c35be115c39dadc71a4de3f584aa8ca295e11257","^;K",["^ ","^;L",null,"^;M",["^S",[]],"^;N",["^13","^11","~$rewrite-clj.node.comment","~$rewrite-clj.node.forms","~$rewrite-clj.node.keyword","~$rewrite-clj.node.quote","~$rewrite-clj.node.stringz","~$rewrite-clj.node.uneval","~$rewrite-clj.node.meta","~$rewrite-clj.node.fn","^;P","~$rewrite-clj.node.reader-macro","~$rewrite-clj.node.seq","~$rewrite-clj.node.token","^<O"]]],["^31","clojure/string.cljs"],["528fbd795675bc73c189ce8a8429415f03165a3b","^;K",["^ ","^;L",null,"^;M",["^S",[]],"^;N",["^13","^11","^;R","^<G"]]],["^31","rewrite_clj/parser.cljs"],["c35be115c39dadc71a4de3f584aa8ca295e11257","^;K",["^ ","^;L",null,"^;M",["^S",[]],"^;N",["^13","^11","~$rewrite-clj.parser.core","^;U","^;V"]]],["^31","rewrite_clj/parser/keyword.cljs"],["c35be115c39dadc71a4de3f584aa8ca295e11257","^;K",["^ ","^;L",null,"^;M",["^S",[]],"^;N",["^13","^11","^;U","^;[","^;V"]]],["^31","zprint/zfns.cljc"],["bcaedc2ca968ebbb39028e5b7a25467410a0b7a6","^;K",["^ ","^;L",null,"^;M",["^S",[]],"^;N",["^13","^11"]]],["^31","rewrite_clj/parser/token.cljs"],["c35be115c39dadc71a4de3f584aa8ca295e11257","^;K",["^ ","^;L",null,"^;M",["^S",[]],"^;N",["^13","^11","^;U","^;V","^;R"]]],["^31","goog/string/string.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^;K",["^ ","^;L",null,"^;M",["^S",[]],"^;N",["^13","~$goog.dom.safe","^<X","^<7","^<2"]]],["^31","clojure/data.cljs"],["528fbd795675bc73c189ce8a8429415f03165a3b","^;K",["^ ","^;L",null,"^;M",["^S",[]],"^;N",["^13","^11","^<H"]]],["^31","goog/reflect/reflect.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^;K",["^ ","^;L",null,"^;M",["^S",[]],"^;N",["^13"]]],["^31","rewrite_clj/node/fn.cljs"],["c35be115c39dadc71a4de3f584aa8ca295e11257","^;K",["^ ","^;L",null,"^;M",["^S",[]],"^;N",["^13","^11","^;P","^=<"]]],["^31","goog/labs/useragent/util.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^;K",["^ ","^;L",null,"^;M",["^S",[]],"^;N",["^13","^<2"]]],["^31","rewrite_clj/node.cljs"],["c35be115c39dadc71a4de3f584aa8ca295e11257","^;K",["^ ","^;L",null,"^;M",["^S",[]],"^;N",["^13","^11","~$rewrite-clj.node.coercer","^;P","^=A","^=H","^<O","^=I","^=?","^=@","^=E","^=C","^=G","^=B","^=D","^=F"]]],["^31","rewrite_clj/zip/removez.cljs"],["c35be115c39dadc71a4de3f584aa8ca295e11257","^;K",["^ ","^;L",null,"^;M",["^S",[]],"^;N",["^13","^11","^<=","^<B","^<?","^<>"]]],["^31","clojure/zip.cljs"],["528fbd795675bc73c189ce8a8429415f03165a3b","^;K",["^ ","^;L",null,"^;M",["^S",[]],"^;N",["^13","^11"]]],["^31","goog/string/stringbuffer.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^;K",["^ ","^;L",null,"^;M",["^S",[]],"^;N",["^13"]]],["^31","cljs/tools/reader/reader_types.cljs"],["927809dcb44fa726e4969d993e3e733636d95ebb","^;K",["^ ","^;L",null,"^;M",["^S",[]],"^;N",["^13","^11","^<D","^;R","^<G"]]],["^31","goog/iter/iter.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^;K",["^ ","^;L",null,"^;M",["^S",[]],"^;N",["^13","^;S","^;T","^<U","~$goog.math"]]],["^31","zprint/spec.cljc"],["bcaedc2ca968ebbb39028e5b7a25467410a0b7a6","^;K",["^ ","^;L",null,"^;M",["^S",[]],"^;N",["^13","^11","^16","^=<","^15","^H"]]],["^31","goog/html/uncheckedconversions.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^;K",["^ ","^;L",null,"^;M",["^S",[]],"^;N",["^13","^;T","^<V","^<Q","^<W","^=1","^<S","^<4","^<7","^<2","^<5"]]],["^31","rewrite_clj/reader.cljs"],["c35be115c39dadc71a4de3f584aa8ca295e11257","^;K",["^ ","^;L",null,"^;M",["^S",[]],"^;N",["^13","^11","^<F","^;[","^<E","^;R","^;P"]]],["^31","rewrite_clj/node/quote.cljs"],["c35be115c39dadc71a4de3f584aa8ca295e11257","^;K",["^ ","^;L",null,"^;M",["^S",[]],"^;N",["^13","^11","^;P"]]],["^31","cljs/tools/reader/impl/commons.cljs"],["927809dcb44fa726e4969d993e3e733636d95ebb","^;K",["^ ","^;L",null,"^;M",["^S",[]],"^;N",["^13","^11","^<C","^;[","^<D"]]],["^31","goog/dom/htmlelement.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^;K",["^ ","^;L",null,"^;M",["^S",[]],"^;N",["^13"]]],["^31","cljs/core.cljs"],["528fbd795675bc73c189ce8a8429415f03165a3b","^;K",["^ ","^;L",null,"^;M",["^S",[]],"^;N",["^13","~$goog.math.Long","~$goog.math.Integer","^;R","^<1","^;S","^;Q","^<G"]]],["^31","goog/html/safescript.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^;K",["^ ","^;L",null,"^;M",["^S",[]],"^;N",["^13","^<7","^<8","^<R","^;T"]]],["^31","goog/html/safestylesheet.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^;K",["^ ","^;L",null,"^;M",["^S",[]],"^;N",["^13","^<7","^<W","^<8","^;S","^<1","^;T","^<2"]]],["^31","goog/math/integer.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^;K",["^ ","^;L",null,"^;M",["^S",[]],"^;N",["^13","^<N"]]],["^31","zprint/zprint.cljc"],["bcaedc2ca968ebbb39028e5b7a25467410a0b7a6","^;K",["^ ","^;L",null,"^;M",["^S",[]],"^;N",["^13","^11","^16","^12","^14","^15","^[","^17","^Z","^10"]]],["^31","clojure/set.cljs"],["528fbd795675bc73c189ce8a8429415f03165a3b","^;K",["^ ","^;L",null,"^;M",["^S",[]],"^;N",["^13","^11"]]],["^31","goog/uri/utils.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^;K",["^ ","^;L",null,"^;M",["^S",[]],"^;N",["^13","^;T","^;R"]]],["^31","goog/string/const.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^;K",["^ ","^;L",null,"^;M",["^S",[]],"^;N",["^13","^;T","^<8"]]],["^31","rewrite_clj/zip/base.cljs"],["c35be115c39dadc71a4de3f584aa8ca295e11257","^;K",["^ ","^;L",null,"^;M",["^S",[]],"^;N",["^13","^11","^;U","^Z","^<?","^<>"]]],["^31","rewrite_clj/zip/whitespace.cljs"],["c35be115c39dadc71a4de3f584aa8ca295e11257","^;K",["^ ","^;L",null,"^;M",["^S",[]],"^;N",["^13","^11","^;U","^<>"]]],["^31","zprint/ansi.cljc"],["bcaedc2ca968ebbb39028e5b7a25467410a0b7a6","^;K",["^ ","^;L",null,"^;M",["^S",[]],"^;N",["^13","^11"]]],["^31","rewrite_clj/parser/whitespace.cljs"],["c35be115c39dadc71a4de3f584aa8ca295e11257","^;K",["^ ","^;L",null,"^;M",["^S",[]],"^;N",["^13","^11","^;U","^;V"]]]]],"~:clj-info",["^ ","jar:file:/Users/hagenek/.m2/repository/binaryage/devtools/1.0.3/devtools-1.0.3.jar!/devtools/defaults.clj",1638904136000,"jar:file:/Users/hagenek/.m2/repository/org/clojure/clojure/1.10.3/clojure-1.10.3.jar!/clojure/edn.clj",1628015039000,"jar:file:/Users/hagenek/.m2/repository/org/clojure/clojure/1.10.3/clojure-1.10.3.jar!/clojure/string.clj",1628015039000,"jar:file:/Users/hagenek/.m2/repository/org/clojure/clojurescript/1.10.879/clojurescript-1.10.879.jar!/cljs/analyzer/passes.cljc",1628015038000,"jar:file:/Users/hagenek/.m2/repository/org/clojure/data.json/2.4.0/data.json-2.4.0.jar!/clojure/data/json.clj",1628015036000,"jar:file:/Users/hagenek/.m2/repository/org/clojure/clojurescript/1.10.879/clojurescript-1.10.879.jar!/cljs/instant.clj",1628015038000,"jar:file:/Users/hagenek/.m2/repository/org/clojure/clojure/1.10.3/clojure-1.10.3.jar!/clojure/java/io.clj",1628015039000,"jar:file:/Users/hagenek/.m2/repository/org/clojure/clojurescript/1.10.879/clojurescript-1.10.879.jar!/cljs/externs.clj",1628015038000,"jar:file:/Users/hagenek/.m2/repository/org/clojure/clojurescript/1.10.879/clojurescript-1.10.879.jar!/cljs/source_map/base64.clj",1628015038000,"jar:file:/Users/hagenek/.m2/repository/org/clojure/clojure/1.10.3/clojure-1.10.3.jar!/clojure/pprint.clj",1628015039000,"jar:file:/Users/hagenek/.m2/repository/org/clojure/tools.reader/1.3.6/tools.reader-1.3.6.jar!/clojure/tools/reader.clj",1628015036000,"jar:file:/Users/hagenek/.m2/repository/org/clojure/clojurescript/1.10.879/clojurescript-1.10.879.jar!/cljs/source_map.clj",1628015038000,"jar:file:/Users/hagenek/.m2/repository/org/clojure/clojure/1.10.3/clojure-1.10.3.jar!/clojure/walk.clj",1628015039000,"jar:file:/Users/hagenek/.m2/repository/org/clojure/clojure/1.10.3/clojure-1.10.3.jar!/clojure/set.clj",1628015039000,"jar:file:/Users/hagenek/.m2/repository/org/clojure/tools.reader/1.3.6/tools.reader-1.3.6.jar!/cljs/tools/reader/reader_types.clj",1628015036000,"jar:file:/Users/hagenek/.m2/repository/zprint/zprint/1.0.1/zprint-1.0.1.jar!/zprint/smacros.cljc",1638904136000,"jar:file:/Users/hagenek/.m2/repository/org/clojure/clojurescript/1.10.879/clojurescript-1.10.879.jar!/cljs/util.cljc",1628015038000,"jar:file:/Users/hagenek/.m2/repository/org/clojure/clojurescript/1.10.879/clojurescript-1.10.879.jar!/cljs/js_deps.cljc",1628015038000,"jar:file:/Users/hagenek/.m2/repository/org/clojure/clojurescript/1.10.879/clojurescript-1.10.879.jar!/cljs/reader.clj",1628015038000,"jar:file:/Users/hagenek/.m2/repository/org/clojure/clojurescript/1.10.879/clojurescript-1.10.879.jar!/cljs/source_map/base64_vlq.clj",1628015038000,"jar:file:/Users/hagenek/.m2/repository/org/clojure/tools.reader/1.3.6/tools.reader-1.3.6.jar!/clojure/tools/reader/default_data_readers.clj",1628015036000,"jar:file:/Users/hagenek/.m2/repository/org/clojure/clojurescript/1.10.879/clojurescript-1.10.879.jar!/cljs/core.cljc",1628015038000,"jar:file:/Users/hagenek/.m2/repository/org/clojure/tools.reader/1.3.6/tools.reader-1.3.6.jar!/clojure/tools/reader/reader_types.clj",1628015036000,"jar:file:/Users/hagenek/.m2/repository/org/clojure/clojurescript/1.10.879/clojurescript-1.10.879.jar!/cljs/spec/gen/alpha.cljc",1628015038000,"jar:file:/Users/hagenek/.m2/repository/org/clojure/clojurescript/1.10.879/clojurescript-1.10.879.jar!/cljs/spec/alpha.cljc",1628015038000,"jar:file:/Users/hagenek/.m2/repository/org/clojure/clojurescript/1.10.879/clojurescript-1.10.879.jar!/cljs/tagged_literals.cljc",1628015038000,"jar:file:/Users/hagenek/.m2/repository/org/clojure/tools.reader/1.3.6/tools.reader-1.3.6.jar!/clojure/tools/reader/impl/errors.clj",1628015036000,"jar:file:/Users/hagenek/.m2/repository/org/clojure/clojurescript/1.10.879/clojurescript-1.10.879.jar!/cljs/analyzer/impl.cljc",1628015038000,"jar:file:/Users/hagenek/.m2/repository/org/clojure/tools.reader/1.3.6/tools.reader-1.3.6.jar!/clojure/tools/reader/impl/inspect.clj",1628015036000,"jar:file:/Users/hagenek/.m2/repository/org/clojure/clojurescript/1.10.879/clojurescript-1.10.879.jar!/cljs/env.cljc",1628015038000,"jar:file:/Users/hagenek/.m2/repository/org/clojure/clojurescript/1.10.879/clojurescript-1.10.879.jar!/cljs/analyzer.cljc",1628015038000,"jar:file:/Users/hagenek/.m2/repository/zprint/zprint/1.0.1/zprint-1.0.1.jar!/zprint/macros.cljc",1638904136000,"jar:file:/Users/hagenek/.m2/repository/org/clojure/clojure/1.10.3/clojure-1.10.3.jar!/clojure/core.clj",1628015039000,"jar:file:/Users/hagenek/.m2/repository/org/clojure/clojurescript/1.10.879/clojurescript-1.10.879.jar!/cljs/compiler.cljc",1628015038000,"jar:file:/Users/hagenek/.m2/repository/org/clojure/clojure/1.10.3/clojure-1.10.3.jar!/clojure/instant.clj",1628015039000,"jar:file:/Users/hagenek/.m2/repository/org/clojure/clojurescript/1.10.879/clojurescript-1.10.879.jar!/cljs/analyzer/passes/and_or.cljc",1628015038000],"~:analyzer",["^ ","^3",null,"^4",["^ "],"^5",["^ ","^6","zprint/zprint.cljc","^7",1,"^8",14,"^9",1,"^:",27,"^;",true],"^<",["^ ","^=","^>","^?","^@","^A","^B","^C","^D","^E","^F","^G","^H","^I","^J"],"^K",["^ ","^L","^M","^N","^M","^O","^M","^P","^M","^Q","^M"],"^R",["^S",[]],"^T","^U","^X",null,"^Y",["^ ","^Z","^Z","~$p","^Z","^[","^[","^10","^10","^11","^11","^12","^12","^13","^13","^14","^14","^15","^15","~$s","^16","~$z","^10","^16","^16","^17","^17"],"^18",["^S",["^19","^1:"]],"~:shadow/js-access-global",["^S",["Error"]],"^1;",["^ ","^1<","^14","^1=","^14","^1>","^14","^1?","^14","^1@","^14","^1A","^14","^1B","^14","^1C","^14","^1D","^14","^1E","^14","^1F","^14","^1G","^14","^1H","^14","^1I","^14","^1J","^14","^1K","^14","^1L","^14","^1M","^14","^1N","^14","^1O","^[","^1P","^14","^1Q","^14","^1R","^14","^1S","^[","^1T","^14","^1U","^14","^1V","^14","^1W","^14","^1X","^14","^1Y","^15","^1Z","^14","^1[","^14","^20","^14","^21","^14","^22","^17","^23","^14","^24","^14","^25","^14","^26","^14","^27","^14","^28","^14","^29","^14","^2:","^14","^2;","^14","^2<","^14","^2=","^14","^2>","^14","^2?","^14","^2@","^14","^2A","^14","^2B","^14","^2C","^14","^2D","^14","^2E","^14","^2F","^14","^2G","^14","^2H","^14","^2I","^14","^2J","^14","^2K","^14","^2L","^14","^2M","^14","^2N","^14","^2O","^12","^2P","^14","^2Q","^14","^2R","^14","^2S","^14"],"~:defs",["^ ","~$body-set",["^ ","^T","^7X","^6","zprint/zprint.cljc","^7",3220,"^8",1,"^9",3220,"^:",14,"^5",["^ ","^6","zprint/zprint.cljc","^7",3220,"^8",6,"^9",3220,"^:",14],"~:tag","~$cljs.core/ISet"],"~$allow-one-line?",["^ ","~:protocol-inline",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",3282,"^8",7,"^9",3282,"^:",22,"~:arglists",["^2U",["~$quote",["^2U",[[["^ ","~:keys",["~$fn-force-nl","~$fn-gt2-force-nl","~$fn-gt3-force-nl"],"^2X","~$options"],"~$len","~$fn-style"]]]]],"~:doc","Should we allow this function to print on a single line?"],"^T","^81","^6","zprint/zprint.cljc","^:",22,"~:method-params",["^2U",[["~$p__45837","^>X","^>Y"]]],"~:protocol-impl",null,"~:arglists-meta",["^2U",[null,null]],"^8",1,"~:variadic?",false,"^7",3282,"~:ret-tag","~$boolean","^9",3282,"~:max-fixed-arity",3,"~:fn-var",true,"^>Q",["^2U",["^>R",["^2U",[[["^ ","^>S",["^>T","^>U","^>V"],"^2X","^>W"],"^>X","^>Y"]]]]],"^>Z","Should we allow this function to print on a single line?"],"~$replace-color",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",744,"^8",7,"^9",744,"^:",20,"^>Q",["^2U",["^>R",["^2U",[["~$local-color","~$style-vec"]]]]],"^>Z","Given a style-vec with exactly one thing in it, replace the color\n  with whatever local color we have determined is correct."],"^T","^6P","^6","zprint/zprint.cljc","^:",20,"^>[",["^2U",[["^?9","^?:"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",744,"^?4",["^S",[null,"~$cljs.core/IVector"]],"^9",744,"^?6",2,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[["^?9","^?:"]]]]],"^>Z","Given a style-vec with exactly one thing in it, replace the color\n  with whatever local color we have determined is correct."],"~$fzprint-inline-comments",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",5538,"^8",7,"^9",5538,"^:",30,"^>Q",["^2U",["^>R",["^2U",[[["^ ","^>S",["~$width"],"^2X","^>W"],"^?:"]]]]],"^>Z","Try to bring inline comments back onto the line on which they belong."],"^T","^7R","^6","zprint/zprint.cljc","^:",30,"^>[",["^2U",[["~$p__46114","^?:"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",5538,"^?4",["^S",["~$clj","^?;"]],"^9",5538,"^?6",2,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[[["^ ","^>S",["^?="],"^2X","^>W"],"^?:"]]]]],"^>Z","Try to bring inline comments back onto the line on which they belong."],"~$right-separator-map",["^ ","^T","^6S","^6","zprint/zprint.cljc","^7",157,"^8",1,"^9",157,"^:",25,"^5",["^ ","^6","zprint/zprint.cljc","^7",157,"^8",6,"^9",157,"^:",25],"^>M","~$cljs.core/IMap"],"~$fzprint-justify-width",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",1095,"^8",7,"^9",1095,"^:",28,"^>Q",["^2U",["^>R",["^2U",[["~$caller",["^;J",[["^ ","^>S",["~$justify?"]],"^?C","^2X","^>W"]],"~$ind","~$coll"]]]]],"^>Z","Figure the width for a justification of a set of pairs in coll.  \n  Also, decide if it makes any sense to justify the pairs at all.\n  For instance, they all need to be one-line."],"^T","^86","^6","zprint/zprint.cljc","^:",28,"^>[",["^2U",[["^?C","~$p__45499","^?E","^?F"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",1095,"^?4",["^S",["~$number","~$clj-nil"]],"^9",1095,"^?6",4,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[["^?C",["^;J",[["^ ","^>S",["^?D"]],"^?C","^2X","^>W"]],"^?E","^?F"]]]]],"^>Z","Figure the width for a justification of a set of pairs in coll.  \n  Also, decide if it makes any sense to justify the pairs at all.\n  For instance, they all need to be one-line."],"~$expand-tabs",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",5869,"^8",7,"^9",5869,"^:",18,"^>Q",["^2U",["^>R",["^2U",[["~$tab-size","~$s"],["~$s"]]]]],"^>Z","Takes a string, and expands tabs inside of the string based\n  on a tab-size argument.","~:top-fn",["^ ","^?3",false,"~:fixed-arity",2,"^?6",2,"^>[",[["^?K","~$s"],["~$s"]],"^>Q",["^2U",[["^?K","~$s"],["~$s"]]],"^?2",["^2U",[null,null]]]],"^T","^9B","^6","zprint/zprint.cljc","^:",18,"^?L",["^ ","^?3",false,"^?M",2,"^?6",2,"^>[",[["^?K","~$s"],["~$s"]],"^>Q",["^2U",[["^?K","~$s"],["~$s"]]],"^?2",["^2U",[null,null]]],"^>[",[["^?K","~$s"],["~$s"]],"^?1",null,"^?M",2,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"~:methods",[["^ ","^?M",2,"^?3",false,"^>M","~$any"],["^ ","^?M",1,"^?3",false,"^>M","^?O"]],"^7",5869,"^9",5869,"^?6",2,"^?7",true,"^>Q",["^2U",[["^?K","~$s"],["~$s"]]],"^>Z","Takes a string, and expands tabs inside of the string based\n  on a tab-size argument."],"~$count-right-blanks",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",4386,"^8",7,"^9",4386,"^:",25,"^>Q",["^2U",["^>R",["^2U",[["~$s"]]]]],"^>Z","Count the number of blanks at the right end of a string."],"^T","^8:","^6","zprint/zprint.cljc","^:",25,"^>[",["^2U",[["~$s"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",4386,"^?4","^?H","^9",4386,"^?6",1,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[["~$s"]]]]],"^>Z","Count the number of blanks at the right end of a string."],"~$fzprint-list",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",3963,"^8",7,"^9",3963,"^:",19,"^>Q",["^2U",["^>R",["^2U",[["^>W","^?E","~$zloc"]]]]],"^>Z","Pretty print and focus style a :list element."],"^T","^98","^6","zprint/zprint.cljc","^:",19,"^>[",["^2U",[["^>W","^?E","^?R"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",3963,"^?4",["^S",["^??","^?O","^?I"]],"^9",3963,"^?6",3,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[["^>W","^?E","^?R"]]]]],"^>Z","Pretty print and focus style a :list element."],"~$fzprint-hang-remaining",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",2130,"^8",7,"^9",2130,"^:",29,"^>Q",["^2U",["^>R",["^2U",[["^?C",["^;J",["^>S",["~$dbg?","^?="],["^ ","^>S",["~$hang?","~$constant-pair?","~$constant-pair-min","~$hang-avoid","~$hang-expand","~$hang-diff","~$nl-separator?","~$respect-nl?"]],"^?C","^2X","^>W"]],"~$hindent","~$findent","~$zloc-seq","^>Y","~$zloc-count"],["^?C","^>W","^@1","^@2","^?R","^>Y"]]]]],"^>Z","zloc-seq is a seq of zlocs of a collection.  We already know\n  that the given zloc won't fit on the current line. [Besides, we\n  ensure that if there are two things remaining anyway. ???] So\n  now, try hanging and see if that is better than flow.  Unless\n  :hang? is nil, in which case we will just flow.  hindent is\n  hang-indent, and findent is flow-indent. This should never be\n  called with :one-line because this is only called from fzprint-list*\n  after the one-line processing is done. If the hindent equals the\n  flow indent, then just do flow.  Do only zloc-count non-whitespace\n  elements of zloc-seq if it exists.","^?L",["^ ","^?3",false,"^?M",7,"^?6",7,"^>[",[["^?C",["^;J",["^>S",["^?T","^?="],["^ ","^>S",["^?U","^?V","^?W","^?X","^?Y","^?Z","^?[","^@0"]],"^?C","^2X","^>W"]],"^@1","^@2","^@3","^>Y","^@4"],["^?C","^>W","^@1","^@2","^?R","^>Y"]],"^>Q",["^2U",[["^?C",["^;J",["^>S",["^?T","^?="],["^ ","^>S",["^?U","^?V","^?W","^?X","^?Y","^?Z","^?[","^@0"]],"^?C","^2X","^>W"]],"^@1","^@2","^@3","^>Y","^@4"],["^?C","^>W","^@1","^@2","^?R","^>Y"]]],"^?2",["^2U",[null,null]]]],"^T","^72","^6","zprint/zprint.cljc","^:",29,"^?L",["^ ","^?3",false,"^?M",7,"^?6",7,"^>[",[["^?C",["^;J",["^>S",["^?T","^?="],["^ ","^>S",["^?U","^?V","^?W","^?X","^?Y","^?Z","^?[","^@0"]],"^?C","^2X","^>W"]],"^@1","^@2","^@3","^>Y","^@4"],["^?C","^>W","^@1","^@2","^?R","^>Y"]],"^>Q",["^2U",[["^?C",["^;J",["^>S",["^?T","^?="],["^ ","^>S",["^?U","^?V","^?W","^?X","^?Y","^?Z","^?[","^@0"]],"^?C","^2X","^>W"]],"^@1","^@2","^@3","^>Y","^@4"],["^?C","^>W","^@1","^@2","^?R","^>Y"]]],"^?2",["^2U",[null,null]]],"^>[",[["^?C",["^;J",["^>S",["^?T","^?="],["^ ","^>S",["^?U","^?V","^?W","^?X","^?Y","^?Z","^?[","^@0"]],"^?C","^2X","^>W"]],"^@1","^@2","^@3","^>Y","^@4"],["^?C","^>W","^@1","^@2","^?R","^>Y"]],"^?1",null,"^?M",7,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^?N",[["^ ","^?M",7,"^?3",false,"^>M",["^S",[null,"^??","^?O","^?I"]]],["^ ","^?M",6,"^?3",false,"^>M",["^S",[null,"^??","^?O","^?I"]]]],"^7",2130,"^9",2130,"^?6",7,"^?7",true,"^>Q",["^2U",[["^?C",["^;J",["^>S",["^?T","^?="],["^ ","^>S",["^?U","^?V","^?W","^?X","^?Y","^?Z","^?[","^@0"]],"^?C","^2X","^>W"]],"^@1","^@2","^@3","^>Y","^@4"],["^?C","^>W","^@1","^@2","^?R","^>Y"]]],"^>Z","zloc-seq is a seq of zlocs of a collection.  We already know\n  that the given zloc won't fit on the current line. [Besides, we\n  ensure that if there are two things remaining anyway. ???] So\n  now, try hanging and see if that is better than flow.  Unless\n  :hang? is nil, in which case we will just flow.  hindent is\n  hang-indent, and findent is flow-indent. This should never be\n  called with :one-line because this is only called from fzprint-list*\n  after the one-line processing is done. If the hindent equals the\n  flow indent, then just do flow.  Do only zloc-count non-whitespace\n  elements of zloc-seq if it exists."],"~$blanks",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",32,"^8",7,"^9",32,"^:",13,"^>Q",["^2U",["^>R",["^2U",[["~$n"]]]]],"^>Z","Produce a blank string of desired size."],"^T","^87","^6","zprint/zprint.cljc","^:",13,"^>[",["^2U",[["~$n"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",32,"^?4","^?O","^9",32,"^?6",1,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[["~$n"]]]]],"^>Z","Produce a blank string of desired size."],"~$remove-hangflow",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",1129,"^8",7,"^9",1129,"^:",22,"^>Q",["^2U",["^>R",["^2U",[["~$hf-style-vec"]]]]],"^>Z","Convert a hangflow style-vec to a regular style-vec."],"^T","^6=","^6","zprint/zprint.cljc","^:",22,"^>[",["^2U",[["^@7"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",1129,"^?4",["^S",["^5R","^?I"]],"^9",1129,"^?6",1,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[["^@7"]]]]],"^>Z","Convert a hangflow style-vec to a regular style-vec."],"~$concat-no-nil-alt",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",282,"^8",7,"^9",282,"^:",24,"^>Q",["^2U",["^>R",["^2U",[["~$&","~$rest"]]]]],"^>Z","Concatentate multiple sequences, but if any of them are nil, return nil.\n  This version is 15-20% slower than the version below. Keeping it around\n  just for illustrative purposes.","^?L",["^ ","^?3",true,"^?M",0,"^?6",0,"^>[",[["^2U",["^@9"]]],"^>Q",["^2U",[["~$&","^@9"]]],"^?2",["^2U",[null]]]],"^T","^7?","^6","zprint/zprint.cljc","^:",24,"^?L",["^ ","^?3",true,"^?M",0,"^?6",0,"^>[",[["^2U",["^@9"]]],"^>Q",["^2U",[["~$&","^@9"]]],"^?2",["^2U",[null]]],"^>[",[["^2U",["^@9"]]],"^?1",null,"^?M",0,"^?2",["^2U",[null]],"^8",1,"^?3",true,"^?N",[["^ ","^?M",0,"^?3",true,"^>M",["^S",["^??","^?I"]]]],"^7",282,"^?4","^?O","^9",282,"^?6",0,"^?7",true,"^>Q",["^2U",[["~$&","^@9"]]],"^>Z","Concatentate multiple sequences, but if any of them are nil, return nil.\n  This version is 15-20% slower than the version below. Keeping it around\n  just for illustrative purposes."],"~$find-element-from-end",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",5512,"^8",7,"^9",5512,"^:",28,"^>Q",["^2U",["^>R",["^2U",[["~$element-pred?","^?:"]]]]],"^>Z","Find a the first element of this type working from the end of a \n  style-vec.  Return the index of the element."],"^T","^7;","^6","zprint/zprint.cljc","^:",28,"^>[",["^2U",[["^@;","^?:"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",5512,"^?4",["^S",["^?H","^?I"]],"^9",5512,"^?6",2,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[["^@;","^?:"]]]]],"^>Z","Find a the first element of this type working from the end of a \n  style-vec.  Return the index of the element."],"~$make-caller",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",5114,"^8",7,"^9",5114,"^:",18,"^>Q",["^2U",["^>R",["^2U",[["^>W","~$new-caller","~$existing-caller","~$key-seq"]]]]],"^>Z","Sometime we need to give a caller to a routine, and there isn't\n  a specific caller in the configuration.  So, we will use the configuration\n  from some other caller and make up a new one just for this situation.\n  The key-seq is the series of keys to both look up and create.  The\n  caller is the new caller, and the existing-caller is the one from which\n  we we will extract the information. This returns a new options map with\n  the new-caller in it."],"^T","^7A","^6","zprint/zprint.cljc","^:",18,"^>[",["^2U",[["^>W","^@=","^@>","^@?"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",5114,"^?4",["^S",["^??","^?O"]],"^9",5114,"^?6",4,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[["^>W","^@=","^@>","^@?"]]]]],"^>Z","Sometime we need to give a caller to a routine, and there isn't\n  a specific caller in the configuration.  So, we will use the configuration\n  from some other caller and make up a new one just for this situation.\n  The key-seq is the series of keys to both look up and create.  The\n  caller is the new caller, and the existing-caller is the one from which\n  we we will extract the information. This returns a new options map with\n  the new-caller in it."],"~$dots",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",37,"^8",7,"^9",37,"^:",11,"^>Q",["^2U",["^>R",["^2U",[["~$n"]]]]],"^>Z","Produce a dot string of desired size."],"^T","^6H","^6","zprint/zprint.cljc","^:",11,"^>[",["^2U",[["~$n"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",37,"^?4","^?O","^9",37,"^?6",1,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[["~$n"]]]]],"^>Z","Produce a dot string of desired size."],"~$concat-no-nil-pre-noseq",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",295,"^8",7,"^9",295,"^:",30,"^>Q",["^2U",["^>R",["^2U",[["~$&","^@9"]]]]],"^>Z","Concatentate multiple sequences, but if any of them are nil or empty\n  collections, return nil.","^?L",["^ ","^?3",true,"^?M",0,"^?6",0,"^>[",[["^2U",["^@9"]]],"^>Q",["^2U",[["~$&","^@9"]]],"^?2",["^2U",[null]]]],"^T","^7M","^6","zprint/zprint.cljc","^:",30,"^?L",["^ ","^?3",true,"^?M",0,"^?6",0,"^>[",[["^2U",["^@9"]]],"^>Q",["^2U",[["~$&","^@9"]]],"^?2",["^2U",[null]]],"^>[",[["^2U",["^@9"]]],"^?1",null,"^?M",0,"^?2",["^2U",[null]],"^8",1,"^?3",true,"^?N",[["^ ","^?M",0,"^?3",true,"^>M",["^S",["^??","^?I"]]]],"^7",295,"^?4","^?O","^9",295,"^?6",0,"^?7",true,"^>Q",["^2U",[["~$&","^@9"]]],"^>Z","Concatentate multiple sequences, but if any of them are nil or empty\n  collections, return nil."],"~$partition-all-sym",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",1449,"^8",7,"^9",1449,"^:",24,"^>Q",["^2U",["^>R",["^2U",[["^>W","~$modifier-set","^?F"]]]]],"^>Z","Similar to partition-all-2-nc, but instead of trying to pair things\n  up (modulo comments and unevaled expressions), this begins things\n  with a symbol, and then accumulates collections until the next symbol.\n  Returns a seq of seqs, where the first thing in each internal seq is\n  a protocol and the remaining thing(s) in that seq are the expressions that\n  follow.  If there is a single thing, it is returned in its own internal\n  seq. ((P (foo [this a) (bar-me [this] b) (barx [this y] (+ c y))) ...)\n  Made harder by the fact that the symbol might be inside of a #?() reader\n  conditional.  It handles comments before symbols on the symbol indent, \n  and the comments before the collections on the collection indent.  \n  Since it doesn't know how many collections there are, this is not trivial.  \n  Must be called with a sequence of z-things (these days called a zseq)"],"^T","^8H","^6","zprint/zprint.cljc","^:",24,"^>[",["^2U",[["^>W","^@C","^?F"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",1449,"^?4","^??","^9",1449,"^?6",3,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[["^>W","^@C","^?F"]]]]],"^>Z","Similar to partition-all-2-nc, but instead of trying to pair things\n  up (modulo comments and unevaled expressions), this begins things\n  with a symbol, and then accumulates collections until the next symbol.\n  Returns a seq of seqs, where the first thing in each internal seq is\n  a protocol and the remaining thing(s) in that seq are the expressions that\n  follow.  If there is a single thing, it is returned in its own internal\n  seq. ((P (foo [this a) (bar-me [this] b) (barx [this y] (+ c y))) ...)\n  Made harder by the fact that the symbol might be inside of a #?() reader\n  conditional.  It handles comments before symbols on the symbol indent, \n  and the comments before the collections on the collection indent.  \n  Since it doesn't know how many collections there are, this is not trivial.  \n  Must be called with a sequence of z-things (these days called a zseq)"],"~$zcomment-or-newline?",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",2094,"^8",7,"^9",2094,"^:",27,"^>Q",["^2U",["^>R",["^2U",[["^?R"]]]]],"^>Z","If this zloc is a comment or a newline, return true."],"^T","^8K","^6","zprint/zprint.cljc","^:",27,"^>[",["^2U",[["^?R"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",2094,"^?4","^?O","^9",2094,"^?6",1,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[["^?R"]]]]],"^>Z","If this zloc is a comment or a newline, return true."],"~$conj-it!",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",42,"^8",7,"^9",42,"^:",15,"^>Q",["^2U",["^>R",["^2U",[["~$&","^@9"]]]]],"^>Z","Make a version of conj! that take multiple arguments.","^?L",["^ ","^?3",true,"^?M",0,"^?6",0,"^>[",[["^2U",["^@9"]]],"^>Q",["^2U",[["~$&","^@9"]]],"^?2",["^2U",[null]]]],"^T","^93","^6","zprint/zprint.cljc","^:",15,"^?L",["^ ","^?3",true,"^?M",0,"^?6",0,"^>[",[["^2U",["^@9"]]],"^>Q",["^2U",[["~$&","^@9"]]],"^?2",["^2U",[null]]],"^>[",[["^2U",["^@9"]]],"^?1",null,"^?M",0,"^?2",["^2U",[null]],"^8",1,"^?3",true,"^?N",[["^ ","^?M",0,"^?3",true,"^>M","^?O"]],"^7",42,"^?4","^?O","^9",42,"^?6",0,"^?7",true,"^>Q",["^2U",[["~$&","^@9"]]],"^>Z","Make a version of conj! that take multiple arguments."],"~$fzfit-one-line",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",632,"^8",7,"^9",632,"^:",21,"^>Q",["^2U",["^>R",["^2U",[["^>W","~$style-lines-return"]]]]],"^>Z","Given the return from style-lines  and options, \n  return true if it fits on a single line."],"^T","^7O","^6","zprint/zprint.cljc","^:",21,"^>[",["^2U",[["^>W","^@G"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",632,"^?4","^?5","^9",632,"^?6",2,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[["^>W","^@G"]]]]],"^>Z","Given the return from style-lines  and options, \n  return true if it fits on a single line."],"~$lazy-sexpr-seq",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",4110,"^8",7,"^9",4110,"^:",21,"^>Q",["^2U",["^>R",["^2U",[["~$nws-seq"]]]]]],"^T","^8V","^6","zprint/zprint.cljc","^:",21,"^>[",["^2U",[["^@I"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",4110,"^?4","^??","^9",4110,"^?6",1,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[["^@I"]]]]]],"~$repeat-element-nl",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",4430,"^8",7,"^9",4430,"^:",24,"^>Q",["^2U",["^>R",["^2U",[["~$n","~$element"]]]]],"^>Z","Given a count n, and single element from a style-vec which\n  contains a newline and an indent of some number of spaces, return\n  a sequence of n of those style vecs but remove spaces from all\n  but the last of them."],"^T","^7T","^6","zprint/zprint.cljc","^:",24,"^>[",["^2U",[["~$n","^@K"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",4430,"^?4",["^S",[null,"^??","^?;","^?O"]],"^9",4430,"^?6",2,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[["~$n","^@K"]]]]],"^>Z","Given a count n, and single element from a style-vec which\n  contains a newline and an indent of some number of spaces, return\n  a sequence of n of those style vecs but remove spaces from all\n  but the last of them."],"~$line-count",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",5853,"^8",7,"^9",5853,"^:",17,"^>Q",["^2U",["^>R",["^2U",[["~$s"]]]]],"^>Z","Count lines in a string."],"^T","^7U","^6","zprint/zprint.cljc","^:",17,"^>[",["^2U",[["~$s"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",5853,"^?4","^?H","^9",5853,"^?6",1,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[["~$s"]]]]],"^>Z","Count lines in a string."],"~$concatv!",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",1700,"^8",7,"^9",1700,"^:",15,"^>Q",["^2U",["^>R",["^2U",[["~$v","~$&","^@9"]]]]],"^>Z","Given a transient vector v, concatenate all of the other\n  elements in all of the remaining collections onto v.","^?L",["^ ","^?3",true,"^?M",1,"^?6",1,"^>[",[["^2U",["~$v","^@9"]]],"^>Q",["^2U",[["~$v","~$&","^@9"]]],"^?2",["^2U",[null]]]],"^T","^:H","^6","zprint/zprint.cljc","^:",15,"^?L",["^ ","^?3",true,"^?M",1,"^?6",1,"^>[",[["^2U",["~$v","^@9"]]],"^>Q",["^2U",[["~$v","~$&","^@9"]]],"^?2",["^2U",[null]]],"^>[",[["^2U",["~$v","^@9"]]],"^?1",null,"^?M",1,"^?2",["^2U",[null]],"^8",1,"^?3",true,"^?N",[["^ ","^?M",1,"^?3",true]],"^7",1700,"^?4","^?O","^9",1700,"^?6",1,"^?7",true,"^>Q",["^2U",[["~$v","~$&","^@9"]]],"^>Z","Given a transient vector v, concatenate all of the other\n  elements in all of the remaining collections onto v."],"~$fzprint-seq",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",1754,"^8",7,"^9",1754,"^:",18,"^>Q",["^2U",["^>R",["^2U",[["^>W","^?E","^@3"]]]]],"^>Z","Take a seq of a zloc, created by (zmap identity zloc).  Return\n  a seq of the fzprint* of each element.  No spacing between any\n  of these elements. Note that this is not a style-vec, but a seq\n  of style-vecs of each of the elements.  These would need to be\n  concatenated together to become a style-vec.  ind is either a\n  constant or a seq of indents, one for each element in zloc-seq.\n  Note that right gets evaluated immediately, while left yields a\n  lazy sequence which get evaluated later."],"^T","^:D","^6","zprint/zprint.cljc","^:",18,"^>[",["^2U",[["^>W","^?E","^@3"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",1754,"^?4",["^S",["^??","^?;","^?O","^?I"]],"^9",1754,"^?6",3,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[["^>W","^?E","^@3"]]]]],"^>Z","Take a seq of a zloc, created by (zmap identity zloc).  Return\n  a seq of the fzprint* of each element.  No spacing between any\n  of these elements. Note that this is not a style-vec, but a seq\n  of style-vecs of each of the elements.  These would need to be\n  concatenated together to become a style-vec.  ind is either a\n  constant or a seq of indents, one for each element in zloc-seq.\n  Note that right gets evaluated immediately, while left yields a\n  lazy sequence which get evaluated later."],"~$loc-vec",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",5464,"^8",7,"^9",5464,"^:",14,"^>Q",["^2U",["^>R",["^2U",[["~$start",["~$s"]]]]]],"^>Z","Takes the start of this vector and the vector itself."],"^T","^96","^6","zprint/zprint.cljc","^:",14,"^>[",["^2U",[["^@P","~$p__46104"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",5464,"^?4","^?H","^9",5464,"^?6",2,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[["^@P",["~$s"]]]]]],"^>Z","Takes the start of this vector and the vector itself."],"~$partition-all-2-nc",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",1354,"^8",7,"^9",1354,"^:",25,"^>Q",["^2U",["^>R",["^2U",[["^>W","^?F"]]]]],"^>Z","Input is (zseqnws zloc) or (zseqnws-w-nl) where one assumes that\n  these are pairs.  Thus, a seq of zlocs.  Output is a sequence of\n  seqs, where the seqs are usually pairs, but might be single things.\n  Doesn't pair up comments or #_(...) unevaled sexpressions.  The\n  ones before the first part of a pair come as a single element in\n  what would usually be a pair, and the ones between the first and\n  second parts of a pair come inside the pair.  There may be an\n  arbitrary number of elements between the first and second elements\n  of the pair (one per line).  If there are any comments or unevaled\n  sexpressions, don't sort the keys, as we might lose track of where\n  the comments or unevaled s-expressions go."],"^T","^9E","^6","zprint/zprint.cljc","^:",25,"^>[",["^2U",[["^>W","^?F"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",1354,"^?4",["^S",["^?;","^?I"]],"^9",1354,"^?6",2,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[["^>W","^?F"]]]]],"^>Z","Input is (zseqnws zloc) or (zseqnws-w-nl) where one assumes that\n  these are pairs.  Thus, a seq of zlocs.  Output is a sequence of\n  seqs, where the seqs are usually pairs, but might be single things.\n  Doesn't pair up comments or #_(...) unevaled sexpressions.  The\n  ones before the first part of a pair come as a single element in\n  what would usually be a pair, and the ones between the first and\n  second parts of a pair come inside the pair.  There may be an\n  arbitrary number of elements between the first and second elements\n  of the pair (one per line).  If there are any comments or unevaled\n  sexpressions, don't sort the keys, as we might lose track of where\n  the comments or unevaled s-expressions go."],"~$length-before",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",2780,"^8",7,"^9",2780,"^:",20,"^>Q",["^2U",["^>R",["^2U",[["^?R"]]]]],"^>Z","Given a zloc, find the amount of printing space before it on its\n  current line."],"^T","^:F","^6","zprint/zprint.cljc","^:",20,"^>[",["^2U",[["^?R"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",2780,"^?4",["^S",["^?O","^?H"]],"^9",2780,"^?6",1,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[["^?R"]]]]],"^>Z","Given a zloc, find the amount of printing space before it on its\n  current line."],"~$fzprint-future-promise-delay-agent",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",4775,"^8",7,"^9",4775,"^:",41,"^>Q",["^2U",["^>R",["^2U",[["^>W","^?E","^?R"]]]]],"^>Z","Print out a future or a promise or a delay.  These can only be \n  sexpressions, since they don't exist in a textual representation \n  of code (or data for that matter).  That means that we can use \n  regular sexpression operations on zloc."],"^T","^83","^6","zprint/zprint.cljc","^:",41,"^>[",["^2U",[["^>W","^?E","^?R"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",4775,"^?4",["^S",["^??","^?O","^?I"]],"^9",4775,"^?6",3,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[["^>W","^?E","^?R"]]]]],"^>Z","Print out a future or a promise or a delay.  These can only be \n  sexpressions, since they don't exist in a textual representation \n  of code (or data for that matter).  That means that we can use \n  regular sexpression operations on zloc."],"~$rightmost",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",643,"^8",7,"^9",643,"^:",16,"^>Q",["^2U",["^>R",["^2U",[["^>W"]]]]],"^>Z","Increase the rightmost count, if any, and return one if not."],"^T","^97","^6","zprint/zprint.cljc","^:",16,"^>[",["^2U",[["^>W"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",643,"^?4",["^S",["^??","^?O"]],"^9",643,"^?6",1,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[["^>W"]]]]],"^>Z","Increase the rightmost count, if any, and return one if not."],"~$split-lf-2",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",60,"^8",7,"^9",60,"^:",17,"^>Q",["^2U",["^>R",["^2U",[["~$s"]]]]],"^>Z","Do split for newlines, instead of using regular expressions.\n  Maximum split is 2."],"^T","^9>","^6","zprint/zprint.cljc","^:",17,"^>[",["^2U",[["~$s"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",60,"^?4","^?;","^9",60,"^?6",1,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[["~$s"]]]]],"^>Z","Do split for newlines, instead of using regular expressions.\n  Maximum split is 2."],"~$c-r-pair",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",653,"^8",7,"^9",653,"^:",15,"^>Q",["^2U",["^>R",["^2U",[["~$commas?","~$rightmost-pair?","~$rightmost?","^>W"]]]]],"^>Z","Handle the complexity of commas and rightmost-pair with options.\n  If it isn't a rightmost, it loses rightmost status.\n  If it is a rightmost, and in the rightmost pair, it gain one rightmost\n  since it has the right end thing (and we don't care about the comma).\n  If it is the rightmost of the non-rightmost-pair, then the comma\n  matters, and we handle that appropriately.  Whew!"],"^T","^99","^6","zprint/zprint.cljc","^:",15,"^>[",["^2U",[["^@X","^@Y","^@Z","^>W"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",653,"^?4",["^S",[null,"^??","^?O","^?I"]],"^9",653,"^?6",4,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[["^@X","^@Y","^@Z","^>W"]]]]],"^>Z","Handle the complexity of commas and rightmost-pair with options.\n  If it isn't a rightmost, it loses rightmost status.\n  If it is a rightmost, and in the rightmost pair, it gain one rightmost\n  since it has the right end thing (and we don't care about the comma).\n  If it is the rightmost of the non-rightmost-pair, then the comma\n  matters, and we handle that appropriately.  Whew!"],"~$fzprint-fn-obj",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",4831,"^8",7,"^9",4831,"^:",21,"^>Q",["^2U",["^>R",["^2U",[[["^;J",[["^ ","^>S",["~$object?"]],"~:fn-obj","^2X","^>W"]],"^?E","^?R"]]]]],"^>Z","Print a function object, what you get when you put a function in\n  a collection, for instance.  This doesn't do macros, you will notice.\n  It also can't be invoked when zloc is a zipper."],"^T","^9F","^6","zprint/zprint.cljc","^:",21,"^>[",["^2U",[["~$p__46063","^?E","^?R"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",4831,"^?4",["^S",["^??","^?O","^?I"]],"^9",4831,"^?6",3,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[[["^;J",[["^ ","^>S",["^A0"]],"^A1","^2X","^>W"]],"^?E","^?R"]]]]],"^>Z","Print a function object, what you get when you put a function in\n  a collection, for instance.  This doesn't do macros, you will notice.\n  It also can't be invoked when zloc is a zipper."],"~$single-line?",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",559,"^8",7,"^9",559,"^:",19,"^>Q",["^2U",["^>R",["^2U",[["^?:"]]]]],"^>Z","This looks at a style vec and doesn't do all that style-lines does.\n  It just looks for a new-line in the strings, and returns true if it\n  doesn't find one."],"^T","^9?","^6","zprint/zprint.cljc","^:",19,"^>[",["^2U",[["^?:"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",559,"^?4","^?5","^9",559,"^?6",1,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[["^?:"]]]]],"^>Z","This looks at a style vec and doesn't do all that style-lines does.\n  It just looks for a new-line in the strings, and returns true if it\n  doesn't find one."],"~$fzprint-map*",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",4579,"^8",7,"^9",4579,"^:",19,"^>Q",["^2U",["^>R",["^2U",[["^?C","~$l-str","~$r-str",["^;J",["^>S",["~$one-line?","~$ztype","~$map-depth","~$in-code?"],["^ ","^>S",["~$comma?","~$key-ignore","~$key-ignore-silent","^?[","~$force-nl?","~$lift-ns?","~$lift-ns-in-code?","~$indent"],"^2X","~$map-options"],"^?C","^2X","^>W"]],"^?E","^?R","^2V"]]]]]],"^T","^7C","^6","zprint/zprint.cljc","^:",19,"^>[",["^2U",[["^?C","^A5","^A6","~$p__46037","^?E","^?R","^2V"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",4579,"^?4",["^S",["^??","^?O","^?I"]],"^9",4579,"^?6",7,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[["^?C","^A5","^A6",["^;J",["^>S",["^A7","^A8","^A9","^A:"],["^ ","^>S",["^A;","^A<","^A=","^?[","^A>","^A?","^A@","^AA"],"^2X","^AB"],"^?C","^2X","^>W"]],"^?E","^?R","^2V"]]]]]],"~$constant-pair",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",2067,"^8",7,"^9",2067,"^:",20,"^>Q",["^2U",["^>R",["^2U",[["^?C",["^;J",[["^ ","^>S",["^?V","^?W"]],"^?C","^2X","^>W"]],"^@3"]]]]],"^>Z","Argument is a zloc-seq.  Output is a [pair-seq non-paired-item-count],\n  if any.  If there are no pair-seqs, pair-seq must be nil, not an\n  empty seq.  This will largely ignore newlines and comments."],"^T","^8D","^6","zprint/zprint.cljc","^:",20,"^>[",["^2U",[["^?C","~$p__45740","^@3"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",2067,"^?4","^?;","^9",2067,"^?6",3,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[["^?C",["^;J",[["^ ","^>S",["^?V","^?W"]],"^?C","^2X","^>W"]],"^@3"]]]]],"^>Z","Argument is a zloc-seq.  Output is a [pair-seq non-paired-item-count],\n  if any.  If there are no pair-seqs, pair-seq must be nil, not an\n  empty seq.  This will largely ignore newlines and comments."],"~$order-out",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",1261,"^8",7,"^9",1261,"^:",16,"^>Q",["^2U",["^>R",["^2U",[["^?C",["^;J",[["^ ","^>S",["~$sort?","~$sort-in-code?","~$key-order","~$key-value"]],"^?C","^>S",["^A:"],"^2X","^>W"]],"~$access","~$out"]]]]],"^>Z","A variety of sorting and ordering options for the output of\n  partition-all-2-nc.  It can sort, which is the default, but if\n  the caller has a key-order vector, it will extract any keys in\n  that vector and place them first (in order) before sorting the\n  other keys.  If sorting is not called for, does nothing."],"^T","^8;","^6","zprint/zprint.cljc","^:",16,"^>[",["^2U",[["^?C","~$p__45527","^AK","^AL"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",1261,"^?4",["^S",[null,"^??","~$cljs.core/IList","~$cljs.core/MetaFn","^?I"]],"^9",1261,"^?6",4,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[["^?C",["^;J",[["^ ","^>S",["^AG","^AH","^AI","^AJ"]],"^?C","^>S",["^A:"],"^2X","^>W"]],"^AK","^AL"]]]]],"^>Z","A variety of sorting and ordering options for the output of\n  partition-all-2-nc.  It can sort, which is the default, but if\n  the caller has a key-order vector, it will extract any keys in\n  that vector and place them first (in order) before sorting the\n  other keys.  If sorting is not called for, does nothing."],"~$comment-in-zloc-seq?",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",4116,"^8",7,"^9",4116,"^:",27,"^>Q",["^2U",["^>R",["^2U",[["^@3"]]]]],"^>Z","If there are any comments at the top level of the zloc-seq, return true,\n  else nil."],"^T","^7<","^6","zprint/zprint.cljc","^:",27,"^>[",["^2U",[["^@3"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",4116,"^?4",["^S",[null,"^?O"]],"^9",4116,"^?6",1,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[["^@3"]]]]],"^>Z","If there are any comments at the top level of the zloc-seq, return true,\n  else nil."],"~$hang-indent",["^ ","^T","^7F","^6","zprint/zprint.cljc","^7",3083,"^8",1,"^9",3083,"^:",17,"^5",["^ ","^6","zprint/zprint.cljc","^7",3083,"^8",6,"^9",3083,"^:",17],"^>M","^>N"],"~$fzprint-two-up",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",778,"^8",7,"^9",778,"^:",21,"^>Q",["^2U",["^>R",["^2U",[["^?C",["^;J",["^>S",["^A7","^?T","~$dbg-indent","~$in-hang?","~$do-in-hang?","^A9"],["^ ","^>S",["^?U","~$dbg-local?","~$dbg-cnt?","^AA","~$indent-arg","~$flow?","~$key-color","~$key-depth-color","~$key-value-color"]],"^?C","^2X","^>W"]],"^?E","^@X","~$justify-width","^@Y",["~$lloc","~$rloc","~$xloc","^2X","~$pair"]]]]]],"^>Z","Print a single pair of things (though it might not be exactly a\n  pair, given comments and :extend and the like), like bindings in\n  a let, clauses in a cond, keys and values in a map.  Controlled\n  by various maps, the key of which is caller.  Returns \n  [:hang <style-vec>] or [:flow <style-vec>] so that the upstream folks\n  know whether this was a hang or flow and can do the right thing\n  based on that."],"^T","^9O","^6","zprint/zprint.cljc","^:",21,"^>[",["^2U",[["^?C","~$p__45457","^?E","^@X","^B1","^@Y","~$p__45458"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",778,"^?4",["^S",["^?;","^?I"]],"^9",778,"^?6",7,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[["^?C",["^;J",["^>S",["^A7","^?T","^AS","^AT","^AU","^A9"],["^ ","^>S",["^?U","^AV","^AW","^AA","^AX","^AY","^AZ","^A[","^B0"]],"^?C","^2X","^>W"]],"^?E","^@X","^B1","^@Y",["^B2","^B3","^B4","^2X","^B5"]]]]]],"^>Z","Print a single pair of things (though it might not be exactly a\n  pair, given comments and :extend and the like), like bindings in\n  a let, clauses in a cond, keys and values in a map.  Controlled\n  by various maps, the key of which is caller.  Returns \n  [:hang <style-vec>] or [:flow <style-vec>] so that the upstream folks\n  know whether this was a hang or flow and can do the right thing\n  based on that."],"~$newline-or-comment?",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",2563,"^8",7,"^9",2563,"^:",26,"^>Q",["^2U",["^>R",["^2U",[["^?R"]]]]],"^>Z","Given an zloc, is it a newline or a comment?"],"^T","^9Q","^6","zprint/zprint.cljc","^:",26,"^>[",["^2U",[["^?R"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",2563,"^?4",["^S",["^?5","^?I"]],"^9",2563,"^?6",1,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[["^?R"]]]]],"^>Z","Given an zloc, is it a newline or a comment?"],"~$prefix-tags",["^ ","^T","^8T","^6","zprint/zprint.cljc","^7",5092,"^8",1,"^9",5092,"^:",17,"^5",["^ ","^6","zprint/zprint.cljc","^7",5092,"^8",6,"^9",5092,"^:",17],"^>M","^?A"],"~$fzprint-flow-seq",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",1789,"^8",7,"^9",1789,"^:",23,"^>Q",["^2U",["^>R",["^2U",[["^>W","^?E","^@3","^A>","~$nl-first?"],["^>W","^?E","^@3"],["^>W","^?E","^@3","^A>"]]]]],"^>Z","Takes zloc-seq, a seq of a zloc, created by (zmap identity zloc),\n  and returns a style-vec of the result.  Either it fits on one\n  line, or it is rendered on multiple lines.  You can force multiple\n  lines with force-nl?. If the seq is empty, returns :noseq, which\n  is what you give concat-no-nil if you want this to just disappear.\n  If you want it to do less than everything in the original zloc,\n  modify the result of (zmap identity zloc) to just contain what\n  you want to print. ind is either a single indent, or a seq of\n  indents, one for each element in zloc-seq.  Don't concatenate an\n  indent/newline on to the beginning of the output from this routine.\n  Let this routine do it for you, as it needs to know one is there\n  in order to properly deal with any newlines in the actual stream.\n  Else you will get two where you only should have one.","^?L",["^ ","^?3",false,"^?M",5,"^?6",5,"^>[",[["^>W","^?E","^@3","^A>","^B;"],["^>W","^?E","^@3"],["^>W","^?E","^@3","^A>"]],"^>Q",["^2U",[["^>W","^?E","^@3","^A>","^B;"],["^>W","^?E","^@3"],["^>W","^?E","^@3","^A>"]]],"^?2",["^2U",[null,null,null]]]],"^T","^8P","^6","zprint/zprint.cljc","^:",23,"^?L",["^ ","^?3",false,"^?M",5,"^?6",5,"^>[",[["^>W","^?E","^@3","^A>","^B;"],["^>W","^?E","^@3"],["^>W","^?E","^@3","^A>"]],"^>Q",["^2U",[["^>W","^?E","^@3","^A>","^B;"],["^>W","^?E","^@3"],["^>W","^?E","^@3","^A>"]]],"^?2",["^2U",[null,null,null]]],"^>[",[["^>W","^?E","^@3","^A>","^B;"],["^>W","^?E","^@3"],["^>W","^?E","^@3","^A>"]],"^?1",null,"^?M",5,"^?2",["^2U",[null,null,null]],"^8",1,"^?3",false,"^?N",[["^ ","^?M",5,"^?3",false,"^>M",["^S",["^?O","^5="]]],["^ ","^?M",3,"^?3",false,"^>M",["^S",["^?O","^5="]]],["^ ","^?M",4,"^?3",false,"^>M",["^S",["^?O","^5="]]]],"^7",1789,"^9",1789,"^?6",5,"^?7",true,"^>Q",["^2U",[["^>W","^?E","^@3","^A>","^B;"],["^>W","^?E","^@3"],["^>W","^?E","^@3","^A>"]]],"^>Z","Takes zloc-seq, a seq of a zloc, created by (zmap identity zloc),\n  and returns a style-vec of the result.  Either it fits on one\n  line, or it is rendered on multiple lines.  You can force multiple\n  lines with force-nl?. If the seq is empty, returns :noseq, which\n  is what you give concat-no-nil if you want this to just disappear.\n  If you want it to do less than everything in the original zloc,\n  modify the result of (zmap identity zloc) to just contain what\n  you want to print. ind is either a single indent, or a seq of\n  indents, one for each element in zloc-seq.  Don't concatenate an\n  indent/newline on to the beginning of the output from this routine.\n  Let this routine do it for you, as it needs to know one is there\n  in order to properly deal with any newlines in the actual stream.\n  Else you will get two where you only should have one."],"~$gather-up-to-next-zloc",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",2609,"^8",7,"^9",2609,"^:",29,"^>Q",["^2U",["^>R",["^2U",[["^@3"]]]]],"^>Z","Given a zloc-seq, gather newlines and comments up to the next\n  zloc into a seq.  Returns [seq next-zloc next-count]."],"^T","^8Q","^6","zprint/zprint.cljc","^:",29,"^>[",["^2U",[["^@3"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",2609,"^?4","^?;","^9",2609,"^?6",1,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[["^@3"]]]]],"^>Z","Given a zloc-seq, gather newlines and comments up to the next\n  zloc into a seq.  Returns [seq next-zloc next-count]."],"~$noarg1-map",["^ ","^T","^8L","^6","zprint/zprint.cljc","^7",3239,"^8",1,"^9",3239,"^:",16,"^5",["^ ","^6","zprint/zprint.cljc","^7",3239,"^8",6,"^9",3239,"^:",16],"^>M","^?A"],"~$zcolor-map",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",699,"^8",7,"^9",699,"^:",17,"^>Q",["^2U",["^>R",["^2U",[[["^ ","^>S",["~$color-map"],"^2X","^>W"],"~$key-or-str"]]]]],"^>Z","Look up the thing in the zprint-color-map.  Accepts keywords or\n  strings."],"^T","^:;","^6","zprint/zprint.cljc","^:",17,"^>[",["^2U",[["~$p__45414","^B@"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",699,"^?4","^?O","^9",699,"^?6",2,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[[["^ ","^>S",["^B?"],"^2X","^>W"],"^B@"]]]]],"^>Z","Look up the thing in the zprint-color-map.  Accepts keywords or\n  strings."],"~$next-actual",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",2808,"^8",7,"^9",2808,"^:",18,"^>Q",["^2U",["^>R",["^2U",[["^?R"]]]]],"^>Z","Return the next actual element, ignoring comments and whitespace\n  and everything else but real elements."],"^T","^;B","^6","zprint/zprint.cljc","^:",18,"^>[",["^2U",[["^?R"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",2808,"^?4",["^S",[null,"^?O","^?I"]],"^9",2808,"^?6",1,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[["^?R"]]]]],"^>Z","Return the next actual element, ignoring comments and whitespace\n  and everything else but real elements."],"~$fzprint-ns",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",4880,"^8",7,"^9",4880,"^:",17,"^>Q",["^2U",["^>R",["^2U",[["^>W","^?E","^?R"]]]]]],"^T","^:=","^6","zprint/zprint.cljc","^:",17,"^>[",["^2U",[["^>W","^?E","^?R"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",4880,"^?4",["^S",["^??","^?O","^?I"]],"^9",4880,"^?6",3,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[["^>W","^?E","^?R"]]]]]],"~$str->key",["^ ","^T","^;5","^6","zprint/zprint.cljc","^7",682,"^8",1,"^9",682,"^:",14,"^5",["^ ","^6","zprint/zprint.cljc","^7",682,"^8",6,"^9",682,"^:",14],"^>M","^?A"],"~$fzprint-hang-one",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",1827,"^8",7,"^9",1827,"^:",23,"^>Q",["^2U",["^>R",["^2U",[["^?C",["^;J",["^>S",["^A7","^?="],["^ ","^>S",["^?X"]],"^?C","^2X","^>W"]],"^@1","^@2","^?R"]]]]],"^>Z","Try out the given zloc, and if it fits on the current line, just\n  do that. It might fit on the same line, as this may not be the rest\n  of the list that we are printing. If not, check it out with good-enough?\n  and do the best you can.  Three choices, really: fits on same line, \n  does ok as hanging, or better with flow. hindent is hang-indent, and \n  findent is flow-indent, and each contains the initial separator.  \n  Might be nice if the fn-style actually got sent to this fn."],"^T","^8W","^6","zprint/zprint.cljc","^:",23,"^>[",["^2U",[["^?C","~$p__45732","^@1","^@2","^?R"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",1827,"^?4",["^S",["^??","^?O","^?I"]],"^9",1827,"^?6",5,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[["^?C",["^;J",["^>S",["^A7","^?="],["^ ","^>S",["^?X"]],"^?C","^2X","^>W"]],"^@1","^@2","^?R"]]]]],"^>Z","Try out the given zloc, and if it fits on the current line, just\n  do that. It might fit on the same line, as this may not be the rest\n  of the list that we are printing. If not, check it out with good-enough?\n  and do the best you can.  Three choices, really: fits on same line, \n  does ok as hanging, or better with flow. hindent is hang-indent, and \n  findent is flow-indent, and each contains the initial separator.  \n  Might be nice if the fn-style actually got sent to this fn."],"~$fzprint-extend",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",1676,"^8",7,"^9",1676,"^:",21,"^>Q",["^2U",["^>R",["^2U",[[["^;J",[["^ ","^>S",["^?["]],"~:extend","^2X","^>W"]],"^?E","^@3"]]]]],"^>Z","Print things with a symbol and collections following.  Kind of like with\n  pairs, but not quite. Takes a zloc-seq."],"^T","^:9","^6","zprint/zprint.cljc","^:",21,"^>[",["^2U",[["~$p__45686","^?E","^@3"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",1676,"^?4","^?O","^9",1676,"^?6",3,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[[["^;J",[["^ ","^>S",["^?["]],"^BH","^2X","^>W"]],"^?E","^@3"]]]]],"^>Z","Print things with a symbol and collections following.  Kind of like with\n  pairs, but not quite. Takes a zloc-seq."],"~$find-what",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",569,"^8",7,"^9",569,"^:",16,"^>Q",["^2U",["^>R",["^2U",[["^?:"]]]]],"^>Z","Given a style-vec, come up with a string that gives some hint of \n  where this style-vec came from."],"^T","^:B","^6","zprint/zprint.cljc","^:",16,"^>[",["^2U",[["^?:"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",569,"^?4",["^S",[null,"^?O","^?I"]],"^9",569,"^?6",1,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[["^?:"]]]]],"^>Z","Given a style-vec, come up with a string that gives some hint of \n  where this style-vec came from."],"~$fzprint-atom",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",4752,"^8",7,"^9",4752,"^:",19,"^>Q",["^2U",["^>R",["^2U",[[["^;J",[["^ ","^>S",["^A0"]],"~:atom","^2X","^>W"]],"^?E","^?R"]]]]]],"^T","^:C","^6","zprint/zprint.cljc","^:",19,"^>[",["^2U",[["~$p__46058","^?E","^?R"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",4752,"^?4",["^S",["^??","^?O","^?I"]],"^9",4752,"^?6",3,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[[["^;J",[["^ ","^>S",["^A0"]],"^BL","^2X","^>W"]],"^?E","^?R"]]]]]],"~$comment-vec-column",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",5734,"^8",7,"^9",5734,"^:",25,"^>Q",["^2U",["^>R",["^2U",[["^?:",["~$indent-index","~$inline-comment-index","^2X","~$comment-vec"]]]]]],"^>Z","Take a single inline comment vector:\n  [indent-index inline-comment-index] \n  and replace it with [inline-comment-index start-column spaces-before]."],"^T","^9H","^6","zprint/zprint.cljc","^:",25,"^>[",["^2U",[["^?:","~$p__46150"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",5734,"^?4","^?;","^9",5734,"^?6",2,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[["^?:",["^BO","^BP","^2X","^BQ"]]]]]],"^>Z","Take a single inline comment vector:\n  [indent-index inline-comment-index] \n  and replace it with [inline-comment-index start-column spaces-before]."],"~$fzprint-indent",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",3113,"^8",7,"^9",3113,"^:",21,"^>Q",["^2U",["^>R",["^2U",[["^?C","^A5","^A6","^>W","^?E","^?R","^>Y","~$arg-1-indent","~$first-indent-only?"],["^?C","^A5","^A6","^>W","^?E","^?R","^>Y","^BT"]]]]],"^>Z","This function assumes that :indent-only? was set for the caller\n  in the options (since anything else doesn't make sense).  It takes\n  a zloc and the ind, which is where we are on the line this point,\n  and will process the zloc to include any newlines.  Of course we\n  have to have all of the white space in the zloc too, since we\n  need to ask some questions about what we are starting with at\n  some point.  We don't add newlines and we let the newlines that\n  are in there do their thing.  We might add newlines if we move\n  beyond the right margin, but for now, we don't (and it isn't\n  entirely clear how or if that would work).  This routine has to\n  make decisions about the indent, that is whether to hang or flow\n  the expression. It does that based on what was done in the input\n  if the configuration allows.","^?L",["^ ","^?3",false,"^?M",9,"^?6",9,"^>[",[["^?C","^A5","^A6","^>W","^?E","^?R","^>Y","^BT","^BU"],["^?C","^A5","^A6","^>W","^?E","^?R","^>Y","^BT"]],"^>Q",["^2U",[["^?C","^A5","^A6","^>W","^?E","^?R","^>Y","^BT","^BU"],["^?C","^A5","^A6","^>W","^?E","^?R","^>Y","^BT"]]],"^?2",["^2U",[null,null]]]],"^T","^:E","^6","zprint/zprint.cljc","^:",21,"^?L",["^ ","^?3",false,"^?M",9,"^?6",9,"^>[",[["^?C","^A5","^A6","^>W","^?E","^?R","^>Y","^BT","^BU"],["^?C","^A5","^A6","^>W","^?E","^?R","^>Y","^BT"]],"^>Q",["^2U",[["^?C","^A5","^A6","^>W","^?E","^?R","^>Y","^BT","^BU"],["^?C","^A5","^A6","^>W","^?E","^?R","^>Y","^BT"]]],"^?2",["^2U",[null,null]]],"^>[",[["^?C","^A5","^A6","^>W","^?E","^?R","^>Y","^BT","^BU"],["^?C","^A5","^A6","^>W","^?E","^?R","^>Y","^BT"]],"^?1",null,"^?M",9,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^?N",[["^ ","^?M",9,"^?3",false,"^>M",["^S",["^??","^?;","^?I"]]],["^ ","^?M",8,"^?3",false,"^>M",["^S",["^??","^?;","^?I"]]]],"^7",3113,"^9",3113,"^?6",9,"^?7",true,"^>Q",["^2U",[["^?C","^A5","^A6","^>W","^?E","^?R","^>Y","^BT","^BU"],["^?C","^A5","^A6","^>W","^?E","^?R","^>Y","^BT"]]],"^>Z","This function assumes that :indent-only? was set for the caller\n  in the options (since anything else doesn't make sense).  It takes\n  a zloc and the ind, which is where we are on the line this point,\n  and will process the zloc to include any newlines.  Of course we\n  have to have all of the white space in the zloc too, since we\n  need to ask some questions about what we are starting with at\n  some point.  We don't add newlines and we let the newlines that\n  are in there do their thing.  We might add newlines if we move\n  beyond the right margin, but for now, we don't (and it isn't\n  entirely clear how or if that would work).  This routine has to\n  make decisions about the indent, that is whether to hang or flow\n  the expression. It does that based on what was done in the input\n  if the configuration allows."],"~$fix-rightcnt",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",669,"^8",7,"^9",669,"^:",19,"^>Q",["^2U",["^>R",["^2U",[["~$rightcnt"]]]]],"^>Z","Handle issue with rightcnt."],"^T","^:G","^6","zprint/zprint.cljc","^:",19,"^>[",["^2U",[["^BW"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",669,"^?4","^?H","^9",669,"^?6",1,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[["^BW"]]]]],"^>Z","Handle issue with rightcnt."],"~$r",["^ ","~:num-fields",2,"~:protocols",["^S",["~$cljs.core/IRecord","~$cljs.core/IKVReduce","~$cljs.core/IEquiv","~$cljs.core/IHash","~$cljs.core/ICollection","~$cljs.core/ICounted","~$cljs.core/ISeqable","~$cljs.core/IMeta","~$cljs.core/ICloneable","~$cljs.core/IPrintWithWriter","~$cljs.core/IIterable","~$cljs.core/IWithMeta","~$cljs.core/IAssociative","^?A","~$cljs.core/ILookup"]],"^T","^;G","^6","zprint/zprint.cljc","^:",13,"~:type",true,"^8",12,"~:internal-ctor",true,"^7",5898,"~:record",true,"^9",5898,"^>M","~$function","~:skip-protocol-flag",["^S",["^BZ","^B[","^C0","^C1","^C2","^C3","^C4","^C5","^C6","^C7","^C8","^C9","^C:","^?A","^C;"]]],"~$remove-nl",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",4090,"^8",7,"^9",4090,"^:",16,"^>Q",["^2U",["^>R",["^2U",[["^?F"]]]]],"^>Z","Remove any [_ _ :newline] from the seq."],"^T","^9:","^6","zprint/zprint.cljc","^:",16,"^>[",["^2U",[["^?F"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",4090,"^?4","^5R","^9",4090,"^?6",1,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[["^?F"]]]]],"^>Z","Remove any [_ _ :newline] from the seq."],"~$fzprint-map",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",4701,"^8",7,"^9",4701,"^:",18,"^>Q",["^2U",["^>R",["^2U",[["^>W","^?E","^?R"]]]]],"^>Z","Format a real map."],"^T","^8@","^6","zprint/zprint.cljc","^:",18,"^>[",["^2U",[["^>W","^?E","^?R"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",4701,"^?4",["^S",["^??","^?O","^?I"]],"^9",4701,"^?6",3,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[["^>W","^?E","^?R"]]]]],"^>Z","Format a real map."],"~$fzprint-vec*",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",4122,"^8",7,"^9",4122,"^:",19,"^>Q",["^2U",["^>R",["^2U",[["^?C","^A5","^A6",["^;J",["^>S",["^BW","^A:"],["^ ","^>S",["~$wrap-coll?","~$wrap?","~$binding?","~$option-fn-first","~$option-fn","^AG","^AH","~$fn-format","^AA"]],"^?C","^2X","^>W"]],"^?E","^?R"]]]]],"^>Z","Print basic stuff like a vector or a set or an array.  Several options \n  for how to print them."],"^T","^:Q","^6","zprint/zprint.cljc","^:",19,"^>[",["^2U",[["^?C","^A5","^A6","~$p__45965","^?E","^?R"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",4122,"^?4",["^S",["^??","^?O","^?I"]],"^9",4122,"^?6",6,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[["^?C","^A5","^A6",["^;J",["^>S",["^BW","^A:"],["^ ","^>S",["^CD","^CE","^CF","^CG","^CH","^AG","^AH","^CI","^AA"]],"^?C","^2X","^>W"]],"^?E","^?R"]]]]],"^>Z","Print basic stuff like a vector or a set or an array.  Several options \n  for how to print them."],"~$wrap-comment",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",5416,"^8",7,"^9",5416,"^:",19,"^>Q",["^2U",["^>R",["^2U",[["^?=",["~$s","~$color","~$stype","^2X","^@K"],"^@P"]]]]],"^>Z","If this is a comment, and it is too long, word wrap it to the right width.\n  Note that top level comments may well end with a newline, so remove it\n  and reapply it at the end if that is the case."],"^T","^9R","^6","zprint/zprint.cljc","^:",19,"^>[",["^2U",[["^?=","~$p__46100","^@P"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",5416,"^?4",["^S",[null,"^??"]],"^9",5416,"^?6",3,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[["^?=",["~$s","^CL","^CM","^2X","^@K"],"^@P"]]]]],"^>Z","If this is a comment, and it is too long, word wrap it to the right width.\n  Note that top level comments may well end with a newline, so remove it\n  and reapply it at the end if that is the case."],"~$comment-vec-seq-column",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",5743,"^8",7,"^9",5743,"^:",29,"^>Q",["^2U",["^>R",["^2U",[["^?:","~$comment-vec-seq"]]]]],"^>Z","Take a single vector of inline comments\n  [[indent-index inline-comment-index] [indent-index inline-comment-index]\n   ...] and replace it with [[inline-comment-index start-column spaces-before]\n   [inline-comment-index start-column spaces-before] ...]"],"^T","^9N","^6","zprint/zprint.cljc","^:",29,"^>[",["^2U",[["^?:","^CP"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",5743,"^?4","^5R","^9",5743,"^?6",2,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[["^?:","^CP"]]]]],"^>Z","Take a single vector of inline comments\n  [[indent-index inline-comment-index] [indent-index inline-comment-index]\n   ...] and replace it with [[inline-comment-index start-column spaces-before]\n   [inline-comment-index start-column spaces-before] ...]"],"~$log-lines",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",99,"^8",7,"^9",99,"^:",16,"^>Q",["^2U",["^>R",["^2U",[[["^ ","^>S",["~$dbg-print?","^AS","^AT"],"^2X","^>W"],"~$dbg-output","^?E","^?:"]]]]],"^>Z","Accept a style-vec that we are about to hand to style-lines, and\n  output it if called for, to aid in debugging."],"^T","^:I","^6","zprint/zprint.cljc","^:",16,"^>[",["^2U",[["~$p__45305","^CS","^?E","^?:"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",99,"^?4","^?I","^9",99,"^?6",4,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[[["^ ","^>S",["^CR","^AS","^AT"],"^2X","^>W"],"^CS","^?E","^?:"]]]]],"^>Z","Accept a style-vec that we are about to hand to style-lines, and\n  output it if called for, to aid in debugging."],"~$line-widths",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",5855,"^8",7,"^9",5855,"^:",18,"^>Q",["^2U",["^>R",["^2U",[["~$s"]]]]],"^>Z","Return a vector the lengths of lines."],"^T","^:J","^6","zprint/zprint.cljc","^:",18,"^>[",["^2U",[["~$s"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",5855,"^?4","^5R","^9",5855,"^?6",1,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[["~$s"]]]]],"^>Z","Return a vector the lengths of lines."],"~$concat-no-nil-pre-right",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",349,"^8",7,"^9",349,"^:",30,"^>Q",["^2U",["^>R",["^2U",[["~$&","^@9"]]]]],"^>Z","Concatentate multiple sequences, but if any of them are nil or empty\n  collections, return nil. If any of them are :noseq, just skip them.","^?L",["^ ","^?3",true,"^?M",0,"^?6",0,"^>[",[["^2U",["^@9"]]],"^>Q",["^2U",[["~$&","^@9"]]],"^?2",["^2U",[null]]]],"^T","^8<","^6","zprint/zprint.cljc","^:",30,"^?L",["^ ","^?3",true,"^?M",0,"^?6",0,"^>[",[["^2U",["^@9"]]],"^>Q",["^2U",[["~$&","^@9"]]],"^?2",["^2U",[null]]],"^>[",[["^2U",["^@9"]]],"^?1",null,"^?M",0,"^?2",["^2U",[null]],"^8",1,"^?3",true,"^?N",[["^ ","^?M",0,"^?3",true,"^>M",["^S",["^??","^?I"]]]],"^7",349,"^?4","^?O","^9",349,"^?6",0,"^?7",true,"^>Q",["^2U",[["~$&","^@9"]]],"^>Z","Concatentate multiple sequences, but if any of them are nil or empty\n  collections, return nil. If any of them are :noseq, just skip them."],"~$lift-style-vec",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",5490,"^8",7,"^9",5490,"^:",21,"^>Q",["^2U",["^>R",["^2U",[["^?:"]]]]],"^>Z","Take a style-vec [[s color type] [s color type] [[s color type]\n  [s color type]] [s color type] ...] and lift out the inner vectors."],"^T","^:5","^6","zprint/zprint.cljc","^:",21,"^>[",["^2U",[["^?:"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",5490,"^?4",["^S",[null,"^?O"]],"^9",5490,"^?6",1,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[["^?:"]]]]],"^>Z","Take a style-vec [[s color type] [s color type] [[s color type]\n  [s color type]] [s color type] ...] and lift out the inner vectors."],"~$fzprint-map-two-up",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",1134,"^8",7,"^9",1134,"^:",25,"^>Q",["^2U",["^>R",["^2U",[["^?C",["^;J",[["^ ","^>S",["^?D","^A>"]],"^?C","^>S",["^?=","^BW","^A7","~$parallel?"],"^2X","^>W"]],"^?E","^@X","^?F"]]]]],"^>Z","Accept a sequence of pairs, and map fzprint-two-up across those pairs.\n  If you have :one-line? set, this will return nil if it is way over,\n  but it can't accurately tell exactly what will fit on one line, since\n  it doesn't know the separators and such.  So, :one-line? true is a\n  performance optimization, so it doesn't do a whole huge map just to\n  find out that it could not possibly have fit on one line.  So, this\n  returns a sequence of style-vecs, where the indentation for the\n  stuff inside of the pairs is already there, but the separators of\n  the style-vecs (including indentation and commas) is done by the\n  caller of fzprint-map-two-up. Always returns a sequence of vector pairs:\n  [[:hang <style-vec-for-one-pair>] [:flow <style-vec-for-one-pair>] ...].\n  If you want a style vec instead, call remove-hangflow on the return \n  from fzprint-map-two-up.  This will use one-line?, but not check to see\n  that it actually fits.  If you care about that, then you should check the\n  return yourself.  It will, however, make an estimate of whether or not\n  it will fit and if it clearly doesn't, it will return a nil."],"^T","^;1","^6","zprint/zprint.cljc","^:",25,"^>[",["^2U",[["^?C","~$p__45518","^?E","^@X","^?F"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",1134,"^?4",["^S",["^??","^?;","^?O","^?I"]],"^9",1134,"^?6",5,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[["^?C",["^;J",[["^ ","^>S",["^?D","^A>"]],"^?C","^>S",["^?=","^BW","^A7","^CY"],"^2X","^>W"]],"^?E","^@X","^?F"]]]]],"^>Z","Accept a sequence of pairs, and map fzprint-two-up across those pairs.\n  If you have :one-line? set, this will return nil if it is way over,\n  but it can't accurately tell exactly what will fit on one line, since\n  it doesn't know the separators and such.  So, :one-line? true is a\n  performance optimization, so it doesn't do a whole huge map just to\n  find out that it could not possibly have fit on one line.  So, this\n  returns a sequence of style-vecs, where the indentation for the\n  stuff inside of the pairs is already there, but the separators of\n  the style-vecs (including indentation and commas) is done by the\n  caller of fzprint-map-two-up. Always returns a sequence of vector pairs:\n  [[:hang <style-vec-for-one-pair>] [:flow <style-vec-for-one-pair>] ...].\n  If you want a style vec instead, call remove-hangflow on the return \n  from fzprint-map-two-up.  This will use one-line?, but not check to see\n  that it actually fits.  If you care about that, then you should check the\n  return yourself.  It will, however, make an estimate of whether or not\n  it will fit and if it clearly doesn't, it will return a nil."],"~$rstr-vec",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",1550,"^8",7,"^9",1550,"^:",15,"^>Q",["^2U",["^>R",["^2U",[["^>W","^?E","^?R","^A6","~$r-type"],["^>W","^?E","^?R","^A6"]]]]],"^>Z","Create an r-str-vec with the indent appropriate for the r-str if\n  it is preceded by a newline.","^?L",["^ ","^?3",false,"^?M",5,"^?6",5,"^>[",[["^>W","^?E","^?R","^A6","^D0"],["^>W","^?E","^?R","^A6"]],"^>Q",["^2U",[["^>W","^?E","^?R","^A6","^D0"],["^>W","^?E","^?R","^A6"]]],"^?2",["^2U",[null,null]]]],"^T","^:3","^6","zprint/zprint.cljc","^:",15,"^?L",["^ ","^?3",false,"^?M",5,"^?6",5,"^>[",[["^>W","^?E","^?R","^A6","^D0"],["^>W","^?E","^?R","^A6"]],"^>Q",["^2U",[["^>W","^?E","^?R","^A6","^D0"],["^>W","^?E","^?R","^A6"]]],"^?2",["^2U",[null,null]]],"^>[",[["^>W","^?E","^?R","^A6","^D0"],["^>W","^?E","^?R","^A6"]],"^?1",null,"^?M",5,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^?N",[["^ ","^?M",5,"^?3",false,"^>M","^?;"],["^ ","^?M",4,"^?3",false,"^>M","^?;"]],"^7",1550,"^9",1550,"^?6",5,"^?7",true,"^>Q",["^2U",[["^>W","^?E","^?R","^A6","^D0"],["^>W","^?E","^?R","^A6"]]],"^>Z","Create an r-str-vec with the indent appropriate for the r-str if\n  it is preceded by a newline."],"~$zat",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",85,"^8",7,"^9",85,"^:",10,"^>Q",["^2U",["^>R",["^2U",[["^>W","~$value"]]]]],"^>Z","Takes an option map and the return from zfuture.  If the\n  options map has (:parallel? options) as true, then deref\n  the value, otherwise just pass it through."],"^T","^8M","^6","zprint/zprint.cljc","^:",10,"^>[",["^2U",[["^>W","^D2"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",85,"^9",85,"^?6",2,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[["^>W","^D2"]]]]],"^>Z","Takes an option map and the return from zfuture.  If the\n  options map has (:parallel? options) as true, then deref\n  the value, otherwise just pass it through."],"~$interpose-either",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",4279,"^8",7,"^9",4279,"^:",23,"^>Q",["^2U",["^>R",["^2U",[["~$sep-true","~$sep-nil","~$pred?","^?F"]]]]],"^>Z","Do the same as interpose, but different seps depending on pred?.\n  If sep-nil is nil, then when pred? is false we don't interpose\n  anything!"],"^T","^9X","^6","zprint/zprint.cljc","^:",23,"^>[",["^2U",[["^D4","^D5","^D6","^?F"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",4279,"^?4","^??","^9",4279,"^?6",4,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[["^D4","^D5","^D6","^?F"]]]]],"^>Z","Do the same as interpose, but different seps depending on pred?.\n  If sep-nil is nil, then when pred? is false we don't interpose\n  anything!"],"~$fzprint-hang",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",1604,"^8",7,"^9",1604,"^:",19,"^>Q",["^2U",["^>R",["^2U",[[["^ ","^>S",["^A7","~$force-eol-blanks?"],"^2X","^>W"],"^?C","^@1","^@2","~$fzfn","^@4","^?R"]]]]],"^>Z","Try to hang something and try to flow it, and then see which is\n  better.  Has hang and flow indents. fzfn is the function to use \n  to do zloc.  Note what fzfn does with the input. Presumably the\n  caller knows what the fzfn does, so it has to count the items\n  itself and pass it in here as zloc-count if it isn't just (zcount zloc)."],"^T","^;:","^6","zprint/zprint.cljc","^:",19,"^>[",["^2U",[["~$p__45616","^?C","^@1","^@2","^D9","^@4","^?R"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",1604,"^?4",["^S",["^??","^?O","^?I"]],"^9",1604,"^?6",7,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[[["^ ","^>S",["^A7","^D8"],"^2X","^>W"],"^?C","^@1","^@2","^D9","^@4","^?R"]]]]],"^>Z","Try to hang something and try to flow it, and then see which is\n  better.  Has hang and flow indents. fzfn is the function to use \n  to do zloc.  Note what fzfn does with the input. Presumably the\n  caller knows what the fzfn does, so it has to count the items\n  itself and pass it in here as zloc-count if it isn't just (zcount zloc)."],"~$wrap-zmap",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",3984,"^8",7,"^9",3984,"^:",16,"^>Q",["^2U",["^>R",["^2U",[["^?C",["^;J",["^>S",["^?=","^BW"],["^ ","^>S",["~$wrap-after-multi?","^@0"]],"^?C","^2X","^>W"]],"^?E","~$coll-print"]]]]],"^>Z","Given the output from fzprint-seq, which is a style-vec in\n  the making without spacing, but with extra [] around the elements,\n  wrap the elements to the right margin."],"^T","^;=","^6","zprint/zprint.cljc","^:",16,"^>[",["^2U",[["^?C","~$p__45951","^?E","^D="]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",3984,"^?4",["^S",["^?;","^5R","^?I"]],"^9",3984,"^?6",4,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[["^?C",["^;J",["^>S",["^?=","^BW"],["^ ","^>S",["^D<","^@0"]],"^?C","^2X","^>W"]],"^?E","^D="]]]]],"^>Z","Given the output from fzprint-seq, which is a style-vec in\n  the making without spacing, but with extra [] around the elements,\n  wrap the elements to the right margin."],"~$good-enough?",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",166,"^8",7,"^9",166,"^:",19,"^>Q",["^2U",["^>R",["^2U",[["^?C",["^;J",["^>S",["^?=","^BW","^?T"],["^ ","^>S",["~$hang-flow","~$hang-type-flow","~$hang-flow-limit","~$general-hang-adjust","~$hang-if-equal-flow?"]],"~:tuning",["^ ","^>S",["^?Y","^?Z","~$hang-size","~$hang-adjust"]],"^?C","^2X","^>W"]],"^>Y","~$p-count","~$indent-diff",["~$p-lines","~$p-maxwidth","~$p-length-seq","~$p-what"],["~$b-lines","~$b-maxwidth","~$_","~$b-what"]]]]]],"^>Z","Given the fn-style, is the first output good enough to be worth\n  doing. p is pretty, which is typically hanging, and b is basic, which\n  is typically flow. p-count is the number of elements in the hang."],"^T","^;@","^6","zprint/zprint.cljc","^:",19,"^>[",["^2U",[["^?C","~$p__45310","^>Y","^DH","^DI","~$p__45311","~$p__45312"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",166,"^?4",["^S",[null,"^?5","^?O","^?I"]],"^9",166,"^?6",7,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[["^?C",["^;J",["^>S",["^?=","^BW","^?T"],["^ ","^>S",["^D@","^DA","^DB","^DC","^DD"]],"^DE",["^ ","^>S",["^?Y","^?Z","^DF","^DG"]],"^?C","^2X","^>W"]],"^>Y","^DH","^DI",["^DJ","^DK","^DL","^DM"],["^DN","^DO","~$_","^DP"]]]]]],"^>Z","Given the fn-style, is the first output good enough to be worth\n  doing. p is pretty, which is typically hanging, and b is basic, which\n  is typically flow. p-count is the number of elements in the hang."],"~$precede-w-nl",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",4297,"^8",7,"^9",4297,"^:",19,"^>Q",["^2U",["^>R",["^2U",[["^>W","^?E","^?F","~$not-first?"]]]]],"^>Z","Move through a sequence of style vecs and ensure that at least\n  one newline (actually an indent) appears before each element.  If\n  a newline in the style-vecs is where we wanted one, well and good.\n  Comments are now not recognized as different, increasing our\n  appreciation of diversity.  If not-first? is truthy, then don't\n  put a newline before the first element."],"^T","^3T","^6","zprint/zprint.cljc","^:",19,"^>[",["^2U",[["^>W","^?E","^?F","^DU"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",4297,"^?4","^??","^9",4297,"^?6",4,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[["^>W","^?E","^?F","^DU"]]]]],"^>Z","Move through a sequence of style vecs and ensure that at least\n  one newline (actually an indent) appears before each element.  If\n  a newline in the style-vecs is where we wanted one, well and good.\n  Comments are now not recognized as different, increasing our\n  appreciation of diversity.  If not-first? is truthy, then don't\n  put a newline before the first element."],"~$get-max-length",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",381,"^8",7,"^9",381,"^:",21,"^>Q",["^2U",["^>R",["^2U",[[["^ ","^2X","^>W","^>S",["~$max-length","~$depth"]]]]]]],"^>Z","Given the options map, return the max length.  This might be\n  a constant number, but it might be based on the depth as well.\n  Returns nil of there is no max-length set."],"^T","^3W","^6","zprint/zprint.cljc","^:",21,"^>[",["^2U",[["~$p__45347"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",381,"^?4",["^S",["^?O","^?I"]],"^9",381,"^?6",1,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[[["^ ","^2X","^>W","^>S",["^DW","^DX"]]]]]]],"^>Z","Given the options map, return the max length.  This might be\n  a constant number, but it might be based on the depth as well.\n  Returns nil of there is no max-length set."],"~$lift-vec",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",5478,"^8",7,"^9",5478,"^:",15,"^>Q",["^2U",["^>R",["^2U",[["~$out-vec","^@K"]]]]],"^>Z","Take a transient output vector and a vector and lift any style-vec elements\n  out of the input vector."],"^T","^;7","^6","zprint/zprint.cljc","^:",15,"^>[",["^2U",[["^D[","^@K"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",5478,"^?4",["^S",[null,"^??"]],"^9",5478,"^?6",2,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[["^D[","^@K"]]]]],"^>Z","Take a transient output vector and a vector and lift any style-vec elements\n  out of the input vector."],"~$style-lines",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",598,"^8",7,"^9",598,"^:",18,"^>Q",["^2U",["^>R",["^2U",[["^>W","^?E","^?:"]]]]],"^>Z","Take a style output, and tell us how many lines it takes to print it\n  and the maximum width that it reaches. Returns \n  [<line-count> <max-width> [line-lengths]].\n  Doesn't require any max-width inside the style-vec. Also returns the\n  line lengths in case that is helpful (since we have them anyway).\n  If (:dbg-ge options) has value, then uses find-what to see if what it\n  finds matches the value, and if it does, place the value in the\n  resulting vector."],"^T","^;?","^6","zprint/zprint.cljc","^:",18,"^>[",["^2U",[["^>W","^?E","^?:"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",598,"^?4",["^S",["^??","^?I"]],"^9",598,"^?6",3,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[["^>W","^?E","^?:"]]]]],"^>Z","Take a style output, and tell us how many lines it takes to print it\n  and the maximum width that it reaches. Returns \n  [<line-count> <max-width> [line-lengths]].\n  Doesn't require any max-width inside the style-vec. Also returns the\n  line lengths in case that is helpful (since we have them anyway).\n  If (:dbg-ge options) has value, then uses find-what to see if what it\n  finds matches the value, and if it does, place the value in the\n  resulting vector."],"~$use-hang?",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",755,"^8",7,"^9",755,"^:",16,"^>Q",["^2U",["^>R",["^2U",[["^?C",["^;J",["^>S",["^DX","^?="],["^ ","^>S",["~$hang-accept","~$ha-depth-factor","~$ha-width-factor"]],"^?C","^2X","^>W"]],"^?E","~$hang-count","~$hanging-line-count"]]]]],"^>Z","This routine tries to figure out if existing hang should be used without\n  even bothering to do a flow and compare them with good-enough?."],"^T","^42","^6","zprint/zprint.cljc","^:",16,"^>[",["^2U",[["^?C","~$p__45447","^?E","^E5","^E6"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",755,"^?4",["^S",["^?5","^?I"]],"^9",755,"^?6",5,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[["^?C",["^;J",["^>S",["^DX","^?="],["^ ","^>S",["^E2","^E3","^E4"]],"^?C","^2X","^>W"]],"^?E","^E5","^E6"]]]]],"^>Z","This routine tries to figure out if existing hang should be used without\n  even bothering to do a flow and compare them with good-enough?."],"~$dec-depth",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",4899,"^8",7,"^9",4899,"^:",16,"^>Q",["^2U",["^>R",["^2U",[["^>W"]]]]],"^>Z","Given an options map, decrement the :depth value and return the result."],"^T","^;H","^6","zprint/zprint.cljc","^:",16,"^>[",["^2U",[["^>W"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",4899,"^?4",["^S",["^??","^?O","^?I"]],"^9",4899,"^?6",1,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[["^>W"]]]]],"^>Z","Given an options map, decrement the :depth value and return the result."],"~$zfind-seq",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",3201,"^8",7,"^9",3201,"^:",16,"^>Q",["^2U",["^>R",["^2U",[["~$zthing?","^@3"]]]]],"^>Z","Find the location, counting from zero, and counting every element \n  in the seq, of the first zthing?.  Return its index if it is found, \n  nil if not."],"^T","^;D","^6","zprint/zprint.cljc","^:",16,"^>[",["^2U",[["^E:","^@3"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",3201,"^?4",["^S",["^?H","^?I"]],"^9",3201,"^?6",2,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[["^E:","^@3"]]]]],"^>Z","Find the location, counting from zero, and counting every element \n  in the seq, of the first zthing?.  Return its index if it is found, \n  nil if not."],"~$fzprint-up-to-first-zloc",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",2671,"^8",7,"^9",2671,"^:",31,"^>Q",["^2U",["^>R",["^2U",[["^?C","^>W","^?E","^?R"]]]]],"^>Z","Returns [pre-first-style-vec first-zloc first-count zloc-seq], where\n  pre-first-style-vec will be :noseq if there isn't anything, and first-count\n  is what you give to nthnext to get to the first-zloc in zloc-seq."],"^T","^41","^6","zprint/zprint.cljc","^:",31,"^>[",["^2U",[["^?C","^>W","^?E","^?R"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",2671,"^?4","^?;","^9",2671,"^?6",4,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[["^?C","^>W","^?E","^?R"]]]]],"^>Z","Returns [pre-first-style-vec first-zloc first-count zloc-seq], where\n  pre-first-style-vec will be :noseq if there isn't anything, and first-count\n  is what you give to nthnext to get to the first-zloc in zloc-seq."],"~$next-newline",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",2711,"^8",7,"^9",2711,"^:",19,"^>Q",["^2U",["^>R",["^2U",[["^?R"]]]]],"^>Z","Given a zloc that is down inside of a collection, presumably\n  a list, return a vector containing the number of printing elements\n  we had to traverse to get to it as well as the newline."],"^T","^;E","^6","zprint/zprint.cljc","^:",19,"^>[",["^2U",[["^?R"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",2711,"^?4","^?;","^9",2711,"^?6",1,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[["^?R"]]]]],"^>Z","Given a zloc that is down inside of a collection, presumably\n  a list, return a vector containing the number of printing elements\n  we had to traverse to get to it as well as the newline."],"~$hash-identity-str",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",4743,"^8",7,"^9",4743,"^:",24,"^>Q",["^2U",["^>R",["^2U",[["~$obj"]]]]],"^>Z","Find the hash-code identity for an object."],"^T","^3D","^6","zprint/zprint.cljc","^:",24,"^>[",["^2U",[["^E>"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",4743,"^?4","~$string","^9",4743,"^?6",1,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[["^E>"]]]]],"^>Z","Find the hash-code identity for an object."],"~$last-space",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",5389,"^8",7,"^9",5389,"^:",17,"^>Q",["^2U",["^>R",["^2U",[["~$s","~$from-index"]]]]],"^>Z","Take a string and an index, and look for the last space prior to the\n  index. If we wanted to tie ourselves to 1.8, we could use \n  clojure.string/last-index-of, but we don't.  However, we use similar\n  conventions, i.e., if no space is found, return nil, and if the index\n  is a space return that value, and accept any from-index, including one\n  larger than the length of the string."],"^T","^9U","^6","zprint/zprint.cljc","^:",17,"^>[",["^2U",[["~$s","^EA"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",5389,"^?4",["^S",["^?H","^?I"]],"^9",5389,"^?6",2,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[["~$s","^EA"]]]]],"^>Z","Take a string and an index, and look for the last space prior to the\n  index. If we wanted to tie ourselves to 1.8, we could use \n  clojure.string/last-index-of, but we don't.  However, we use similar\n  conventions, i.e., if no space is found, return nil, and if the index\n  is a space return that value, and accept any from-index, including one\n  larger than the length of the string."],"~$fzprint-object",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",4730,"^8",7,"^9",4730,"^:",21,"^>Q",["^2U",["^>R",["^2U",[["^>W","^?E","^?R","~$zloc-value"],["^>W","^?E","^?R"]]]]],"^>Z","Print something that looks like #object[...] in a way\n  that will acknowledge the structure inside of the [...]","^?L",["^ ","^?3",false,"^?M",4,"^?6",4,"^>[",[["^>W","^?E","^?R","^EC"],["^>W","^?E","^?R"]],"^>Q",["^2U",[["^>W","^?E","^?R","^EC"],["^>W","^?E","^?R"]]],"^?2",["^2U",[null,null]]]],"^T","^9J","^6","zprint/zprint.cljc","^:",21,"^?L",["^ ","^?3",false,"^?M",4,"^?6",4,"^>[",[["^>W","^?E","^?R","^EC"],["^>W","^?E","^?R"]],"^>Q",["^2U",[["^>W","^?E","^?R","^EC"],["^>W","^?E","^?R"]]],"^?2",["^2U",[null,null]]],"^>[",[["^>W","^?E","^?R","^EC"],["^>W","^?E","^?R"]],"^?1",null,"^?M",4,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^?N",[["^ ","^?M",4,"^?3",false,"^>M",["^S",["^??","^?O","^?I"]]],["^ ","^?M",3,"^?3",false,"^>M",["^S",["^??","^?O","^?I"]]]],"^7",4730,"^9",4730,"^?6",4,"^?7",true,"^>Q",["^2U",[["^>W","^?E","^?R","^EC"],["^>W","^?E","^?R"]]],"^>Z","Print something that looks like #object[...] in a way\n  that will acknowledge the structure inside of the [...]"],"~$fzprint-set",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",4273,"^8",7,"^9",4273,"^:",18,"^>Q",["^2U",["^>R",["^2U",[["^>W","^?E","^?R"]]]]],"^>Z","Pretty print and focus style a :set element."],"^T","^3C","^6","zprint/zprint.cljc","^:",18,"^>[",["^2U",[["^>W","^?E","^?R"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",4273,"^?4",["^S",["^??","^?O","^?I"]],"^9",4273,"^?6",3,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[["^>W","^?E","^?R"]]]]],"^>Z","Pretty print and focus style a :set element."],"~$no-max-length",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",391,"^8",7,"^9",391,"^:",20,"^>Q",["^2U",["^>R",["^2U",[["^>W"]]]]],"^>Z","Given an options map, return another options map with no\n  :max-length key.  This is to that you can call a routine that\n  normally deals with :max-length and get it to do the normal\n  thing."],"^T","^:K","^6","zprint/zprint.cljc","^:",20,"^>[",["^2U",[["^>W"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",391,"^?4",["^S",["^??","^?O"]],"^9",391,"^?6",1,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[["^>W"]]]]],"^>Z","Given an options map, return another options map with no\n  :max-length key.  This is to that you can call a routine that\n  normally deals with :max-length and get it to do the normal\n  thing."],"~$fzprint-array",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",4269,"^8",7,"^9",4269,"^:",20,"^>Q",["^2U",["^>R",["^2U",[["^>W","^?E","^?R"]]]]]],"^T","^3N","^6","zprint/zprint.cljc","^:",20,"^>[",["^2U",[["^>W","^?E","^?R"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",4269,"^?4",["^S",["^??","^?O","^?I"]],"^9",4269,"^?6",3,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[["^>W","^?E","^?R"]]]]]],"~$noarg1",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",3246,"^8",7,"^9",3246,"^:",13,"^>Q",["^2U",["^>R",["^2U",[["^>W","~$fn-type"]]]]],"^>Z","Set noarg1 in the options if it is the right fn-type."],"^T","^:V","^6","zprint/zprint.cljc","^:",13,"^>[",["^2U",[["^>W","^EH"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",3246,"^?4",["^S",[null,"^??","^?O"]],"^9",3246,"^?6",2,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[["^>W","^EH"]]]]],"^>Z","Set noarg1 in the options if it is the right fn-type."],"~$map-ignore",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",1338,"^8",7,"^9",1338,"^:",17,"^>Q",["^2U",["^>R",["^2U",[["^?C",["^;J",[["^ ","^>S",["^A<","^A="]],"^?C","^2X","^>W"]],"^?R"]]]]],"^>Z","Take a map and remove any of the key sequences specified from it.\n  Note that this only works for sexpressions, not for actual zippers."],"^T","^:W","^6","zprint/zprint.cljc","^:",17,"^>[",["^2U",[["^?C","~$p__45546","^?R"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",1338,"^?4",["^S",[null,"^?O"]],"^9",1338,"^?6",3,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[["^?C",["^;J",[["^ ","^>S",["^A<","^A="]],"^?C","^2X","^>W"]],"^?R"]]]]],"^>Z","Take a map and remove any of the key sequences specified from it.\n  Note that this only works for sexpressions, not for actual zippers."],"~$newline-seq?",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",3090,"^8",7,"^9",3090,"^:",19,"^>Q",["^2U",["^>R",["^2U",[["^2O"]]]]],"^>Z","Given a vector of vectors, decide if we should merge these individually\n  into the top level vector."],"^T","^9W","^6","zprint/zprint.cljc","^:",19,"^>[",["^2U",[["^2O"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",3090,"^?4","^?5","^9",3090,"^?6",1,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[["^2O"]]]]],"^>Z","Given a vector of vectors, decide if we should merge these individually\n  into the top level vector."],"~$accumulate-ll",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",405,"^8",7,"^9",405,"^:",20,"^>Q",["^2U",["^>R",["^2U",[["~$count-comment?",["^AL","~$cur-len","~$just-eol?","~$just-comment?","^2X","~$in"],"~$s","~$tag","~$eol?"]]]]],"^>Z","Take the vector carrying the intermediate results, and\n  do the right thing with a new string. Vector is\n  [ 0 out - vector accumulating line lengths \n    1 cur-len - length of current line\n    just-eol? - did we just do an eol?\n    ]\n  s - string to add to current line\n  tag - element type of string (comment's don't count in length)\n  eol? - should we terminate line after adding count of s"],"^T","^;0","^6","zprint/zprint.cljc","^:",20,"^>[",["^2U",[["^EM","~$p__45349","~$s","^ER","^ES"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",405,"^?4","^?;","^9",405,"^?6",5,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[["^EM",["^AL","^EN","^EO","^EP","^2X","^EQ"],"~$s","^ER","^ES"]]]]],"^>Z","Take the vector carrying the intermediate results, and\n  do the right thing with a new string. Vector is\n  [ 0 out - vector accumulating line lengths \n    1 cur-len - length of current line\n    just-eol? - did we just do an eol?\n    ]\n  s - string to add to current line\n  tag - element type of string (comment's don't count in length)\n  eol? - should we terminate line after adding count of s"],"~$repeat-style-vec-nl",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",4406,"^8",7,"^9",4406,"^:",26,"^>Q",["^2U",["^>R",["^2U",[["~$n","^?:"]]]]],"^>Z","Given a count n, and style vec that ends with a newline and an associated\n  indent of some number of spaces, return a sequence of n of those style vecs\n  but remove spaces from all but the last of them."],"^T","^:R","^6","zprint/zprint.cljc","^:",26,"^>[",["^2U",[["~$n","^?:"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",4406,"^?4",["^S",[null,"^??","^?O"]],"^9",4406,"^?6",2,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[["~$n","^?:"]]]]],"^>Z","Given a count n, and style vec that ends with a newline and an associated\n  indent of some number of spaces, return a sequence of n of those style vecs\n  but remove spaces from all but the last of them."],"~$fzprint-anon-fn",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",3969,"^8",7,"^9",3969,"^:",22,"^>Q",["^2U",["^>R",["^2U",[["^>W","^?E","^?R"]]]]],"^>Z","Pretty print and focus style a fn element."],"^T","^:0","^6","zprint/zprint.cljc","^:",22,"^>[",["^2U",[["^>W","^?E","^?R"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",3969,"^?4",["^S",["^??","^?O","^?I"]],"^9",3969,"^?6",3,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[["^>W","^?E","^?R"]]]]],"^>Z","Pretty print and focus style a fn element."],"~$comment-vec-all-column",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",5751,"^8",7,"^9",5751,"^:",29,"^>Q",["^2U",["^>R",["^2U",[["^?:","~$comment-vec-all"]]]]],"^>Z","Take a seq of all of the comments as produced by \n  find-consecutive-inline-comments, and turn it into:\n  [[[inline-comment-index start-column spaces-before] [inline-comment-index\n  start-column spaces-before]\n  ...] ...]"],"^T","^;>","^6","zprint/zprint.cljc","^:",29,"^>[",["^2U",[["^?:","^EX"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",5751,"^?4","^5R","^9",5751,"^?6",2,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[["^?:","^EX"]]]]],"^>Z","Take a seq of all of the comments as produced by \n  find-consecutive-inline-comments, and turn it into:\n  [[[inline-comment-index start-column spaces-before] [inline-comment-index\n  start-column spaces-before]\n  ...] ...]"],"~$in-hang",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",267,"^8",7,"^9",267,"^:",14,"^>Q",["^2U",["^>R",["^2U",[["^>W"]]]]],"^>Z","Add :in-hang? true to the options map."],"^T","^4Y","^6","zprint/zprint.cljc","^:",14,"^>[",["^2U",[["^>W"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",267,"^?4",["^S",[null,"^??","^?O"]],"^9",267,"^?6",1,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[["^>W"]]]]],"^>Z","Add :in-hang? true to the options map."],"~$comment-column",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",5720,"^8",7,"^9",5720,"^:",21,"^>Q",["^2U",["^>R",["^2U",[[["^BO","~$comment-index"],"^?:"]]]]],"^>Z","Takes a single vector of [indent-index comment-index] and will show the\n  column on the line in which the comment starts."],"^T","^4Q","^6","zprint/zprint.cljc","^:",21,"^>[",["^2U",[["~$p__46146","^?:"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",5720,"^?4","^?H","^9",5720,"^?6",2,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[[["^BO","^E["],"^?:"]]]]],"^>Z","Takes a single vector of [indent-index comment-index] and will show the\n  column on the line in which the comment starts."],"~$line-size",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",5522,"^8",7,"^9",5522,"^:",16,"^>Q",["^2U",["^>R",["^2U",[["^?:"]]]]],"^>Z","Given a style-vec, how big is it in actual characters.  This doesn't\n  handle newlines."],"^T","^50","^6","zprint/zprint.cljc","^:",16,"^>[",["^2U",[["^?:"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",5522,"^?4","^?O","^9",5522,"^?6",1,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[["^?:"]]]]],"^>Z","Given a style-vec, how big is it in actual characters.  This doesn't\n  handle newlines."],"~$minimum-column",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",5760,"^8",7,"^9",5760,"^:",21,"^>Q",["^2U",["^>R",["^2U",[["^BQ"]]]]],"^>Z","Given a set of inline comments:\n  [[inline-comment-index start-column spaces-before]\n   [inline-comment-index start-column spaces-before] ...], determine\n   the minimum column at which they could be aligned."],"^T","^3S","^6","zprint/zprint.cljc","^:",21,"^>[",["^2U",[["^BQ"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",5760,"^?4","^?O","^9",5760,"^?6",1,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[["^BQ"]]]]],"^>Z","Given a set of inline comments:\n  [[inline-comment-index start-column spaces-before]\n   [inline-comment-index start-column spaces-before] ...], determine\n   the minimum column at which they could be aligned."],"~$interpose-either-nl-hf",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",4466,"^8",7,"^9",4466,"^:",29,"^>Q",["^2U",["^>R",["^2U",[["~$sep-comma","~$sep-comma-nl","~$sep","~$sep-nl",["^ ","^>S",["^?[","~$nl-separator-flow?"],"^2X","~$suboptions"],"^A;","^?F"]]]]],"^>Z","Do very specialized interpose, but different seps depending on pred-fn\n  return and nl-separator?. This assumes that sep-* does one line, and\n  sep-*-nl does two lines."],"^T","^;9","^6","zprint/zprint.cljc","^:",29,"^>[",["^2U",[["^F4","^F5","^F6","^F7","~$p__46017","^A;","^?F"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",4466,"^?4","^?O","^9",4466,"^?6",7,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[["^F4","^F5","^F6","^F7",["^ ","^>S",["^?[","^F8"],"^2X","^F9"],"^A;","^?F"]]]]],"^>Z","Do very specialized interpose, but different seps depending on pred-fn\n  return and nl-separator?. This assumes that sep-* does one line, and\n  sep-*-nl does two lines."],"~$fzprint-hang-unless-fail",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",720,"^8",7,"^9",720,"^:",31,"^>Q",["^2U",["^>R",["^2U",[["^>W","^@1","^@2","^D9","^?R"]]]]],"^>Z","Try to hang something and if it doesn't hang at all, then flow it,\n  but strongly prefer hang.  Has hang and flow indents, and fzfn is the\n  fzprint-? function to use with zloc.  Callers need to know whether this\n  was hang or flow, so it returns [{:hang | :flow} style-vec] all the time."],"^T","^;4","^6","zprint/zprint.cljc","^:",31,"^>[",["^2U",[["^>W","^@1","^@2","^D9","^?R"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",720,"^?4","^?;","^9",720,"^?6",5,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[["^>W","^@1","^@2","^D9","^?R"]]]]],"^>Z","Try to hang something and if it doesn't hang at all, then flow it,\n  but strongly prefer hang.  Has hang and flow indents, and fzfn is the\n  fzprint-? function to use with zloc.  Callers need to know whether this\n  was hang or flow, so it returns [{:hang | :flow} style-vec] all the time."],"~$keyword-fn?",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",374,"^8",7,"^9",374,"^:",18,"^>Q",["^2U",["^>R",["^2U",[["^>W","~$s"]]]]],"^>Z","Takes a string, and returns the fn-style if it is a keyword and\n  without the : it can be found in the fn-map."],"^T","^;6","^6","zprint/zprint.cljc","^:",18,"^>[",["^2U",[["^>W","~$s"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",374,"^?4",["^S",["^?O","^?I"]],"^9",374,"^?6",2,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[["^>W","~$s"]]]]],"^>Z","Takes a string, and returns the fn-style if it is a keyword and\n  without the : it can be found in the fn-map."],"~$not-rightmost",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",648,"^8",7,"^9",648,"^:",20,"^>Q",["^2U",["^>R",["^2U",[["^>W"]]]]],"^>Z","Remove the rightmost count."],"^T","^4S","^6","zprint/zprint.cljc","^:",20,"^>[",["^2U",[["^>W"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",648,"^?4",["^S",["^??","^?I"]],"^9",648,"^?6",1,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[["^>W"]]]]],"^>Z","Remove the rightmost count."],"~$remove-one-newline",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",2588,"^8",7,"^9",2588,"^:",25,"^>Q",["^2U",["^>R",["^2U",[["^?:"]]]]],"^>Z","Given a single style-vec, look at the last element, and if it is a\n  :newline, remove it.  If there is nothing left, return :noseq"],"^T","^44","^6","zprint/zprint.cljc","^:",25,"^>[",["^2U",[["^?:"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",2588,"^?4",["^S",[null,"~$seq","^5="]],"^9",2588,"^?6",1,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[["^?:"]]]]],"^>Z","Given a single style-vec, look at the last element, and if it is a\n  :newline, remove it.  If there is nothing left, return :noseq"],"~$find-aligned-inline-comments",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",5575,"^8",7,"^9",5575,"^:",35,"^>Q",["^2U",["^>R",["^2U",[["^?:"]]]]],"^>Z","Given a style-vec, find previously aligned inline comments and\n  output the as a sequence of vectors of comments. The previously\n  aligned comments do not have to be consecutive, but they can't\n  be separated by more than max-aligned-inline-comment-distance.\n  Each comment itself is a vector: [indent-index inline-comment-index],\n  yielding a [[[indent-index inline-comment-index] [indent-index\n  inline-comment-index] ...] ...].  The indexes are into the\n  style-vec."],"^T","^55","^6","zprint/zprint.cljc","^:",35,"^>[",["^2U",[["^?:"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",5575,"^?4",["^S",["^??","^?O"]],"^9",5575,"^?6",1,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[["^?:"]]]]],"^>Z","Given a style-vec, find previously aligned inline comments and\n  output the as a sequence of vectors of comments. The previously\n  aligned comments do not have to be consecutive, but they can't\n  be separated by more than max-aligned-inline-comment-distance.\n  Each comment itself is a vector: [indent-index inline-comment-index],\n  yielding a [[[indent-index inline-comment-index] [indent-index\n  inline-comment-index] ...] ...].  The indexes are into the\n  style-vec."],"~$zpmap",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",77,"^8",16,"^9",77,"^:",21,"^>Q",["^2U",["^>R",["^2U",[["^>W","~$f","^?F"],["^>W","~$f","~$coll1","~$coll2"]]]]],"^?L",["^ ","^?3",false,"^?M",4,"^?6",4,"^>[",[["^>W","~$f","^?F"],["^>W","~$f","^FB","^FC"]],"^>Q",["^2U",[["^>W","~$f","^?F"],["^>W","~$f","^FB","^FC"]]],"^?2",["^2U",[null,null]]]],"^T","^53","^6","zprint/zprint.cljc","^:",21,"^?L",["^ ","^?3",false,"^?M",4,"^?6",4,"^>[",[["^>W","~$f","^?F"],["^>W","~$f","^FB","^FC"]],"^>Q",["^2U",[["^>W","~$f","^?F"],["^>W","~$f","^FB","^FC"]]],"^?2",["^2U",[null,null]]],"^>[",[["^>W","~$f","^?F"],["^>W","~$f","^FB","^FC"]],"^?1",null,"^?M",4,"^?2",["^2U",[null,null]],"^8",10,"^?3",false,"^?N",[["^ ","^?M",3,"^?3",false,"^>M","^5R"],["^ ","^?M",4,"^?3",false,"^>M","^5R"]],"^7",77,"^9",77,"^?6",4,"^?7",true,"^>Q",["^2U",[["^>W","~$f","^?F"],["^>W","~$f","^FB","^FC"]]]],"~$change-start-column",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",5770,"^8",7,"^9",5770,"^:",26,"^>Q",["^2U",["^>R",["^2U",[["~$new-start-column","^?:",["^BP","~$start-column","~$spaces-before","^2X","^BQ"]]]]]],"^>Z","Given a new start-column, and a vector \n  [[inline-comment-index start-column spaces-before]\n  and a style-vec, return a new style-vec with the inline-comment starting\n  at a new column."],"^T","^56","^6","zprint/zprint.cljc","^:",26,"^>[",["^2U",[["^FE","^?:","~$p__46155"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",5770,"^?4",["^S",["^??","^?O"]],"^9",5770,"^?6",3,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[["^FE","^?:",["^BP","^FF","^FG","^2X","^BQ"]]]]]],"^>Z","Given a new start-column, and a vector \n  [[inline-comment-index start-column spaces-before]\n  and a style-vec, return a new style-vec with the inline-comment starting\n  at a new column."],"~$remove-last-newline",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",2570,"^8",7,"^9",2570,"^:",26,"^>Q",["^2U",["^>R",["^2U",[["~$ssv"]]]]],"^>Z","Given a seq of style-vecs, look at the last one, and if it is a\n  :newline, then remove it.  But the last one might be a single\n  one, in which case we will remove the whole thing, and it might be\n  the last one in a sequence, in which case we will remove just that\n  one.  If there is nothing left, return [[[\"\" :none :none]]]."],"^T","^45","^6","zprint/zprint.cljc","^:",26,"^>[",["^2U",[["^FJ"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",2570,"^?4",["^S",[null,"^??"]],"^9",2570,"^?6",1,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[["^FJ"]]]]],"^>Z","Given a seq of style-vecs, look at the last one, and if it is a\n  :newline, then remove it.  But the last one might be a single\n  one, in which case we will remove the whole thing, and it might be\n  the last one in a sequence, in which case we will remove just that\n  one.  If there is nothing left, return [[[\"\" :none :none]]]."],"~$noarg1-set",["^ ","^T","^:N","^6","zprint/zprint.cljc","^7",3237,"^8",1,"^9",3237,"^:",16,"^5",["^ ","^6","zprint/zprint.cljc","^7",3237,"^8",6,"^9",3237,"^:",16],"^>M","^>N"],"~$prepend-nl",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",585,"^8",7,"^9",585,"^:",17,"^>Q",["^2U",["^>R",["^2U",[["^>W","^?E","^?F"]]]]],"^>Z","Given an indent ind and a style-vec coll, place a newline (actually an\n  indent) at the front of coll.  If the first thing in coll is a newline,\n  then don't add any spaces after the newline that we prepend."],"^T","^4:","^6","zprint/zprint.cljc","^:",17,"^>[",["^2U",[["^>W","^?E","^?F"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",585,"^?4",["^S",["^??","^?O","^?I"]],"^9",585,"^?6",3,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[["^>W","^?E","^?F"]]]]],"^>Z","Given an indent ind and a style-vec coll, place a newline (actually an\n  indent) at the front of coll.  If the first thing in coll is a newline,\n  then don't add any spaces after the newline that we prepend."],"~$fzprint-up-to-next-zloc",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",2620,"^8",7,"^9",2620,"^:",30,"^>Q",["^2U",["^>R",["^2U",[["^?C","^>W","^?E",["~$_","~$_","~$current-count","^@3","^2X","~$next-data"]]]]]],"^>Z","Using the information returned from fzprint-up-to-first-zloc or\n  fzprint-up-to-next-zloc, find the next zloc and return \n  [pre-next-style-vec next-zloc next-count zloc-seq]"],"^T","^:P","^6","zprint/zprint.cljc","^:",30,"^>[",["^2U",[["^?C","^>W","^?E","~$p__45766"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",2620,"^?4","^?;","^9",2620,"^?6",4,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[["^?C","^>W","^?E",["~$_","~$_","^FN","^@3","^2X","^FO"]]]]]],"^>Z","Using the information returned from fzprint-up-to-first-zloc or\n  fzprint-up-to-next-zloc, find the next zloc and return \n  [pre-next-style-vec next-zloc next-count zloc-seq]"],"~$cleave-end",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",1428,"^8",7,"^9",1428,"^:",17,"^>Q",["^2U",["^>R",["^2U",[["^?F"]]]]],"^>Z","Take a seq, and if it is contains a single symbol, simply return\n  it in another seq.  If it contains something else, remove any non\n  collections off of the end and return them in their own double seqs,\n  as well as return the remainder (the beginning) as a double seq."],"^T","^3@","^6","zprint/zprint.cljc","^:",17,"^>[",["^2U",[["^?F"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",1428,"^?4","^??","^9",1428,"^?6",1,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[["^?F"]]]]],"^>Z","Take a seq, and if it is contains a single symbol, simply return\n  it in another seq.  If it contains something else, remove any non\n  collections off of the end and return them in their own double seqs,\n  as well as return the remainder (the beginning) as a double seq."],"~$object-str?",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",4725,"^8",7,"^9",4725,"^:",18,"^>Q",["^2U",["^>R",["^2U",[["~$s"]]]]],"^>Z","Return true if the string starts with #object["],"^T","^3>","^6","zprint/zprint.cljc","^:",18,"^>[",["^2U",[["~$s"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",4725,"^?4",["^S",["^??","^?;","^?O","^AO","^?I"]],"^9",4725,"^?6",1,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[["~$s"]]]]],"^>Z","Return true if the string starts with #object["],"~$fzprint-list*",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",3320,"^8",7,"^9",3320,"^:",20,"^>Q",["^2U",["^>R",["^2U",[["^?C","^A5","^A6",["^ ","^>S",["~$fn-map","~$user-fn-map","^A7","^>Y","~$no-arg1?","^>T"],"^2X","^>W"],"^?E","^?R"]]]]],"^>Z","Print a list, which might be a list or an anon fn.  \n  Lots of work to make a list look good, as that is typically code. \n  Presently all of the callers of this are :list or :vector-fn."],"^T","^:Y","^6","zprint/zprint.cljc","^:",20,"^>[",["^2U",[["^?C","^A5","^A6","~$p__45853","^?E","^?R"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",3320,"^?4",["^S",["^??","^?O","^?I"]],"^9",3320,"^?6",6,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[["^?C","^A5","^A6",["^ ","^>S",["^FT","^FU","^A7","^>Y","^FV","^>T"],"^2X","^>W"],"^?E","^?R"]]]]],"^>Z","Print a list, which might be a list or an anon fn.  \n  Lots of work to make a list look good, as that is typically code. \n  Presently all of the callers of this are :list or :vector-fn."],"~$hang-zloc?",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",2831,"^8",7,"^9",2831,"^:",17,"^>Q",["^2U",["^>R",["^2U",[["^?R"]]]]],"^>Z","Should we hang this zloc, or flow it.  We assume that we are at\n  the start of the collection (though this could be generalized to\n  deal with other starting locations easily enough).  Return true\n  if we should hang it based just on the information in the zloc\n  itself.  The criteria are: If there is a newline after the second\n  thing in the zloc, and the amount of space prior to the third thing\n  is the same as the amount of space prior to the second thing, then\n  the incoming zloc was hung and we should do the same. Of course, it\n  would also only be hung if the second thing was on the same line as\n  the first thing."],"^T","^4A","^6","zprint/zprint.cljc","^:",17,"^>[",["^2U",[["^?R"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",2831,"^?4",["^S",[null,"^?5","^?O","^?I"]],"^9",2831,"^?6",1,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[["^?R"]]]]],"^>Z","Should we hang this zloc, or flow it.  We assume that we are at\n  the start of the collection (though this could be generalized to\n  deal with other starting locations easily enough).  Return true\n  if we should hang it based just on the information in the zloc\n  itself.  The criteria are: If there is a newline after the second\n  thing in the zloc, and the amount of space prior to the third thing\n  is the same as the amount of space prior to the second thing, then\n  the incoming zloc was hung and we should do the same. Of course, it\n  would also only be hung if the second thing was on the same line as\n  the first thing."],"~$fzprint-reader-macro",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",4975,"^8",7,"^9",4975,"^:",27,"^>Q",["^2U",["^>R",["^2U",[["^>W","^?E","^?R"]]]]],"^>Z","Print a reader-macro, often a reader-conditional. Adapted for differences\n  in parsing #?@ between rewrite-clj and rewrite-cljs.  Also adapted for\n  the rewrite-clj not parsing namespaced maps in the version presently\n  used."],"^T","^4F","^6","zprint/zprint.cljc","^:",27,"^>[",["^2U",[["^>W","^?E","^?R"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",4975,"^?4",["^S",["^??","^?O","^?I"]],"^9",4975,"^?6",3,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[["^>W","^?E","^?R"]]]]],"^>Z","Print a reader-macro, often a reader-conditional. Adapted for differences\n  in parsing #?@ between rewrite-clj and rewrite-cljs.  Also adapted for\n  the rewrite-clj not parsing namespaced maps in the version presently\n  used."],"~$ensure-start-w-nl",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",2099,"^8",7,"^9",2099,"^:",24,"^>Q",["^2U",["^>R",["^2U",[["^?E","^?:"]]]]],"^>Z","Given a style-vec, ensure it starts with a newline.  If it doesn't,\n  then put one in.  We could take the whole newline, but the indent is\n  really the only unique thing."],"^T","^4I","^6","zprint/zprint.cljc","^:",24,"^>[",["^2U",[["^?E","^?:"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",2099,"^?4",["^S",[null,"^??","^?O","^?I"]],"^9",2099,"^?6",2,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[["^?E","^?:"]]]]],"^>Z","Given a style-vec, ensure it starts with a newline.  If it doesn't,\n  then put one in.  We could take the whole newline, but the indent is\n  really the only unique thing."],"~$line-lengths",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",523,"^8",7,"^9",523,"^:",19,"^>Q",["^2U",["^>R",["^2U",[["^>W","^?E","^?:"]]]]],"^>Z","Take a style-vec, and output a sequence of numbers, one for each\n  line, which contains the actual length. Must take the current\n  indent to have a prayer of getting this right, but it is used\n  only for the first line.  The ind can be an integer or a seq of\n  integers, in which case only the first integer is used. Newlines\n  can come anywhere in an element in a style-vec, it will account\n  for both sides.  Will break lines on comments even if no newlines\n  in them.  This doesn't count the length of comment lines unless\n  [:comment :count?] is true, so that we don't format based on\n  comment size -- that is handled with the wrap-comments at the\n  end. Note that only vectors with :whitespace or :indent are scanned\n  for newlines, and if consecutive newlines appear, only the first\n  is counted as a newline -- the second is counted as a regular \n  character."],"^T","^4[","^6","zprint/zprint.cljc","^:",19,"^>[",["^2U",[["^>W","^?E","^?:"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",523,"^?4",["^S",["^?O","^?I"]],"^9",523,"^?6",3,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[["^>W","^?E","^?:"]]]]],"^>Z","Take a style-vec, and output a sequence of numbers, one for each\n  line, which contains the actual length. Must take the current\n  indent to have a prayer of getting this right, but it is used\n  only for the first line.  The ind can be an integer or a seq of\n  integers, in which case only the first integer is used. Newlines\n  can come anywhere in an element in a style-vec, it will account\n  for both sides.  Will break lines on comments even if no newlines\n  in them.  This doesn't count the length of comment lines unless\n  [:comment :count?] is true, so that we don't format based on\n  comment size -- that is handled with the wrap-comments at the\n  end. Note that only vectors with :whitespace or :indent are scanned\n  for newlines, and if consecutive newlines appear, only the first\n  is counted as a newline -- the second is counted as a regular \n  character."],"~$merge-fzprint-seq",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",3100,"^8",7,"^9",3100,"^:",24,"^>Q",["^2U",["^>R",["^2U",[["~$fzprint-seq-vec"]]]]],"^>Z","Given the output from fzprint-seq, which is a seq of the\n  output of fzprint*, apply a function to each of them that has\n  more than one element (since less has no meaning) and when the\n  function returns true, merge the vector in as individual elements."],"^T","^61","^6","zprint/zprint.cljc","^:",24,"^>[",["^2U",[["^G1"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",3100,"^?4",["^S",[null,"^??","^?O"]],"^9",3100,"^?6",1,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[["^G1"]]]]],"^>Z","Given the output from fzprint-seq, which is a seq of the\n  output of fzprint*, apply a function to each of them that has\n  more than one element (since less has no meaning) and when the\n  function returns true, merge the vector in as individual elements."],"~$max-width",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",5860,"^8",7,"^9",5860,"^:",16,"^>Q",["^2U",["^>R",["^2U",[["~$s"]]]]],"^>Z","Split a string into lines, and figure the max width."],"^T","^5U","^6","zprint/zprint.cljc","^:",16,"^>[",["^2U",[["~$s"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",5860,"^?4","^?O","^9",5860,"^?6",1,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[["~$s"]]]]],"^>Z","Split a string into lines, and figure the max width."],"~$fzprint-binding-vec",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",1560,"^8",7,"^9",1560,"^:",26,"^>Q",["^2U",["^>R",["^2U",[[["^;J",[["^ ","^>S",["^?["]],"~:binding","^2X","^>W"]],"^?E","^?R"]]]]]],"^T","^4O","^6","zprint/zprint.cljc","^:",26,"^>[",["^2U",[["~$p__45609","^?E","^?R"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",1560,"^?4",["^S",["^??","^?O","^?I"]],"^9",1560,"^?6",3,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[[["^;J",[["^ ","^>S",["^?["]],"^G4","^2X","^>W"]],"^?E","^?R"]]]]]],"~$fn-style->caller",["^ ","^T","^3V","^6","zprint/zprint.cljc","^7",3251,"^8",1,"^9",3251,"^:",22,"^5",["^ ","^6","zprint/zprint.cljc","^7",3251,"^8",6,"^9",3251,"^:",22],"^>M","^?A"],"~$fzprint-vec",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",4265,"^8",7,"^9",4265,"^:",18,"^>Q",["^2U",["^>R",["^2U",[["^>W","^?E","^?R"]]]]]],"^T","^5[","^6","zprint/zprint.cljc","^:",18,"^>[",["^2U",[["^>W","^?E","^?R"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",4265,"^?4",["^S",["^??","^?O","^?I"]],"^9",4265,"^?6",3,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[["^>W","^?E","^?R"]]]]]],"~$at-newline?",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",2705,"^8",7,"^9",2705,"^:",18,"^>Q",["^2U",["^>R",["^2U",[["^?R"]]]]],"^>Z","Is this a newline or equivalent?  Comments and newlines are both\n  newlines for the purposed of this routine."],"^T","^4V","^6","zprint/zprint.cljc","^:",18,"^>[",["^2U",[["^?R"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",2705,"^?4","^?5","^9",2705,"^?6",1,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[["^?R"]]]]],"^>Z","Is this a newline or equivalent?  Comments and newlines are both\n  newlines for the purposed of this routine."],"~$trimr-blanks-style-vec",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",4425,"^8",7,"^9",4425,"^:",29,"^>Q",["^2U",["^>R",["^2U",[["^?:"]]]]],"^>Z","Given a style-vec, trim the blanks out of each element."],"^T","^47","^6","zprint/zprint.cljc","^:",29,"^>[",["^2U",[["^?:"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",4425,"^?4","^??","^9",4425,"^?6",1,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[["^?:"]]]]],"^>Z","Given a style-vec, trim the blanks out of each element."],"~$indent-zmap",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",2919,"^8",7,"^9",2919,"^:",18,"^>Q",["^2U",["^>R",["^2U",[["^?C",["^;J",["^>S",["^?=","^BW"],["^ ","^>S",["^D<"]],"^?C","^2X","^>W"]],"^?E","~$actual-ind","^D=","^AA","^BU"],["^?C","^>W","^?E","^G;","^D=","^AA"]]]]],"^>Z","Implement :indent-only?.  This routine is the central one through\n  which all :indent-only? processing flows, and replaces all of the\n  detailed logic in fzprint-list*, fzprint-vec*, and fzprint-map*.\n  This is called directly by fzprint-vec*, which handles both vectors\n  and sets, and through fzprint-indent by fzprint-list* and\n  fzprint-map*.  Thus, all of the data structures get their\n  :indent-only? processing handled by ident-zmap.  coll-print is\n  the output from fzprint-seq, which is a style-vec in the making\n  without spacing, but with extra [] around the elements.  Everything\n  is based off of ind, and we know nothing to the left of that.\n  ind must be the left end of everything, not the right of l-str!\n  The actual-ind is to the right of l-str.  When we get a newline,\n  replace any spaces after it with our own, and that would be to\n  bring it to ind + indent.  ","^?L",["^ ","^?3",false,"^?M",7,"^?6",7,"^>[",[["^?C",["^;J",["^>S",["^?=","^BW"],["^ ","^>S",["^D<"]],"^?C","^2X","^>W"]],"^?E","^G;","^D=","^AA","^BU"],["^?C","^>W","^?E","^G;","^D=","^AA"]],"^>Q",["^2U",[["^?C",["^;J",["^>S",["^?=","^BW"],["^ ","^>S",["^D<"]],"^?C","^2X","^>W"]],"^?E","^G;","^D=","^AA","^BU"],["^?C","^>W","^?E","^G;","^D=","^AA"]]],"^?2",["^2U",[null,null]]]],"^T","^40","^6","zprint/zprint.cljc","^:",18,"^?L",["^ ","^?3",false,"^?M",7,"^?6",7,"^>[",[["^?C",["^;J",["^>S",["^?=","^BW"],["^ ","^>S",["^D<"]],"^?C","^2X","^>W"]],"^?E","^G;","^D=","^AA","^BU"],["^?C","^>W","^?E","^G;","^D=","^AA"]],"^>Q",["^2U",[["^?C",["^;J",["^>S",["^?=","^BW"],["^ ","^>S",["^D<"]],"^?C","^2X","^>W"]],"^?E","^G;","^D=","^AA","^BU"],["^?C","^>W","^?E","^G;","^D=","^AA"]]],"^?2",["^2U",[null,null]]],"^>[",[["^?C",["^;J",["^>S",["^?=","^BW"],["^ ","^>S",["^D<"]],"^?C","^2X","^>W"]],"^?E","^G;","^D=","^AA","^BU"],["^?C","^>W","^?E","^G;","^D=","^AA"]],"^?1",null,"^?M",7,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^?N",[["^ ","^?M",7,"^?3",false,"^>M",["^S",["^??","^?;","^?I"]]],["^ ","^?M",6,"^?3",false,"^>M",["^S",["^??","^?;","^?I"]]]],"^7",2919,"^9",2919,"^?6",7,"^?7",true,"^>Q",["^2U",[["^?C",["^;J",["^>S",["^?=","^BW"],["^ ","^>S",["^D<"]],"^?C","^2X","^>W"]],"^?E","^G;","^D=","^AA","^BU"],["^?C","^>W","^?E","^G;","^D=","^AA"]]],"^>Z","Implement :indent-only?.  This routine is the central one through\n  which all :indent-only? processing flows, and replaces all of the\n  detailed logic in fzprint-list*, fzprint-vec*, and fzprint-map*.\n  This is called directly by fzprint-vec*, which handles both vectors\n  and sets, and through fzprint-indent by fzprint-list* and\n  fzprint-map*.  Thus, all of the data structures get their\n  :indent-only? processing handled by ident-zmap.  coll-print is\n  the output from fzprint-seq, which is a style-vec in the making\n  without spacing, but with extra [] around the elements.  Everything\n  is based off of ind, and we know nothing to the left of that.\n  ind must be the left end of everything, not the right of l-str!\n  The actual-ind is to the right of l-str.  When we get a newline,\n  replace any spaces after it with our own, and that would be to\n  bring it to ind + indent.  "],"~$style-loc-vec",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",5470,"^8",7,"^9",5470,"^:",20,"^>Q",["^2U",["^>R",["^2U",[["^AA","^?:"]]]]],"^>Z","Take a style-vec and produce a style-loc-vec with the starting column\n  of each element in the style-vec. Accepts a beginning indent."],"^T","^3[","^6","zprint/zprint.cljc","^:",20,"^>[",["^2U",[["^AA","^?:"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",5470,"^?4","^F?","^9",5470,"^?6",2,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[["^AA","^?:"]]]]],"^>Z","Take a style-vec and produce a style-loc-vec with the starting column\n  of each element in the style-vec. Accepts a beginning indent."],"~$remove-key-seq",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",1299,"^8",7,"^9",1299,"^:",21,"^>Q",["^2U",["^>R",["^2U",[["~$m","~$ks"]]]]],"^>Z","If given a non-collection, simply does a dissoc of the key, but\n  if given a sequence of keys, will remove the final one."],"^T","^54","^6","zprint/zprint.cljc","^:",21,"^>[",["^2U",[["~$m","^G>"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",1299,"^?4",["^S",["^??","^?O","^?I"]],"^9",1299,"^?6",2,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[["~$m","^G>"]]]]],"^>Z","If given a non-collection, simply does a dissoc of the key, but\n  if given a sequence of keys, will remove the final one."],"~$hangflow",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",713,"^8",7,"^9",713,"^:",15,"^>Q",["^2U",["^>R",["^2U",[["~$hangflow?","~$hang-or-flow","^?:"]]]]],"^>Z","Take a style-vec, and if hangflow? is true, return a\n  vector [hang-or-flow style-vec], else return style-vec.\n  But a nil style-vec returns nil."],"^T","^4@","^6","zprint/zprint.cljc","^:",15,"^>[",["^2U",[["^G@","^GA","^?:"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",713,"^?4",["^S",[null,"^?;","^?I"]],"^9",713,"^?6",3,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[["^G@","^GA","^?:"]]]]],"^>Z","Take a style-vec, and if hangflow? is true, return a\n  vector [hang-or-flow style-vec], else return style-vec.\n  But a nil style-vec returns nil."],"~$fzprint-record",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",4904,"^8",7,"^9",4904,"^:",21,"^>Q",["^2U",["^>R",["^2U",[[["^;J",[["^ ","^>S",["~$record-type?","~$to-string?"]],"^C>","^2X","^>W"]],"^?E","^?R"]]]]]],"^T","^4J","^6","zprint/zprint.cljc","^:",21,"^>[",["^2U",[["~$p__46066","^?E","^?R"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",4904,"^?4",["^S",["^??","^?O","^?I"]],"^9",4904,"^?6",3,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[[["^;J",[["^ ","^>S",["^GC","^GD"]],"^C>","^2X","^>W"]],"^?E","^?R"]]]]]],"~$first-actual",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",2825,"^8",7,"^9",2825,"^:",19,"^>Q",["^2U",["^>R",["^2U",[["^?R"]]]]],"^>Z","Return the first actual element, ignoring comments and whitespace\n  and everything else but real elements."],"^T","^4E","^6","zprint/zprint.cljc","^:",19,"^>[",["^2U",[["^?R"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",2825,"^?4",["^S",[null,"^?O","^?I"]],"^9",2825,"^?6",1,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[["^?R"]]]]],"^>Z","Return the first actual element, ignoring comments and whitespace\n  and everything else but real elements."],"~$modify-zloc",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",3293,"^8",7,"^9",3293,"^:",18,"^>Q",["^2U",["^>R",["^2U",[["^?C","^>W","^?R"]]]]],"^>Z","If the (caller options) has a value for :return-altered-zipper, then\n  examine the value.  It should be [<depth> <symbol> <fn>]. \n  If the <depth> is nil, any depth will do. If the\n  <symbol> is nil, any symbol will do.  If the <depth> and <symbol>\n  match, then the <fn> is called as (fn caller options zloc), and must\n  return a new zloc."],"^T","^5I","^6","zprint/zprint.cljc","^:",18,"^>[",["^2U",[["^?C","^>W","^?R"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",3293,"^?4",["^S",[null,"^?O"]],"^9",3293,"^?6",3,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[["^?C","^>W","^?R"]]]]],"^>Z","If the (caller options) has a value for :return-altered-zipper, then\n  examine the value.  It should be [<depth> <symbol> <fn>]. \n  If the <depth> is nil, any depth will do. If the\n  <symbol> is nil, any symbol will do.  If the <depth> and <symbol>\n  match, then the <fn> is called as (fn caller options zloc), and must\n  return a new zloc."],"~$fzprint-one-line",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",1713,"^8",7,"^9",1713,"^:",23,"^>Q",["^2U",["^>R",["^2U",[["^>W","^?E","^@3"]]]]],"^>Z","Do a fzprint-seq like thing, but do it incrementally and\n  if it gets too big, return nil."],"^T","^5J","^6","zprint/zprint.cljc","^:",23,"^>[",["^2U",[["^>W","^?E","^@3"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",1713,"^?4",["^S",["^??","^?I"]],"^9",1713,"^?6",3,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[["^>W","^?E","^@3"]]]]],"^>Z","Do a fzprint-seq like thing, but do it incrementally and\n  if it gets too big, return nil."],"~$fzfit",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",619,"^8",7,"^9",619,"^:",12,"^>Q",["^2U",["^>R",["^2U",[[["^ ","^>S",["^?=","^BW","^?T"],"^2X","^>W"],["^@L","^G2","^2X","^@G"]]]]]],"^>Z","Given output from style-lines and options, see if it fits the width.  \n  Return the number of lines it takes if it fits, nil otherwise."],"^T","^3Q","^6","zprint/zprint.cljc","^:",12,"^>[",["^2U",[["~$p__45408","~$p__45409"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",619,"^?4",["^S",[null,"^?O","^?I"]],"^9",619,"^?6",2,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[[["^ ","^>S",["^?=","^BW","^?T"],"^2X","^>W"],["^@L","^G2","^2X","^@G"]]]]]],"^>Z","Given output from style-lines and options, see if it fits the width.  \n  Return the number of lines it takes if it fits, nil otherwise."],"~$fzprint-meta",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",4938,"^8",7,"^9",4938,"^:",19,"^>Q",["^2U",["^>R",["^2U",[["^>W","^?E","^?R"]]]]],"^>Z","Print the two items in a meta node.  Different because it doesn't print\n  a single collection, so it doesn't do any indent or rightmost.  It also\n  uses a different approach to calling fzprint-flow-seq with the\n  results zmap, so that it prints all of the seq, not just the rightmost."],"^T","^4C","^6","zprint/zprint.cljc","^:",19,"^>[",["^2U",[["^>W","^?E","^?R"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",4938,"^?4",["^S",["^??","^?O","^?I"]],"^9",4938,"^?6",3,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[["^>W","^?E","^?R"]]]]],"^>Z","Print the two items in a meta node.  Different because it doesn't print\n  a single collection, so it doesn't do any indent or rightmost.  It also\n  uses a different approach to calling fzprint-flow-seq with the\n  results zmap, so that it prints all of the seq, not just the rightmost."],"~$flow-indent",["^ ","^T","^4K","^6","zprint/zprint.cljc","^7",3085,"^8",1,"^9",3085,"^:",17,"^5",["^ ","^6","zprint/zprint.cljc","^7",3085,"^8",6,"^9",3085,"^:",17],"^>M","^>N"],"~$count-newline-types",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",4369,"^8",7,"^9",4369,"^:",26,"^>Q",["^2U",["^>R",["^2U",[["~$newline-style-vec"]]]]],"^>Z","Analyze a style-vec which contains only newlines, the count of newlines\n  in the style vec.  We assume that each :newline style-vec contains one\n  newline (i.e., it was generated by fzprint-newlines)."],"^T","^3K","^6","zprint/zprint.cljc","^:",26,"^>[",["^2U",[["^GO"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",4369,"^?4","^?H","^9",4369,"^?6",1,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[["^GO"]]]]],"^>Z","Analyze a style-vec which contains only newlines, the count of newlines\n  in the style vec.  We assume that each :newline style-vec contains one\n  newline (i.e., it was generated by fzprint-newlines)."],"~$find-consecutive-inline-comments",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",5667,"^8",7,"^9",5667,"^:",39,"^>Q",["^2U",["^>R",["^2U",[["^?:"]]]]],"^>Z","Given a style-vec, find consecutive inline comments and output\n  the as a sequence of vectors of comments.  Each comment itself\n  is a vector: [indent-index inline-comment-index], yielding a\n  [[[indent-index inline-comment-index] [indent-index inline-comment-index]\n  ...] ...]"],"^T","^3L","^6","zprint/zprint.cljc","^:",39,"^>[",["^2U",[["^?:"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",5667,"^?4","^?O","^9",5667,"^?6",1,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[["^?:"]]]]],"^>Z","Given a style-vec, find consecutive inline comments and output\n  the as a sequence of vectors of comments.  Each comment itself\n  is a vector: [indent-index inline-comment-index], yielding a\n  [[[indent-index inline-comment-index] [indent-index inline-comment-index]\n  ...] ...]"],"~$fzprint-dbg",["^ ","^T","^3M","^6","zprint/zprint.cljc","^7",97,"^8",1,"^9",97,"^:",17,"^5",["^ ","^6","zprint/zprint.cljc","^7",97,"^8",6,"^9",97,"^:",17],"^>M","~$cljs.core/Atom"],"~$next-non-comment-nl",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",4447,"^8",7,"^9",4447,"^:",26,"^>Q",["^2U",["^>R",["^2U",[["^?F"]]]]],"^>Z","Given a coll of [hangflow style-vec] pairs, return the \n  [hangflow style-vec] pair where the style-vec is not a \n  :comment, :comment-inline, :newline or :indent."],"^T","^4G","^6","zprint/zprint.cljc","^:",26,"^>[",["^2U",[["^?F"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",4447,"^?4",["^S",["^?O","^?I"]],"^9",4447,"^?6",1,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[["^?F"]]]]],"^>Z","Given a coll of [hangflow style-vec] pairs, return the \n  [hangflow style-vec] pair where the style-vec is not a \n  :comment, :comment-inline, :newline or :indent."],"~$any-zcoll?",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",3975,"^8",7,"^9",3975,"^:",17,"^>Q",["^2U",["^>R",["^2U",[["^>W","^?E","^?R"]]]]],"^>Z","Return true if there are any collections in the collection."],"^T","^5Z","^6","zprint/zprint.cljc","^:",17,"^>[",["^2U",[["^>W","^?E","^?R"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",3975,"^?4",["^S",[null,"^?O"]],"^9",3975,"^?6",3,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[["^>W","^?E","^?R"]]]]],"^>Z","Return true if there are any collections in the collection."],"~$ensure-end-w-nl",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",2114,"^8",7,"^9",2114,"^:",22,"^>Q",["^2U",["^>R",["^2U",[["^?E","^?:"]]]]],"^>Z","Given a style-vec, ensure it ends with a newline.  If it doesn't,\n  then put one in."],"^T","^5X","^6","zprint/zprint.cljc","^:",22,"^>[",["^2U",[["^?E","^?:"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",2114,"^?4",["^S",[null,"^??","^?O","^?I"]],"^9",2114,"^?6",2,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[["^?E","^?:"]]]]],"^>Z","Given a style-vec, ensure it ends with a newline.  If it doesn't,\n  then put one in."],"~$fzprint-newline",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",5079,"^8",7,"^9",5079,"^:",22,"^>Q",["^2U",["^>R",["^2U",[["^>W","^?E","^?R"]]]]],"^>Z","Given an element which contains newlines, split it up into individual\n  newline elements."],"^T","^5V","^6","zprint/zprint.cljc","^:",22,"^>[",["^2U",[["^>W","^?E","^?R"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",5079,"^?4",["^S",[null,"^??","^?O"]],"^9",5079,"^?6",3,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[["^>W","^?E","^?R"]]]]],"^>Z","Given an element which contains newlines, split it up into individual\n  newline elements."],"~$contains-nil?",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",276,"^8",7,"^9",276,"^:",20,"^>Q",["^2U",["^>R",["^2U",[["^?F"]]]]],"^>Z","Scan a collection, and return true if it contains any nils or empty\n  collections."],"^T","^6W","^6","zprint/zprint.cljc","^:",20,"^>[",["^2U",[["^?F"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",276,"^?4",["^S",["^?O","^?I"]],"^9",276,"^?6",1,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[["^?F"]]]]],"^>Z","Scan a collection, and return true if it contains any nils or empty\n  collections."],"~$fzprint-align-inline-comments",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",5805,"^8",7,"^9",5805,"^:",36,"^>Q",["^2U",["^>R",["^2U",[["^>W","^?:"]]]]],"^>Z","Given the current style-vec, align all consecutive inline comments."],"^T","^74","^6","zprint/zprint.cljc","^:",36,"^>[",["^2U",[["^>W","^?:"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",5805,"^?4",["^S",[null,"^?O"]],"^9",5805,"^?6",2,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[["^>W","^?:"]]]]],"^>Z","Given the current style-vec, align all consecutive inline comments."],"~$remove-one",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",364,"^8",7,"^9",364,"^:",17,"^>Q",["^2U",["^>R",["^2U",[["~$s","~$index"]]]]],"^>Z","Remove a single thing from a sequence."],"^T","^65","^6","zprint/zprint.cljc","^:",17,"^>[",["^2U",[["~$s","^GZ"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",364,"^?4","^5R","^9",364,"^?6",2,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[["~$s","^GZ"]]]]],"^>Z","Remove a single thing from a sequence."],"~$align-comment-vec",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",5796,"^8",7,"^9",5796,"^:",24,"^>Q",["^2U",["^>R",["^2U",[["^?:","^BQ"]]]]],"^>Z","Given one set of inline comments: \n  [[inline-comment-index start-column spaces-before]\n   [inline-comment-index start-column spaces-before] ...], align them \n   as best as possible, and return the modified style-vec."],"^T","^68","^6","zprint/zprint.cljc","^:",24,"^>[",["^2U",[["^?:","^BQ"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",5796,"^?4",["^S",[null,"^?O"]],"^9",5796,"^?6",2,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[["^?:","^BQ"]]]]],"^>Z","Given one set of inline comments: \n  [[inline-comment-index start-column spaces-before]\n   [inline-comment-index start-column spaces-before] ...], align them \n   as best as possible, and return the modified style-vec."],"~$showfn?",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",115,"^8",7,"^9",115,"^:",14,"^>Q",["^2U",["^>R",["^2U",[["^FT","~$f"]]]]],"^>Z","Show this thing as a function?"],"^T","^5:","^6","zprint/zprint.cljc","^:",14,"^>[",["^2U",[["^FT","~$f"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",115,"^?4",["^S",[null,"^?O","^?I"]],"^9",115,"^?6",2,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[["^FT","~$f"]]]]],"^>Z","Show this thing as a function?"],"~$map->r",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^:",13,"^8",12,"^C=",true,"~:factory","~:map","^7",5898,"^9",5898,"^>Q",["^2U",["^>R",["^2U",[["~$G__46168"]]]]],"^>Z","Factory function for zprint.zprint/r, taking a map of keywords to field values."],"^T","^67","^6","zprint/zprint.cljc","^:",13,"^>[",["^2U",[["^H4"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^C=",true,"^?3",false,"^H2","^H3","^7",5898,"^?4","^;G","^9",5898,"^?6",1,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[["^H4"]]]]],"^>Z","Factory function for zprint.zprint/r, taking a map of keywords to field values."],"~$generate-ll",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",429,"^8",7,"^9",429,"^:",18,"^>Q",["^2U",["^>R",["^2U",[["^EM",["^AL","^EN","^EO","^EP","^2X","^EQ"],["~$s","~$_","^ER","^2X","^@K"]]]]]]],"^T","^76","^6","zprint/zprint.cljc","^:",18,"^>[",["^2U",[["^EM","~$p__45354","~$p__45355"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",429,"^?4","^?;","^9",429,"^?6",3,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[["^EM",["^AL","^EN","^EO","^EP","^2X","^EQ"],["~$s","~$_","^ER","^2X","^@K"]]]]]]],"~$->r",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^:",13,"^8",12,"^C=",true,"^H2","~:positional","^7",5898,"^9",5898,"^>Q",["^2U",["^>R",["^2U",[["~$left","~$right"]]]]],"^>Z","Positional factory function for zprint.zprint/r."],"^T","^6Y","^6","zprint/zprint.cljc","^:",13,"^>[",["^2U",[["^H:","^H;"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^C=",true,"^?3",false,"^H2","^H9","^7",5898,"^?4","^;G","^9",5898,"^?6",2,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[["^H:","^H;"]]]]],"^>Z","Positional factory function for zprint.zprint/r."],"~$ignore-key-seq",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",1325,"^8",7,"^9",1325,"^:",21,"^>Q",["^2U",["^>R",["^2U",[["~$m","^G>"]]]]],"^>Z","Given a map and a key sequence, remove that key sequence if\n  it appears in the map leaving behind a key :zprint-ignored, \n  and terminate the reduce if it changes the map."],"^T","^63","^6","zprint/zprint.cljc","^:",21,"^>[",["^2U",[["~$m","^G>"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",1325,"^?4",["^S",[null,"^??","^?O"]],"^9",1325,"^?6",2,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[["~$m","^G>"]]]]],"^>Z","Given a map and a key sequence, remove that key sequence if\n  it appears in the map leaving behind a key :zprint-ignored, \n  and terminate the reduce if it changes the map."],"~$fzprint",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",5823,"^8",7,"^9",5823,"^:",14,"^>Q",["^2U",["^>R",["^2U",[["^>W","^AA","^?R"]]]]],"^>Z","The pretty print part of fzprint."],"^T","^6?","^6","zprint/zprint.cljc","^:",14,"^>[",["^2U",[["^>W","^AA","^?R"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",5823,"^?4",["^S",[null,"^??","^?;","^?O","^?I"]],"^9",5823,"^?6",3,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[["^>W","^AA","^?R"]]]]],"^>Z","The pretty print part of fzprint."],"~$internal-validate",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",4095,"^8",7,"^9",4095,"^:",24,"^>Q",["^2U",["^>R",["^2U",[["^>W","~$error-str"]]]]],"^>Z","Validate an options map that was returned from some internal configuration\n  expression or configuration.  Either returns the options map or throws\n  an error."],"^T","^6@","^6","zprint/zprint.cljc","^:",24,"^>[",["^2U",[["^>W","^H?"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",4095,"^9",4095,"^?6",2,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[["^>W","^H?"]]]]],"^>Z","Validate an options map that was returned from some internal configuration\n  expression or configuration.  Either returns the options map or throws\n  an error."],"~$line-lengths-iter",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",447,"^8",7,"^9",447,"^:",24,"^>Q",["^2U",["^>R",["^2U",[["^>W","^?E","^?:"]]]]],"^>Z","Take a style-vec, and output a sequence of numbers, one for each\n  line, which contains the actual length. Must take the current\n  indent to have a prayer of getting this right, but it is used\n  only for the first line.  The ind can be an integer or a seq of\n  integers, in which case only the first integer is used. Newlines\n  can come anywhere in an element in a style-vec, it will account\n  for both sides.  Will break lines on comments even if no newlines\n  in them.  This doesn't count the length of comment lines unless\n  [:comment :count?] is true, so that we don't format based on\n  comment size -- that is handled with the wrap-comments elsewhere.\n  Note that only vectors with :whitespace, :indent, or :newline are scanned\n  for newlines, and if consecutive newlines appear, only the first\n  is counted as a newline -- the second is counted as a regular \n  character. A single comment is counted as two lines. Lots of edge\n  conditions that are really quite important."],"^T","^4?","^6","zprint/zprint.cljc","^:",24,"^>[",["^2U",[["^>W","^?E","^?:"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",447,"^?4",["^S",["^??","^?;"]],"^9",447,"^?6",3,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[["^>W","^?E","^?:"]]]]],"^>Z","Take a style-vec, and output a sequence of numbers, one for each\n  line, which contains the actual length. Must take the current\n  indent to have a prayer of getting this right, but it is used\n  only for the first line.  The ind can be an integer or a seq of\n  integers, in which case only the first integer is used. Newlines\n  can come anywhere in an element in a style-vec, it will account\n  for both sides.  Will break lines on comments even if no newlines\n  in them.  This doesn't count the length of comment lines unless\n  [:comment :count?] is true, so that we don't format based on\n  comment size -- that is handled with the wrap-comments elsewhere.\n  Note that only vectors with :whitespace, :indent, or :newline are scanned\n  for newlines, and if consecutive newlines appear, only the first\n  is counted as a newline -- the second is counted as a regular \n  character. A single comment is counted as two lines. Lots of edge\n  conditions that are really quite important."],"~$left-or-up",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",2760,"^8",7,"^9",2760,"^:",17,"^>Q",["^2U",["^>R",["^2U",[["^?R"]]]]],"^>Z","Take a zloc and move left if possible, or move up if necessary.\n  Return a vector with [up-size new-zloc]"],"^T","^49","^6","zprint/zprint.cljc","^:",17,"^>[",["^2U",[["^?R"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",2760,"^?4","^?;","^9",2760,"^?6",1,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[["^?R"]]]]],"^>Z","Take a zloc and move left if possible, or move up if necessary.\n  Return a vector with [up-size new-zloc]"],"~$count-constant-pairs",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",2005,"^8",7,"^9",2005,"^:",27,"^>Q",["^2U",["^>R",["^2U",[["^@3"]]]]],"^>Z","Given a seq of zlocs, work backwards from the end, and see how\n  many elements are pairs of constants (using zconstant?).  So that\n  (... :a (stuff) :b (bother)) returns 4, since both :a and :b are\n  zconstant? true. This is made more difficult by having to skip\n  comments along the way as part of the pair check, but keep track\n  of the ones we skip so the count is right in the end.  We don't\n  expect any spaces in this but newlines must be handled, because \n  this seq should have been produced by zmap or its equivalent.\n  Returns two things: [paired-item-count actual-paired-items],\n  where paired-item-count is the number of things from the end of\n  the seq you have to trim off to get the constant pairs included,\n  and the actual-paired-items is the count of the items to be checked\n  against the constant-pair-min (which is exclusive of comments and\n  newlines)."],"^T","^4;","^6","zprint/zprint.cljc","^:",27,"^>[",["^2U",[["^@3"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",2005,"^?4","^?;","^9",2005,"^?6",1,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[["^@3"]]]]],"^>Z","Given a seq of zlocs, work backwards from the end, and see how\n  many elements are pairs of constants (using zconstant?).  So that\n  (... :a (stuff) :b (bother)) returns 4, since both :a and :b are\n  zconstant? true. This is made more difficult by having to skip\n  comments along the way as part of the pair check, but keep track\n  of the ones we skip so the count is right in the end.  We don't\n  expect any spaces in this but newlines must be handled, because \n  this seq should have been produced by zmap or its equivalent.\n  Returns two things: [paired-item-count actual-paired-items],\n  where paired-item-count is the number of things from the end of\n  the seq you have to trim off to get the constant pairs included,\n  and the actual-paired-items is the count of the items to be checked\n  against the constant-pair-min (which is exclusive of comments and\n  newlines)."],"~$force-vector",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",369,"^8",7,"^9",369,"^:",19,"^>Q",["^2U",["^>R",["^2U",[["^?F"]]]]],"^>Z","Ensure that whatever we have is a vector."],"^T","^5Q","^6","zprint/zprint.cljc","^:",19,"^>[",["^2U",[["^?F"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",369,"^?4",["^S",[null,"^??","^?O"]],"^9",369,"^?6",1,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[["^?F"]]]]],"^>Z","Ensure that whatever we have is a vector."],"~$compare-ordered-keys",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",1251,"^8",7,"^9",1251,"^:",27,"^>Q",["^2U",["^>R",["^2U",[["^AJ","^1U","~$x","~$y"]]]]],"^>Z","Do a key comparison that places ordered keys first."],"^T","^5G","^6","zprint/zprint.cljc","^:",27,"^>[",["^2U",[["^AJ","^1U","~$x","~$y"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",1251,"^?4","^?H","^9",1251,"^?6",4,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[["^AJ","^1U","~$x","~$y"]]]]],"^>Z","Do a key comparison that places ordered keys first."],"~$inlinecomment?",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",5329,"^8",7,"^9",5329,"^:",21,"^>Q",["^2U",["^>R",["^2U",[["^?R"]]]]],"^>Z","If this is an inline comment, returns a vector with the amount\n  of space that was between this and the previous element and the\n  starting column of this inline comment.  That means that if we\n  go left, we get something other than whitespace before a newline.\n  If we get only whitespace before a newline, then this is considered\n  an inline comment if the comment at the end of the previous line\n  was an inline comment and we were aligned with that comment.\n  Assumes zloc is a comment."],"^T","^4B","^6","zprint/zprint.cljc","^:",21,"^>[",["^2U",[["^?R"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",5329,"^?4",["^S",["^?;","^?I"]],"^9",5329,"^?6",1,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[["^?R"]]]]],"^>Z","If this is an inline comment, returns a vector with the amount\n  of space that was between this and the previous element and the\n  starting column of this inline comment.  That means that if we\n  go left, we get something other than whitespace before a newline.\n  If we get only whitespace before a newline, then this is considered\n  an inline comment if the comment at the end of the previous line\n  was an inline comment and we were aligned with that comment.\n  Assumes zloc is a comment."],"~$trimr-blanks",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",4396,"^8",7,"^9",4396,"^:",19,"^>Q",["^2U",["^>R",["^2U",[["~$s"]]]]],"^>Z","Trim only blanks off the right end of a string."],"^T","^4D","^6","zprint/zprint.cljc","^:",19,"^>[",["^2U",[["~$s"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",4396,"^?4","^E?","^9",4396,"^?6",1,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[["~$s"]]]]],"^>Z","Trim only blanks off the right end of a string."],"~$show-user-fn?",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",136,"^8",7,"^9",136,"^:",20,"^>Q",["^2U",["^>R",["^2U",[["^>W","~$f"]]]]],"^>Z","Show this thing as a user defined function?  Assumes that we\n  have already handled any clojure defined functions!"],"^T","^6V","^6","zprint/zprint.cljc","^:",20,"^>[",["^2U",[["^>W","~$f"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",136,"^?4",["^S",[null,"^?O","^?I"]],"^9",136,"^?6",2,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[["^>W","~$f"]]]]],"^>Z","Show this thing as a user defined function?  Assumes that we\n  have already handled any clojure defined functions!"],"~$concat-no-nil",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",310,"^8",7,"^9",310,"^:",20,"^>Q",["^2U",["^>R",["^2U",[["~$&","^@9"]]]]],"^>Z","Concatentate multiple sequences, but if any of them are nil or empty\n  collections, return nil. If any of them are :noseq, just skip them.\n  When complete, check the last element-- if it is a :right, and if it\n  the previous element is a :newline or :indent, then ensure that the\n  number of spaces in that previous element matches the number to the\n  right of the :right.","^?L",["^ ","^?3",true,"^?M",0,"^?6",0,"^>[",[["^2U",["^@9"]]],"^>Q",["^2U",[["~$&","^@9"]]],"^?2",["^2U",[null]]]],"^T","^7Q","^6","zprint/zprint.cljc","^:",20,"^?L",["^ ","^?3",true,"^?M",0,"^?6",0,"^>[",[["^2U",["^@9"]]],"^>Q",["^2U",[["~$&","^@9"]]],"^?2",["^2U",[null]]],"^>[",[["^2U",["^@9"]]],"^?1",null,"^?M",0,"^?2",["^2U",[null]],"^8",1,"^?3",true,"^?N",[["^ ","^?M",0,"^?3",true,"^>M",["^S",["^??","^?O","^?I"]]]],"^7",310,"^?4","^?O","^9",310,"^?6",0,"^?7",true,"^>Q",["^2U",[["~$&","^@9"]]],"^>Z","Concatentate multiple sequences, but if any of them are nil or empty\n  collections, return nil. If any of them are :noseq, just skip them.\n  When complete, check the last element-- if it is a :right, and if it\n  the previous element is a :newline or :indent, then ensure that the\n  number of spaces in that previous element matches the number to the\n  right of the :right."],"~$prefix-options",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",5101,"^8",7,"^9",5101,"^:",21,"^>Q",["^2U",["^>R",["^2U",[["^>W","~$prefix-tag"]]]]],"^>Z","Change options as necessary based on prefix tag."],"^T","^6Q","^6","zprint/zprint.cljc","^:",21,"^>[",["^2U",[["^>W","^HJ"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",5101,"^?4",["^S",[null,"^??","^?O"]],"^9",5101,"^?6",2,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[["^>W","^HJ"]]]]],"^>Z","Change options as necessary based on prefix tag."],"~$indent-shift",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",2867,"^8",7,"^9",2867,"^:",19,"^>Q",["^2U",["^>R",["^2U",[["^?C","^>W","^?E","^G;","~$svec"]]]]],"^>Z","Take a style-vec that was once output from indent-zmap, and fix\n  up all of the :indent elements in it by adding (- actual-ind ind)\n  to them.  If we find a multiple thing in here, call indent-shift\n  recursively with the ind and cur-ind that is approprite.  All of\n  the actual indents are correct already -- all we are doing is\n  setting up their base.  There is no attempt to determine if we\n  are exceeding any configured width."],"^T","^7S","^6","zprint/zprint.cljc","^:",19,"^>[",["^2U",[["^?C","^>W","^?E","^G;","^HL"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",2867,"^?4",["^S",["^??","^?;"]],"^9",2867,"^?6",5,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[["^?C","^>W","^?E","^G;","^HL"]]]]],"^>Z","Take a style-vec that was once output from indent-zmap, and fix\n  up all of the :indent elements in it by adding (- actual-ind ind)\n  to them.  If we find a multiple thing in here, call indent-shift\n  recursively with the ind and cur-ind that is approprite.  All of\n  the actual indents are correct already -- all we are doing is\n  setting up their base.  There is no attempt to determine if we\n  are exceeding any configured width."],"~$tag-l-size",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",2736,"^8",7,"^9",2736,"^:",17,"^>Q",["^2U",["^>R",["^2U",[["~$t"]]]]],"^>Z","Given a tag into which you can go down from rewrite-clj, which must be\n  a collection of some kind, return the size the l-str.  All of the tag\n  values into which you can go down must be in this list for indent-before\n  to work correctly.  It uses these values when it steps up out of one of\n  these things to see how big the thing would have been if it showed up\n  as characters."],"^T","^7V","^6","zprint/zprint.cljc","^:",17,"^>[",["^2U",[["~$t"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",2736,"^9",2736,"^?6",1,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[["~$t"]]]]],"^>Z","Given a tag into which you can go down from rewrite-clj, which must be\n  a collection of some kind, return the size the l-str.  All of the tag\n  values into which you can go down must be in this list for indent-before\n  to work correctly.  It uses these values when it steps up out of one of\n  these things to see how big the thing would have been if it showed up\n  as characters."],"~$next-space",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",5403,"^8",7,"^9",5403,"^:",17,"^>Q",["^2U",["^>R",["^2U",[["~$s","^EA"]]]]],"^>Z","Take a string and an index, and look for the next space *after* the\n  index. If no space is found, return nil. Accept any from-index, \n  including one larger than the length of the string."],"^T","^6O","^6","zprint/zprint.cljc","^:",17,"^>[",["^2U",[["~$s","^EA"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",5403,"^?4",["^S",["^?H","^?I"]],"^9",5403,"^?6",2,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[["~$s","^EA"]]]]],"^>Z","Take a string and an index, and look for the next space *after* the\n  index. If no space is found, return nil. Accept any from-index, \n  including one larger than the length of the string."],"~$add-newline-to-comment",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",2599,"^8",7,"^9",2599,"^:",29,"^>Q",["^2U",["^>R",["^2U",[["^AA","~$fzprint*-return"]]]]],"^>Z","Given [[[\";stuff\" :none :comment]]] or \n  [[[\";bother\" :none :comment-inline 1]]] add [\"\n\" :none :newline]\n  to the inside of it."],"^T","^77","^6","zprint/zprint.cljc","^:",29,"^>[",["^2U",[["^AA","^HP"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",2599,"^?4",["^S",[null,"^5R"]],"^9",2599,"^?6",2,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[["^AA","^HP"]]]]],"^>Z","Given [[[\";stuff\" :none :comment]]] or \n  [[[\";bother\" :none :comment-inline 1]]] add [\"\n\" :none :newline]\n  to the inside of it."],"~$middle-element?",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",1287,"^8",7,"^9",1287,"^:",22,"^>Q",["^2U",["^>R",["^2U",[[["^ ","^>S",["^A:"],"^2X","^>W"],"^?R"]]]]],"^>Z","This checks to see if an element should be considered the middle element\n  of a pair.  At some point, we can expand this, but for now there is only\n  one middle element."],"^T","^88","^6","zprint/zprint.cljc","^:",22,"^>[",["^2U",[["~$p__45538","^?R"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",1287,"^?4",["^S",["^?5","^?I"]],"^9",1287,"^?6",2,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[[["^ ","^>S",["^A:"],"^2X","^>W"],"^?R"]]]]],"^>Z","This checks to see if an element should be considered the middle element\n  of a pair.  At some point, we can expand this, but for now there is only\n  one middle element."],"~$max-aligned-inline-comment-distance",["^ ","^T","^89","^6","zprint/zprint.cljc","^7",5573,"^8",1,"^9",5573,"^:",41,"^5",["^ ","^6","zprint/zprint.cljc","^7",5573,"^8",6,"^9",5573,"^:",41],"^>M","^?H"],"~$space-before-comment",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",5528,"^8",7,"^9",5528,"^:",27,"^>Q",["^2U",["^>R",["^2U",[["^?:"]]]]],"^>Z","Given a style-vec, whose last element in a comment, find the amount\n  of space before that comment on the line."],"^T","^7:","^6","zprint/zprint.cljc","^:",27,"^>[",["^2U",[["^?:"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",5528,"^?4","^?O","^9",5528,"^?6",1,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[["^?:"]]]]],"^>Z","Given a style-vec, whose last element in a comment, find the amount\n  of space before that comment on the line."],"~$fzprint-get-zloc-seq",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",2553,"^8",7,"^9",2553,"^:",27,"^>Q",["^2U",["^>R",["^2U",[["^?C","^>W","^?R"]]]]],"^>Z","Get the zloc seq, with or without newlines, as indicated by the options."],"^T","^6Z","^6","zprint/zprint.cljc","^:",27,"^>[",["^2U",[["^?C","^>W","^?R"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",2553,"^?4","^?O","^9",2553,"^?6",3,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[["^?C","^>W","^?R"]]]]],"^>Z","Get the zloc seq, with or without newlines, as indicated by the options."],"~$length-after-newline",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",2727,"^8",7,"^9",2727,"^:",27,"^>Q",["^2U",["^>R",["^2U",[["~$s"]]]]],"^>Z","Given a string, return the number of characters to the right\n  of any newlines in the string.  Will return nil if no newlines\n  in the string."],"^T","^84","^6","zprint/zprint.cljc","^:",27,"^>[",["^2U",[["~$s"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",2727,"^?4",["^S",["^?H","^?I"]],"^9",2727,"^?6",1,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[["~$s"]]]]],"^>Z","Given a string, return the number of characters to the right\n  of any newlines in the string.  Will return nil if no newlines\n  in the string."],"~$get-respect-indent",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",3261,"^8",7,"^9",3261,"^:",25,"^>Q",["^2U",["^>R",["^2U",[["^>W","^?C","~$backup"]]]]],"^>Z","Given an options map, get the respect-nl?, respect-bl? and indent-only?\n  options from the caller's options, and if the caller doesn't define these,\n  use the values from the backup section of the options map. Return\n  [respect-nl? respect-bl? indent-only?]"],"^T","^71","^6","zprint/zprint.cljc","^:",25,"^>[",["^2U",[["^>W","^?C","^HX"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",3261,"^?4","^?;","^9",3261,"^?6",3,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[["^>W","^?C","^HX"]]]]],"^>Z","Given an options map, get the respect-nl?, respect-bl? and indent-only?\n  options from the caller's options, and if the caller doesn't define these,\n  use the values from the backup section of the options map. Return\n  [respect-nl? respect-bl? indent-only?]"],"~$get-zloc-seq-right",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",2683,"^8",7,"^9",2683,"^:",25,"^>Q",["^2U",["^>R",["^2U",[[["~$_","~$_","~$next-count","^@3","^2X","~$input-data"]]]]]],"^>Z","Using return from fzprint-up-to-first-zloc or fzprint-up-to-next-zloc,\n  [pre-next-style-vec next-zloc next-count zloc-seq], return a zloc-seq\n  pointer to just beyond the specific zloc which was found by the\n  fzprint-up-to-first or fzprint-up-to-next call.  You don't give this\n  a number, you give it the data structure from the thing that you found."],"^T","^75","^6","zprint/zprint.cljc","^:",25,"^>[",["^2U",[["~$p__45773"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",2683,"^?4","^F?","^9",2683,"^?6",1,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[[["~$_","~$_","^HZ","^@3","^2X","^H["]]]]]],"^>Z","Using return from fzprint-up-to-first-zloc or fzprint-up-to-next-zloc,\n  [pre-next-style-vec next-zloc next-count zloc-seq], return a zloc-seq\n  pointer to just beyond the specific zloc which was found by the\n  fzprint-up-to-first or fzprint-up-to-next call.  You don't give this\n  a number, you give it the data structure from the thing that you found."],"~$fit-within?",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",1112,"^8",7,"^9",1112,"^:",18,"^>Q",["^2U",["^>R",["^2U",[["~$size","^?F","^DX"],["^I2","^?F"]]]]],"^>Z","Take a size and a collection of vectors with two or more elements\n  per vector.  The elements are zlocs, the vectors are not.  Return\n  the remaining character count or nil if it for sure doesn't fit.\n  In order to be sure it doesn't fit, this version doesn't assume\n  *any* separators, so it really underestimates the size.","^?L",["^ ","^?3",false,"^?M",3,"^?6",3,"^>[",[["^I2","^?F","^DX"],["^I2","^?F"]],"^>Q",["^2U",[["^I2","^?F","^DX"],["^I2","^?F"]]],"^?2",["^2U",[null,null]]]],"^T","^6A","^6","zprint/zprint.cljc","^:",18,"^?L",["^ ","^?3",false,"^?M",3,"^?6",3,"^>[",[["^I2","^?F","^DX"],["^I2","^?F"]],"^>Q",["^2U",[["^I2","^?F","^DX"],["^I2","^?F"]]],"^?2",["^2U",[null,null]]],"^>[",[["^I2","^?F","^DX"],["^I2","^?F"]],"^?1",null,"^?M",3,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^?N",[["^ ","^?M",3,"^?3",false,"^>M",["^S",[null,"^?O"]]],["^ ","^?M",2,"^?3",false,"^>M",["^S",[null,"^?O"]]]],"^7",1112,"^9",1112,"^?6",3,"^?7",true,"^>Q",["^2U",[["^I2","^?F","^DX"],["^I2","^?F"]]],"^>Z","Take a size and a collection of vectors with two or more elements\n  per vector.  The elements are zlocs, the vectors are not.  Return\n  the remaining character count or nil if it for sure doesn't fit.\n  In order to be sure it doesn't fit, this version doesn't assume\n  *any* separators, so it really underestimates the size."],"~$fzprint-pairs",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",1654,"^8",7,"^9",1654,"^:",20,"^>Q",["^2U",["^>R",["^2U",[[["^;J",[["^ ","^>S",["^?[","^@0"]],"~:pair","^2X","^>W"]],"^?E","^@3"]]]]],"^>Z","Always prints pairs on a different line from other pairs. Takes a zloc-seq"],"^T","^6<","^6","zprint/zprint.cljc","^:",20,"^>[",["^2U",[["~$p__45672","^?E","^@3"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",1654,"^?4","^?O","^9",1654,"^?6",3,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[[["^;J",[["^ ","^>S",["^?[","^@0"]],"^I4","^2X","^>W"]],"^?E","^@3"]]]]],"^>Z","Always prints pairs on a different line from other pairs. Takes a zloc-seq"],"~$trimr-blanks-element",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",4420,"^8",7,"^9",4420,"^:",27,"^>Q",["^2U",["^>R",["^2U",[[["~$s","^CL","~$what"]]]]]],"^>Z","Given an element, trim the blanks out of the string."],"^T","^7G","^6","zprint/zprint.cljc","^:",27,"^>[",["^2U",[["~$p__46004"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",4420,"^?4","^?;","^9",4420,"^?6",1,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[[["~$s","^CL","^I7"]]]]]],"^>Z","Given an element, trim the blanks out of the string."],"~$body-map",["^ ","^T","^5B","^6","zprint/zprint.cljc","^7",3224,"^8",1,"^9",3224,"^:",14,"^5",["^ ","^6","zprint/zprint.cljc","^7",3224,"^8",6,"^9",3224,"^:",14],"^>M","^?A"],"~$fzprint-wrap-comments",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",5496,"^8",7,"^9",5496,"^:",28,"^>Q",["^2U",["^>R",["^2U",[[["^ ","^>S",["^?="],"^2X","^>W"],"^?:"]]]]],"^>Z","Take the final output style-vec, and wrap any comments which run over\n  the width. Looking for "],"^T","^7>","^6","zprint/zprint.cljc","^:",28,"^>[",["^2U",[["~$p__46108","^?:"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",5496,"^?4",["^S",[null,"^?O"]],"^9",5496,"^?6",2,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[[["^ ","^>S",["^?="],"^2X","^>W"],"^?:"]]]]],"^>Z","Take the final output style-vec, and wrap any comments which run over\n  the width. Looking for "],"~$first-nl?",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",578,"^8",7,"^9",578,"^:",16,"^>Q",["^2U",["^>R",["^2U",[["^?:"]]]]],"^>Z","Look at a style vec ready to be given to concat-no-nil, and see if\n  the first thing in there is a newline of some sort."],"^T","^6;","^6","zprint/zprint.cljc","^:",16,"^>[",["^2U",[["^?:"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",578,"^?4","^?5","^9",578,"^?6",1,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[["^?:"]]]]],"^>Z","Look at a style vec ready to be given to concat-no-nil, and see if\n  the first thing in there is a newline of some sort."],"~$pair-element?",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",1278,"^8",7,"^9",1278,"^:",20,"^>Q",["^2U",["^>R",["^2U",[["^?R"]]]]],"^>Z","This checks to see if an element should be considered part of a\n  pair if it comes between other elements, and a single element on\n  its own if it would otherwise be the first part of a pair.  Mostly\n  this will trigger on comments, but a #_(...) element will also\n  trigger this, as will a newline if one appears."],"^T","^5@","^6","zprint/zprint.cljc","^:",20,"^>[",["^2U",[["^?R"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",1278,"^?4","^?O","^9",1278,"^?6",1,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[["^?R"]]]]],"^>Z","This checks to see if an element should be considered part of a\n  pair if it comes between other elements, and a single element on\n  its own if it would otherwise be the first part of a pair.  Mostly\n  this will trigger on comments, but a #_(...) element will also\n  trigger this, as will a newline if one appears."],"~$make-record",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",5899,"^8",7,"^9",5899,"^:",18,"^>Q",["^2U",["^>R",["^2U",[["^H:","^H;"]]]]]],"^T","^6L","^6","zprint/zprint.cljc","^:",18,"^>[",["^2U",[["^H:","^H;"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",5899,"^?4","^;G","^9",5899,"^?6",2,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[["^H:","^H;"]]]]]],"~$fzprint*",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",5141,"^8",7,"^9",5141,"^:",15,"^>Q",["^2U",["^>R",["^2U",[[["^ ","^>S",["^?=","^BW","^FT","~$hex?","~$shift-seq","^?T","^CR","^AT","^A7","~$string-str?","~$string-color","^DX","~$max-depth","~$trim-comments?","^A:","~$max-hang-depth","~$max-hang-span","~$max-hang-count","~$next-inner"],"^2X","^>W"],"^AA","^?R"]]]]],"^>Z","The pretty print part of fzprint."],"^T","^6K","^6","zprint/zprint.cljc","^:",15,"^>[",["^2U",[["~$p__46088","^AA","^?R"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",5141,"^?4",["^S",[null,"^??","^?;","^?O","^?I"]],"^9",5141,"^?6",3,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[[["^ ","^>S",["^?=","^BW","^FT","^I@","^IA","^?T","^CR","^AT","^A7","^IB","^IC","^DX","^ID","^IE","^A:","^IF","^IG","^IH","^II"],"^2X","^>W"],"^AA","^?R"]]]]],"^>Z","The pretty print part of fzprint."],"~$split-lf",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",49,"^8",7,"^9",49,"^:",15,"^>Q",["^2U",["^>R",["^2U",[["~$s"]]]]],"^>Z","Do split for newlines, instead of using regular expressions."],"^T","^6J","^6","zprint/zprint.cljc","^:",15,"^>[",["^2U",[["~$s"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",49,"^?4",["^S",["^??","^?;"]],"^9",49,"^?6",1,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[["~$s"]]]]],"^>Z","Do split for newlines, instead of using regular expressions."],"~$ignore-key-seq-silent",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",1314,"^8",7,"^9",1314,"^:",28,"^>Q",["^2U",["^>R",["^2U",[["~$m","^G>"]]]]],"^>Z","Given a map and a key sequence, remove that key sequence if\n  it appears in the map, and terminate the reduce if it changes\n  the map."],"^T","^6N","^6","zprint/zprint.cljc","^:",28,"^>[",["^2U",[["~$m","^G>"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",1314,"^?4",["^S",[null,"^??","^?O","^?I"]],"^9",1314,"^?6",2,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[["~$m","^G>"]]]]],"^>Z","Given a map and a key sequence, remove that key sequence if\n  it appears in the map, and terminate the reduce if it changes\n  the map."],"~$compare-keys",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",1244,"^8",7,"^9",1244,"^:",19,"^>Q",["^2U",["^>R",["^2U",[["~$x","~$y"]]]]],"^>Z","Do a key comparison that works well for numbers as well as\n  strings."],"^T","^5T","^6","zprint/zprint.cljc","^:",19,"^>[",["^2U",[["~$x","~$y"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",1244,"^?4","^?H","^9",1244,"^?6",2,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[["~$x","~$y"]]]]],"^>Z","Do a key comparison that works well for numbers as well as\n  strings."],"~$interpose-nl-hf",["^ ","^>P",null,"^5",["^ ","^6","zprint/zprint.cljc","^7",4564,"^8",7,"^9",4564,"^:",22,"^>Q",["^2U",["^>R",["^2U",[["^F9","^?E","^?F"]]]]],"^>Z","Put a single or double line between pairs returned from\n  fzprint-map-two-up.  The second argument is the map resulting\n  from (:map options) or (:pair options) or whatever.  It should\n  have :nl-separator? and :nl-separator-flow? in it."],"^T","^5N","^6","zprint/zprint.cljc","^:",22,"^>[",["^2U",[["^F9","^?E","^?F"]]],"^?1",null,"^?2",["^2U",[null,null]],"^8",1,"^?3",false,"^7",4564,"^?4","^?O","^9",4564,"^?6",3,"^?7",true,"^>Q",["^2U",["^>R",["^2U",[["^F9","^?E","^?F"]]]]],"^>Z","Put a single or double line between pairs returned from\n  fzprint-map-two-up.  The second argument is the map resulting\n  from (:map options) or (:pair options) or whatever.  It should\n  have :nl-separator? and :nl-separator-flow? in it."]],"^1:",["^ ","^M","^M","^11","^11"],"~:cljs.analyzer/constants",["^ ","^18",["^S",["~:in-code?","~:newline-first","~:comment-wrap","~:prefix-tags","~:flow?","~:sort-in-code?","~:nl-separator?","~:hang-size","~:nl-first","~:gt3-force-nl","~:dbg","~:indent-arg","~:arg2-extend","~:arg2-pair","~:ha-depth-factor","~:true","~:key-depth-color","~:wrap-coll?","~:constant-pair?","~:indent","~:max-length","^DE","~:comma?","~:record-type?","~:fn","~:justify?","~:fn-force-nl","~:max-hang-depth","~:dbg-hang","~:arg1-body","~:input-hang","~:unquote-splicing","~:future","~:justify-tuning","~:zprint-not-found","~:arg2","~:max-depth-string","~:whitespace","~:ha-width-factor","~:element","~:user-fn-map","~:hash-paren","~:next-inner","~:pair-fn","^BH","~:else","~:force-nl","~:number","~:zipper","~:arg1-extend","^H:","~:unknown","~:replace-w-string","~:promise","~:arg1-pair","~:hang-expand","~:brace","~:unquote","~:default","^I4","~:flow","~:noarg1","~:noarg1-body","^W","~:symbol","~:key-value-color","~:constant-pair-min","~:key-value","~:sexpr","~:in-hang?","~:comma","~:dbg-ge","~:value","~:user-fn","~:rightcnt","~:dbg-indent","~:force-nl?","~:width","~:gt2-force-nl","~:respect-nl?","~:uneval","~:key-ignore-silent","~:key-order","~:color-map","~:aligned","~:arg1-pair-body","~:undef","~:key-ignore","~:false","~:agent","~:do-in-hang?","~:respect-bl?","~:string","~:no-arg1?","~:vector","~:hex?","~:array","~:empty","~:inline-align-style","~:hang-accept","~:object?","~:force-nl-body","~:map-depth","~:arg2-fn","~:hang-avoid","~:dbg-cnt?","~:hang-diff","~:paren","~:dbg-print?","~:option-fn","~:zprint-ignored","^A1","~:no-nl-first","~:count?","~:lift-ns-in-code?","~:fn-gt2-force-nl","~:spec","~:syntax-quote","^G4","~:inline?","~:modifiers","~:hang-type-flow","~:arg1-force-nl","~:wrap?","~:hang-adjust","~:dbg-local?","~:hang","~:dbg?","~:justify-hang","~:list","~:var","~:quote","~:keyword","~:ztype","~:wrap-after-multi?","~:flow-body","~:hang-flow","~:binding?","~:key-color","~:string-color","~:syntax-quote-paren","~:trim-comments?","~:general-hang-adjust","~:nil","~:max-hang-span","~:deref","~:bracket","^C>","~:comment","~:none-hang","~:comment-inline","~:none-hang-one","~:fn-style","~:lift-ns?","~:to-string?","~:right","~:fn-gt3-force-nl","~:one-line?","~:nl-separator-flow?","~:option-fn-first","~:string-str?","~:depth","~:regex","~:hang-if-equal-flow?","~:fn-format","~:noseq","~:arg1-mixin","~:on","~:max-depth","~:first-indent-only?","~:arg1->","~:vector-fn","~:set","~:dbg-bug?","~:fn-map","~:none-two-up","~:hang?","~:indent-only?","~:pdepth","~:none-body","~:hang-flow-limit","~:shift-seq","^BL","~:hash-brace","~:force-eol-blanks?","~:newline","~:return-altered-zipper","~$...","~:rightmost-pair","~:consecutive","~:max-hang-count","~:parallel?","~:sort?","~:delay","^H3","~:replacement-string","~:object","^H;","~:arg1","~:none","~:reader-cond","~:char","~:indent-only-style","~:rightmost","~:left"]],"~:order",["^L3","^K>","^K8","^W","^JK","^DE","^LM","^L>","^ML","^LS","^M;","^JX","^L1","^IW","^LA","^K@","^K=","^LD","^LC","^KM","^M9","^M=","^M3","^MP","^J7","^MF","^J8","^LX","^LZ","^JO","^JH","^L7","^JJ","^N0","^K:","^LW","^LH","^L2","^L;","^JB","^JZ","^MN","^JL","^JY","^KC","^LV","^KF","^K0","^KV","^J2","^JI","^MH","^IT","^I[","^J4","^K4","^L0","^LB","^LO","^M5","^KY","^N4","^L=","^MG","^JP","^IQ","^J<","^K?","^MV","^LE","^JD","^MS","^MW","^IU","^KE","^K6","^IP","^JE","^L5","^KJ","^KD","^G4","^IV","^N5","^KQ","^MO","^LY","^I4","^KB","^BH","^M0","^J;","^LI","^K[","^J?","^MJ","^L[","^J6","^K5","^IX","^KN","^LJ","^JR","^LK","^K9","^MK","^IY","^J@","^JF","^K1","^K2","^KA","^KX","^KZ","^L?","^LL","^M[","^H3","^LF","^J9","^N3","^JA","^J1","^JN","^KH","^MB","^JW","^JS","^KP","^J0","^KI","^MI","^J=","^L9","^M4","^MQ","^MR","^J[","^JU","^MY","^KT","^M>","^J5","^L4","^L@","^LN","^M7","^M<","^MC","^L6","^KS","^MD","^M6","^M1","^L8","^K7","^MZ","^BL","^KW","^JT","^JC","^JV","^MX","^KL","^M8","^A1","^LP","^C>","^J:","^M2","^MA","^N1","^ME","^LG","^LQ","^M@","^MM","^MU","^J>","^JM","^KR","^LR","^LU","^IZ","^M?","^JG","^IS","^L<","^KO","^K<","^JQ","^K3","^LT","^J3","^KK","^N2","^M:","^IR","^KU","^KG","^MT","^K;","^L:","^H:","^H;"]],"^2Y",["^ ","^1:",["^S",[]],"^19",["^S",[]]],"^2Z",["^ "],"^2[",["^13","^11","^16","^12","^14","^15","^[","^17","^Z","^10"]],"^W","^U","~:ns-specs",["^ "],"~:ns-spec-vars",["^S",[]],"~:compiler-options",["^;J",[["^N9","~:static-fns"],true,["^N9","~:shadow-tweaks"],null,["^N9","~:source-map-inline"],null,["^N9","~:elide-asserts"],false,["^N9","~:optimize-constants"],null,["^N9","^34"],null,["^N9","~:external-config"],null,["^N9","~:tooling-config"],null,["^N9","~:emit-constants"],null,["^N9","~:load-tests"],null,["^N9","~:form-size-threshold"],null,["^N9","~:data-readers"],null,["^N9","~:infer-externs"],"~:auto",["^N9","^36"],null,["~:js-options","~:js-provider"],"~:shadow",["~:mode"],"~:dev",["^N9","~:fn-invoke-direct"],null,["^N9","~:source-map"],"/dev/null"]]]